########################################
docu-indautoref.txt - lunghezza: 112081
########################################
Indicator Reference

AccelerationDecelerationOscillator

Alias:

```
* AccDeOsc

```

Acceleration/Deceleration Technical Indicator (AC) measures acceleration
and deceleration of the current driving force. This indicator will change
direction before any changes in the driving force, which, it its turn, will
change its direction before the price.

Formula:

```
* AcdDecOsc = AwesomeOscillator - SMA(AwesomeOscillator, period)

```

See:

```
* [https://www.metatrader5.com/en/terminal/help/indicators/bw_indicators/ao](https://www.metatrader5.com/en/terminal/help/indicators/bw_indicators/ao)

* [https://www.ifcmarkets.com/en/ntx-indicators/ntx-indicators-accelerator-decelerator-oscillator](https://www.ifcmarkets.com/en/ntx-indicators/ntx-indicators-accelerator-decelerator-oscillator)

```

Lines:

```
* accde

```

Params:

```
* period (5)

* movav (SMA)

```

PlotInfo:

```
* plot (True)

* plotmaster (None)

* legendloc (None)

* subplot (True)

* plotname ()

* plotskip (False)

* plotabove (False)

* plotlinelabels (False)

* plotlinevalues (True)

* plotvaluetags (True)

```

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

accde:

_method (bar)

alpha (0.5)

width (1.0)

Accum

Alias:

CumSum, CumulativeSum

Cummulative sum of the data values

Formula:

accum += data

Lines:

accum

Params:

seed (0.0)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

accum:

AdaptiveMovingAverage

Alias:

KAMA, MovingAverageAdaptive

Defined by Perry Kaufman in his book “Smarter Trading”.

It is A Moving Average with a continuously scaled smoothing factor by
taking into account market direction and volatility. The smoothing factor
is calculated from 2 ExponetialMovingAverage smoothing factors, a fast one
and slow one.

If the market trends the value will tend to the fast ema smoothing
period. If the market doesn’t trend it will move towards the slow EMA
smoothing period.

It is a subclass of SmoothingMovingAverage, overriding once to account for
the live nature of the smoothing factor

Formula:

direction = close - close_period

volatility = sumN(abs(close - close_n), period)

effiency_ratio = abs(direction / volatility)

fast = 2 / (fast_period + 1)

slow = 2 / (slow_period + 1)

smfactor = squared(efficienty_ratio * (fast - slow) + slow)

smfactor1 = 1.0  - smfactor

The initial seed value is a SimpleMovingAverage

See also:

http://fxcodebase.com/wiki/index.php/Kaufman’s_Adaptive_Moving_Average_(KAMA
)

http://www.metatrader5.com/en/terminal/help/analytics/indicators/trend_indicators/ama

http://help.cqg.com/cqgic/default.htm#!Documents/adaptivemovingaverag2.htm

Lines:

kama

Params:

period (30)

fast (2)

slow (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

kama:

AdaptiveMovingAverageEnvelope

Alias:

KAMAEnvelope, MovingAverageAdaptiveEnvelope

AdaptiveMovingAverage and envelope bands separated “perc” from it

Formula:

kama (from AdaptiveMovingAverage)

top = kama * (1 + perc)

bot = kama * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

kama

top

bot

Params:

period (30)

fast (2)

slow (30)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

kama:

top:

_samecolor (True)

bot:

_samecolor (True)

AdaptiveMovingAverageOscillator

Alias:

AdaptiveMovingAverageOsc, KAMAOscillator, KAMAOsc, MovingAverageAdaptiveOscillator, MovingAverageAdaptiveOsc

Oscillation of a AdaptiveMovingAverage around its data

Lines:

kama

Params:

period (30)

fast (2)

slow (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

kama:

_0:

_name (osc)

AllN

Has a value of 
True
 (stored as 
1.0
 in the lines) if 
all
 of the
values in the 
period
 evaluates to non-zero (ie: 
True
)

Uses the built-in 
all
 for the calculation

Formula:

alln = all(data, period)

Lines:

alln

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

alln:

AnyN

Has a value of 
True
 (stored as 
1.0
 in the lines) if 
any
 of the
values in the 
period
 evaluates to non-zero (ie: 
True
)

Uses the built-in 
any
 for the calculation

Formula:

anyn = any(data, period)

Lines:

anyn

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

anyn:

ApplyN

Calculates 
func
 for a given period

Formula:

line = func(data, period)

Lines:

apply

Params:

period (1)

func (None)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

apply:

AroonDown

This is the AroonDown from the indicator AroonUpDown developed by Tushar
Chande in 1995.

Formula:

down = 100 * (period - distance to lowest low) / period

Note:

```
The lines oscillate between 0 and 100. That means that the “distance” to
the last highest or lowest must go from 0 to period so that the formula
can yield 0 and 100.

Hence the lookback period is period + 1, because the current bar is also
taken into account. And therefore this indicator needs an effective
lookback period of period + 1.

```

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:aroon

Lines:

aroondown

Params:

period (14)

upperband (70)

lowerband (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.05)

plotyhlines ([0, 100])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

aroondown:

AroonOscillator

Alias:

AroonOsc

It is a variation of the AroonUpDown indicator which shows the current
difference between the AroonUp and AroonDown value, trying to present a
visualization which indicates which is stronger (greater than 0 -> AroonUp
and less than 0 -> AroonDown)

Formula:

aroonosc = aroonup - aroondown

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:aroon

Lines:

aroonosc

Params:

period (14)

upperband (70)

lowerband (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.05)

plotyhlines ([0, 100])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

aroonosc:

AroonUp

This is the AroonUp from the indicator AroonUpDown developed by Tushar
Chande in 1995.

Formula:

up = 100 * (period - distance to highest high) / period

Note:

```
The lines oscillate between 0 and 100. That means that the “distance” to
the last highest or lowest must go from 0 to period so that the formula
can yield 0 and 100.

Hence the lookback period is period + 1, because the current bar is also
taken into account. And therefore this indicator needs an effective
lookback period of period + 1.

```

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:aroon

Lines:

aroonup

Params:

period (14)

upperband (70)

lowerband (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.05)

plotyhlines ([0, 100])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

aroonup:

AroonUpDown

Alias:

AroonIndicator

Developed by Tushar Chande in 1995.

It tries to determine if a trend exists or not by calculating how far away
within a given period the last highs/lows are (AroonUp/AroonDown)

Formula:

up = 100 * (period - distance to highest high) / period

down = 100 * (period - distance to lowest low) / period

Note:

```
The lines oscillate between 0 and 100. That means that the “distance” to
the last highest or lowest must go from 0 to period so that the formula
can yield 0 and 100.

Hence the lookback period is period + 1, because the current bar is also
taken into account. And therefore this indicator needs an effective
lookback period of period + 1.

```

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:aroon

Lines:

aroonup

aroondown

Params:

period (14)

upperband (70)

lowerband (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.05)

plotyhlines ([0, 100])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

aroonup:

aroondown:

AroonUpDownOscillator

Alias:

AroonUpDownOsc

Presents together the indicators AroonUpDown and AroonOsc

Formula:

```
(None, uses the aforementioned indicators)

```

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:aroon

Lines:

aroonup

aroondown

aroonosc

Params:

period (14)

upperband (70)

lowerband (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.05)

plotyhlines ([0, 100])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

aroonup:

aroondown:

aroonosc:

Average

Alias:

ArithmeticMean, Mean

Averages a given data arithmetically over a period

Formula:

av = data(period) / period

See also:

https://en.wikipedia.org/wiki/Arithmetic_mean

Lines:

av

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

av:

AverageDirectionalMovementIndex

Alias:

ADX

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
.

Intended to measure trend strength

This indicator only shows ADX:

Use PlusDirectionalIndicator (PlusDI) to get +DI

Use MinusDirectionalIndicator (MinusDI) to get -DI

Use Directional Indicator (DI) to get +DI, -DI

Use AverageDirectionalIndexRating (ADXR) to get ADX, ADXR

Use DirectionalMovementIndex (DMI) to get ADX, +DI, -DI

Use DirectionalMovement (DM) to get ADX, ADXR, +DI, -DI

Formula:

upmove = high - high(-1)

downmove = low(-1) - low

+dm = upmove if upmove > downmove and upmove > 0 else 0

-dm = downmove if downmove > upmove and downmove > 0 else 0

+di = 100 * MovingAverage(+dm, period) / atr(period)

-di = 100 * MovingAverage(-dm, period) / atr(period)

dx = 100 * abs(+di - -di) / (+di + -di)

adx = MovingAverage(dx, period)

The moving average used is the one originally defined by Wilder,
the SmoothedMovingAverage

See:

https://en.wikipedia.org/wiki/Average_directional_movement_index

Lines:

adx

Params:

period (14)

movav (SmoothedMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

plusDI:

_name (+DI)

minusDI:

_name (-DI)

adx:

_name (ADX)

AverageDirectionalMovementIndexRating

Alias:

ADXR

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
.

Intended to measure trend strength.

ADXR is the average of ADX with a value period bars ago

This indicator shows the ADX and ADXR:

Use PlusDirectionalIndicator (PlusDI) to get +DI

Use MinusDirectionalIndicator (MinusDI) to get -DI

Use Directional Indicator (DI) to get +DI, -DI

Use AverageDirectionalIndex (ADX) to get ADX

Use DirectionalMovementIndex (DMI) to get ADX, +DI, -DI

Use DirectionalMovement (DM) to get ADX, ADXR, +DI, -DI

Formula:

upmove = high - high(-1)

downmove = low(-1) - low

+dm = upmove if upmove > downmove and upmove > 0 else 0

-dm = downmove if downmove > upmove and downmove > 0 else 0

+di = 100 * MovingAverage(+dm, period) / atr(period)

-di = 100 * MovingAverage(-dm, period) / atr(period)

dx = 100 * abs(+di - -di) / (+di + -di)

adx = MovingAverage(dx, period)

adxr = (adx + adx(-period)) / 2

The moving average used is the one originally defined by Wilder,
the SmoothedMovingAverage

See:

https://en.wikipedia.org/wiki/Average_directional_movement_index

Lines:

adx

adxr

Params:

period (14)

movav (SmoothedMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

plusDI:

_name (+DI)

minusDI:

_name (-DI)

adx:

_name (ADX)

adxr:

_name (ADXR)

AverageTrueRange

Alias:

ATR

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
.

The idea is to take the close into account to calculate the range if it
yields a larger range than the daily range (High - Low)

Formula:

SmoothedMovingAverage(TrueRange, period)

See:

http://en.wikipedia.org/wiki/Average_true_range

Lines:

atr

Params:

period (14)

movav (SmoothedMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

atr:

AwesomeOscillator

Alias:

AwesomeOsc, AO

Awesome Oscillator (AO) is a momentum indicator reflecting the precise
changes in the market driving force which helps to identify the trend’s
strength up to the points of formation and reversal.

Formula:

median price = (high + low) / 2

AO = SMA(median price, 5)- SMA(median price, 34)

See:

https://www.metatrader5.com/en/terminal/help/indicators/bw_indicators/awesome

https://www.ifcmarkets.com/en/ntx-indicators/awesome-oscillator

Lines:

ao

Params:

fast (5)

slow (34)

movav (SMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

ao:

_method (bar)

alpha (0.5)

width (1.0)

BaseApplyN

Base class for ApplyN and others which may take a 
func
 as a parameter
but want to define the lines in the indicator.

Calculates 
func
 for a given period where func is given as a parameter,
aka named argument or 
kwarg

Formula:

lines[0] = func(data, period)

Any extra lines defined beyond the first (index 0) are not calculated

Params:

period (1)

func (None)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

BollingerBands

Alias:

BBands

Defined by John Bollinger in the 80s. It measures volatility by defining
upper and lower bands at distance x standard deviations

Formula:

midband = SimpleMovingAverage(close, period)

topband = midband + devfactor * StandardDeviation(data, period)

botband = midband - devfactor * StandardDeviation(data, period)

See:

http://en.wikipedia.org/wiki/Bollinger_Bands

Lines:

mid

top

bot

Params:

period (20)

devfactor (2.0)

movav (MovingAverageSimple)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

mid:

ls (–)

top:

_samecolor (True)

bot:

_samecolor (True)

BollingerBandsPct

Extends the Bollinger Bands with a Percentage line

Lines:

mid

top

bot

pctb

Params:

period (20)

devfactor (2.0)

movav (MovingAverageSimple)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

mid:

ls (–)

top:

_samecolor (True)

bot:

_samecolor (True)

pctb:

_name (%B)

CointN

Calculates the score (coint_t) and pvalue for a given 
period
 for the
data feeds

Uses 
pandas
 and 
statsmodels
 (for 
coint
)

Lines:

score

pvalue

Params:

period (10)

regression ©

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

score:

pvalue:

CommodityChannelIndex

Alias:

CCI

Introduced by Donald Lambert in 1980 to measure variations of the
“typical price” (see below) from its mean to identify extremes and
reversals

Formula:

tp = typical_price = (high + low + close) / 3

tpmean = MovingAverage(tp, period)

deviation = tp - tpmean

meandev = MeanDeviation(tp)

cci = deviation / (meandeviation * factor)

See:

https://en.wikipedia.org/wiki/Commodity_channel_index

Lines:

cci

Params:

period (20)

factor (0.015)

movav (MovingAverageSimple)

upperband (100.0)

lowerband (-100.0)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

cci:

CrossDown

This indicator gives a signal if the 1
st
 provided data crosses over the 2
nd

indicator upwards

It does need to look into the current time index (0) and the previous time
index (-1) of both the 1
st
 and 2
nd
 data

Formula:

diff = data - data1

downcross = last_non_zero_diff > 0 and data0(0) < data1(0)

Lines:

cross

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.05)

plotyhlines ([0.0, 1.0])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

cross:

CrossOver

This indicator gives a signal if the provided datas (2) cross up or down.

1.0 if the 1
st
 data crosses the 2
nd
 data upwards

-1.0 if the 1
st
 data crosses the 2
nd
 data downwards

It does need to look into the current time index (0) and the previous time
index (-1) of both the 1t and 2
nd
 data

Formula:

diff = data - data1

upcross =  last_non_zero_diff < 0 and data0(0) > data1(0)

downcross = last_non_zero_diff > 0 and data0(0) < data1(0)

crossover = upcross - downcross

Lines:

crossover

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.05)

plotyhlines ([-1.0, 1.0])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

crossover:

CrossUp

This indicator gives a signal if the 1
st
 provided data crosses over the 2
nd

indicator upwards

It does need to look into the current time index (0) and the previous time
index (-1) of both the 1
st
 and 2
nd
 data

Formula:

diff = data - data1

upcross =  last_non_zero_diff < 0 and data0(0) > data1(0)

Lines:

cross

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.05)

plotyhlines ([0.0, 1.0])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

cross:

DV2

RSI(2) alternative
Developed by David Varadi of 
http://cssanalytics.wordpress.com/

This seems to be the 
Bounded
 version.

See also:

http://web.archive.org/web/20131216100741/http://quantingdutchman.wordpress.com/2010/08/06/dv2-indicator-for-amibroker/

Lines:

dv2

Params:

period (252)

maperiod (2)

_movav (SMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

dv2:

DemarkPivotPoint

Defines a level of significance by taking into account the average of price
bar components of the past period of a larger timeframe. For example when
operating with days, the values are taking from the already “past” month
fixed prices.

Example of using this indicator:

data = btfeeds.ADataFeed(dataname=x, timeframe=bt.TimeFrame.Days)
  cerebro.adddata(data)
  cerebro.resampledata(data, timeframe=bt.TimeFrame.Months)

In the 
__init__
 method of the strategy:

pivotindicator = btind.DemarkPivotPoiont(self.data1)  # the resampled data

The indicator will try to automatically plot to the non-resampled data. To
disable this behavior use the following during construction:

_autoplot=False

Note:

The example shows 
days
 and 
months
, but any combination of timeframes
  can be used. See the literature for recommended combinations

Formula:

if close < open x = high + (2 x low) + close

if close > open x = (2 x high) + low + close

if Close == open x = high + low + (2 x close)

p = x / 4

support1 = x / 2 - high

resistance1 = x / 2 - low

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:pivot_points

Lines:

p

s1

r1

Params:

open (False)

close (False)

_autoplot (True)

level1 (0.382)

level2 (0.618)

level3 (1.0)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

p:

s1:

r1:

DetrendedPriceOscillator

Alias:

DPO

Defined by Joe DiNapoli in his book 
“Trading with DiNapoli levels”

It measures the price variations against a Moving Average (the trend)
and therefore removes the “trend” factor from the price.

Formula:

movav = MovingAverage(close, period)

dpo = close - movav(shifted period / 2 + 1)

See:

http://en.wikipedia.org/wiki/Detrended_price_oscillator

Lines:

dpo

Params:

period (20)

movav (MovingAverageSimple)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

dpo:

DicksonMovingAverage

Alias:

DMA, DicksonMA

By Nathan Dickson

The 
Dickson Moving Average
 combines the 
ZeroLagIndicator
 (aka

ErrorCorrecting
 or 
EC
) by 
Ehlers
, and the 
HullMovingAverage
 to
try to deliver a result close to that of the 
Jurik
 Moving Averages

Formula:

ec = ZeroLagIndicator(period, gainlimit)

hma = HullMovingAverage(hperiod)

dma = (ec + hma) / 2

The default moving average for the 
ZeroLagIndicator
 is EMA, but can
      be changed with the parameter 
_movav

-
NOTE
*: the passed moving average must calculate alpha (and 1 -
  alpha) and make them available as attributes 
alpha
 and

alpha1

The 2
nd
 moving averag can be changed from 
Hull
 to anything else with
      the param 
_hma

See also:

https://www.reddit.com/r/algotrading/comments/4xj3vh/dickson_moving_average

Lines:

dma

Params:

period (30)

gainlimit (50)

hperiod (7)

_movav (EMA)

_hma (HMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

dma:

DicksonMovingAverageEnvelope

Alias:

DMAEnvelope, DicksonMAEnvelope

DicksonMovingAverage and envelope bands separated “perc” from it

Formula:

dma (from DicksonMovingAverage)

top = dma * (1 + perc)

bot = dma * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

dma

top

bot

Params:

period (30)

gainlimit (50)

hperiod (7)

_movav (EMA)

_hma (HMA)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

dma:

top:

_samecolor (True)

bot:

_samecolor (True)

DicksonMovingAverageOscillator

Alias:

DicksonMovingAverageOsc, DMAOscillator, DMAOsc, DicksonMAOscillator, DicksonMAOsc

Oscillation of a DicksonMovingAverage around its data

Lines:

dma

Params:

period (30)

gainlimit (50)

hperiod (7)

_movav (EMA)

_hma (HMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

dma:

_0:

_name (osc)

DirectionalIndicator

Alias:

DI

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
.

Intended to measure trend strength

This indicator shows +DI, -DI:

Use PlusDirectionalIndicator (PlusDI) to get +DI

Use MinusDirectionalIndicator (MinusDI) to get -DI

Use AverageDirectionalIndex (ADX) to get ADX

Use AverageDirectionalIndexRating (ADXR) to get ADX, ADXR

Use DirectionalMovementIndex (DMI) to get ADX, +DI, -DI

Use DirectionalMovement (DM) to get ADX, ADXR, +DI, -DI

Formula:

upmove = high - high(-1)

downmove = low(-1) - low

+dm = upmove if upmove > downmove and upmove > 0 else 0

-dm = downmove if downmove > upmove and downmove > 0 else 0

+di = 100 * MovingAverage(+dm, period) / atr(period)

-di = 100 * MovingAverage(-dm, period) / atr(period)

The moving average used is the one originally defined by Wilder,
the SmoothedMovingAverage

See:

https://en.wikipedia.org/wiki/Average_directional_movement_index

Lines:

plusDI

minusDI

Params:

period (14)

movav (SmoothedMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

plusDI:

minusDI:

DirectionalMovement

Alias:

DM

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
.

Intended to measure trend strength

This indicator shows ADX, ADXR, +DI, -DI.

Use PlusDirectionalIndicator (PlusDI) to get +DI

Use MinusDirectionalIndicator (MinusDI) to get -DI

Use Directional Indicator (DI) to get +DI, -DI

Use AverageDirectionalIndex (ADX) to get ADX

Use AverageDirectionalIndexRating (ADXR) to get ADX, ADXR

Use DirectionalMovementIndex (DMI) to get ADX, +DI, -DI

Formula:

upmove = high - high(-1)

downmove = low(-1) - low

+dm = upmove if upmove > downmove and upmove > 0 else 0

-dm = downmove if downmove > upmove and downmove > 0 else 0

+di = 100 * MovingAverage(+dm, period) / atr(period)

-di = 100 * MovingAverage(-dm, period) / atr(period)

dx = 100 * abs(+di - -di) / (+di + -di)

adx = MovingAverage(dx, period)

The moving average used is the one originally defined by Wilder,
the SmoothedMovingAverage

See:

https://en.wikipedia.org/wiki/Average_directional_movement_index

Lines:

adx

adxr

plusDI

minusDI

Params:

period (14)

movav (SmoothedMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

plusDI:

minusDI:

adx:

_name (ADX)

adxr:

_name (ADXR)

DirectionalMovementIndex

Alias:

DMI

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
.

Intended to measure trend strength

This indicator shows the ADX, +DI, -DI:

Use PlusDirectionalIndicator (PlusDI) to get +DI

Use MinusDirectionalIndicator (MinusDI) to get -DI

Use Directional Indicator (DI) to get +DI, -DI

Use AverageDirectionalIndex (ADX) to get ADX

Use AverageDirectionalIndexRating (ADXRating) to get ADX, ADXR

Use DirectionalMovement (DM) to get ADX, ADXR, +DI, -DI

Formula:

upmove = high - high(-1)

downmove = low(-1) - low

+dm = upmove if upmove > downmove and upmove > 0 else 0

-dm = downmove if downmove > upmove and downmove > 0 else 0

+di = 100 * MovingAverage(+dm, period) / atr(period)

-di = 100 * MovingAverage(-dm, period) / atr(period)

dx = 100 * abs(+di - -di) / (+di + -di)

adx = MovingAverage(dx, period)

The moving average used is the one originally defined by Wilder,
the SmoothedMovingAverage

See:

https://en.wikipedia.org/wiki/Average_directional_movement_index

Lines:

adx

plusDI

minusDI

Params:

period (14)

movav (SmoothedMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

plusDI:

minusDI:

adx:

_name (ADX)

DoubleExponentialMovingAverage

Alias:

DEMA, MovingAverageDoubleExponential

DEMA was first time introduced in 1994, in the article “Smoothing Data with
Faster Moving Averages” by Patrick G. Mulloy in “Technical Analysis of
Stocks & Commodities” magazine.

It attempts to reduce the inherent lag associated to Moving Averages

Formula:

dema = (2.0 - ema(data, period) - ema(ema(data, period), period)

See:

```
(None)

```

Lines:

dema

Params:

period (30)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

dema:

DoubleExponentialMovingAverageEnvelope

Alias:

DEMAEnvelope, MovingAverageDoubleExponentialEnvelope

DoubleExponentialMovingAverage and envelope bands separated “perc” from it

Formula:

dema (from DoubleExponentialMovingAverage)

top = dema * (1 + perc)

bot = dema * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

dema

top

bot

Params:

period (30)

_movav (EMA)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

dema:

top:

_samecolor (True)

bot:

_samecolor (True)

DoubleExponentialMovingAverageOscillator

Alias:

DoubleExponentialMovingAverageOsc, DEMAOscillator, DEMAOsc, MovingAverageDoubleExponentialOscillator, MovingAverageDoubleExponentialOsc

Oscillation of a DoubleExponentialMovingAverage around its data

Lines:

dema

Params:

period (30)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

dema:

_0:

_name (osc)

DownDay

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
 for the RSI

Records days which have been “down”, i.e.: the close price has been
lower than the day before.

Formula:

downday = max(close_prev - close, 0)

See:

http://en.wikipedia.org/wiki/Relative_strength_index

Lines:

downday

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

downday:

DownDayBool

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
 for the RSI

Records days which have been “down”, i.e.: the close price has been
lower than the day before.

Note:

This version returns a bool rather than the difference

Formula:

downday = close_prev > close

See:

http://en.wikipedia.org/wiki/Relative_strength_index

Lines:

downday

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

downday:

DownMove

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
 as part of the Directional Move System to
calculate Directional Indicators.

Positive if the given data has moved lower than the previous day

Formula:

downmove = data(-1) - data

See:

https://en.wikipedia.org/wiki/Average_directional_movement_index

Lines:

downmove

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

downmove:

Envelope

It creates envelopes bands separated from the source data by a given
percentage

Formula:

src = datasource

top = src * (1 + perc)

bot = src * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

src

top

bot

Params:

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

src:

_plotskip (True)

top:

_samecolor (True)

bot:

_samecolor (True)

ExponentialMovingAverage

Alias:

EMA, MovingAverageExponential

A Moving Average that smoothes data exponentially over time.

It is a subclass of SmoothingMovingAverage.

self.smfactor -> 2 / (1 + period)

self.smfactor1 -> 1 - self.smfactor

Formula:

movav = prev * (1.0 - smoothfactor) + newdata * smoothfactor

See also:

http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average

Lines:

ema

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

ema:

ExponentialMovingAverageEnvelope

Alias:

EMAEnvelope, MovingAverageExponentialEnvelope

ExponentialMovingAverage and envelope bands separated “perc” from it

Formula:

ema (from ExponentialMovingAverage)

top = ema * (1 + perc)

bot = ema * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

ema

top

bot

Params:

period (30)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

ema:

top:

_samecolor (True)

bot:

_samecolor (True)

ExponentialMovingAverageOscillator

Alias:

ExponentialMovingAverageOsc, EMAOscillator, EMAOsc, MovingAverageExponentialOscillator, MovingAverageExponentialOsc

Oscillation of a ExponentialMovingAverage around its data

Lines:

ema

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

ema:

_0:

_name (osc)

ExponentialSmoothing

Alias:

ExpSmoothing

Averages a given data over a period using exponential smoothing

A regular ArithmeticMean (Average) is used as the seed value considering
the first period values of data

Formula:

av = prev * (1 - alpha) + data * alpha

See also:

https://en.wikipedia.org/wiki/Exponential_smoothing

Lines:

av

Params:

period (1)

alpha (None)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

av:

ExponentialSmoothingDynamic

Alias:

ExpSmoothingDynamic

Averages a given data over a period using exponential smoothing

A regular ArithmeticMean (Average) is used as the seed value considering
the first period values of data

Note:

alpha is an array of values which can be calculated dynamically

Formula:

av = prev * (1 - alpha) + data * alpha

See also:

https://en.wikipedia.org/wiki/Exponential_smoothing

Lines:

av

Params:

period (1)

alpha (None)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

av:

FibonacciPivotPoint

Defines a level of significance by taking into account the average of price
bar components of the past period of a larger timeframe. For example when
operating with days, the values are taking from the already “past” month
fixed prices.

Fibonacci levels (configurable) are used to define the support/resistance levels

Example of using this indicator:

data = btfeeds.ADataFeed(dataname=x, timeframe=bt.TimeFrame.Days)
  cerebro.adddata(data)
  cerebro.resampledata(data, timeframe=bt.TimeFrame.Months)

In the 
__init__
 method of the strategy:

pivotindicator = btind.FibonacciPivotPoiont(self.data1)  # the resampled data

The indicator will try to automatically plo to the non-resampled data. To
disable this behavior use the following during construction:

_autoplot=False

Note:

The example shows 
days
 and 
months
, but any combination of timeframes
  can be used. See the literature for recommended combinations

Formula:

pivot = (h + l + c) / 3  # variants duplicate close or add open

support1 = p - level1 * (high - low)  # level1 0.382

support2 = p - level2 * (high - low)  # level2 0.618

support3 = p - level3 * (high - low)  # level3 1.000

resistance1 = p + level1 * (high - low)  # level1 0.382

resistance2 = p + level2 * (high - low)  # level2 0.618

resistance3 = p + level3 * (high - low)  # level3 1.000

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:pivot_points

Lines:

p

s1

s2

s3

r1

r2

r3

Params:

open (False)

close (False)

_autoplot (True)

level1 (0.382)

level2 (0.618)

level3 (1.0)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

p:

s1:

s2:

s3:

r1:

r2:

r3:

FindFirstIndex

Returns the index of the last data that satisfies equality with the
condition generated by the parameter _evalfunc

Note:

```
Returned indexes look backwards. 0 is the current index and 1 is
the previous bar.

```

Formula:

index = first for which data[index] == _evalfunc(data)

Lines:

index

Params:

period (1)

_evalfunc (None)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

index:

FindFirstIndexHighest

Returns the index of the first data that is the highest in the period

Note:

```
Returned indexes look backwards. 0 is the current index and 1 is
the previous bar.

```

Formula:

index = index of first data which is the highest

Lines:

index

Params:

period (1)

_evalfunc (
)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

index:

FindFirstIndexLowest

Returns the index of the first data that is the lowest in the period

Note:

```
Returned indexes look backwards. 0 is the current index and 1 is
the previous bar.

```

Formula:

index = index of first data which is the lowest

Lines:

index

Params:

period (1)

_evalfunc (
)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

index:

FindLastIndex

Returns the index of the last data that satisfies equality with the
condition generated by the parameter _evalfunc

Note:

```
Returned indexes look backwards. 0 is the current index and 1 is
the previous bar.

```

Formula:

index = last for which data[index] == _evalfunc(data)

Lines:

index

Params:

period (1)

_evalfunc (None)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

index:

FindLastIndexHighest

Returns the index of the last data that is the highest in the period

Note:

```
Returned indexes look backwards. 0 is the current index and 1 is
the previous bar.

```

Formula:

index = index of last data which is the highest

Lines:

index

Params:

period (1)

_evalfunc (
)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

index:

FindLastIndexLowest

Returns the index of the last data that is the lowest in the period

Note:

```
Returned indexes look backwards. 0 is the current index and 1 is
the previous bar.

```

Formula:

index = index of last data which is the lowest

Lines:

index

Params:

period (1)

_evalfunc (
)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

index:

Fractal

References:

```
[Ref 1] [http://www.investopedia.com/articles/trading/06/fractals.asp](http://www.investopedia.com/articles/trading/06/fractals.asp)

```

Lines:

fractal_bearish

fractal_bullish

Params:

period (5)

bardist (0.015)

shift_to_potential_fractal (2)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

fractal_bearish:

marker (^)

markersize (4.0)

color (lightblue)

fillstyle (full)

ls ()

fractal_bullish:

marker (v)

markersize (4.0)

color (lightblue)

fillstyle (full)

ls ()

HeikinAshi

Heikin Ashi candlesticks in the forms of lines

Formula:

```
ha_open = (ha_open(-1) + ha_close(-1)) / 2
ha_high = max(hi, ha_open, ha_close)
ha_low = min(lo, ha_open, ha_close)
ha_close = (open + high + low + close) / 4

```

See also:

```
[https://en.wikipedia.org/wiki/Candlestick_chart#Heikin_Ashi_candlesticks](https://en.wikipedia.org/wiki/Candlestick_chart#Heikin_Ashi_candlesticks)
[http://stockcharts.com/school/doku.php?id=chart_school:chart_analysis:heikin_ashi](http://stockcharts.com/school/doku.php?id=chart_school:chart_analysis:heikin_ashi)

```

Lines:

ha_open

ha_high

ha_low

ha_close

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

ha_open:

ha_high:

ha_low:

ha_close:

Highest

Alias:

MaxN

Calculates the highest value for the data in a given period

Uses the built-in 
max
 for the calculation

Formula:

highest = max(data, period)

Lines:

highest

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

highest:

HullMovingAverage

Alias:

HMA, HullMA

By Alan Hull

The Hull Moving Average solves the age old dilemma of making a moving
average more responsive to current price activity whilst maintaining curve
smoothness. In fact the HMA almost eliminates lag altogether and manages to
improve smoothing at the same time.

Formula:

hma = wma(2 * wma(data, period // 2) - wma(data, period), sqrt(period))

See also:

http://alanhull.com/hull-moving-average

Note:

Please note that the final minimum period is not the period passed with
    the parameter 
period
. A final moving average on moving average is
    done in which the period is the 
square root
 of the original.

In the default case of 
30
 the final minimum period before the
moving average produces a non-NAN value is 
34

Lines:

hma

Params:

period (30)

_movav (WMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

hma:

HullMovingAverageEnvelope

Alias:

HMAEnvelope, HullMAEnvelope

HullMovingAverage and envelope bands separated “perc” from it

Formula:

hma (from HullMovingAverage)

top = hma * (1 + perc)

bot = hma * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

hma

top

bot

Params:

period (30)

_movav (WMA)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

hma:

top:

_samecolor (True)

bot:

_samecolor (True)

HullMovingAverageOscillator

Alias:

HullMovingAverageOsc, HMAOscillator, HMAOsc, HullMAOscillator, HullMAOsc

Oscillation of a HullMovingAverage around its data

Lines:

hma

Params:

period (30)

_movav (WMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

hma:

_0:

_name (osc)

HurstExponent

Alias:

```
- Hurst

References:

- [https://www.quantopian.com/posts/hurst-exponent](https://www.quantopian.com/posts/hurst-exponent)

- [https://www.quantopian.com/posts/some-code-from-ernie-chans-new-book-implemented-in-python](https://www.quantopian.com/posts/some-code-from-ernie-chans-new-book-implemented-in-python)

```

Interpretation of the results

```
1. Geometric random walk (H=0.5)

1. Mean-reverting series (H<0.5)

1. Trending Series (H>0.5)

```

Important notes:

The default period is 
40
, but experimentation by users has shown
      that it would be advisable to have at least 2000 samples (i.e.: a
      period of at least 2000) to have stable values.

The lag_start and lag_end values will default to be 
2
 and

self.p.period / 2
 unless the parameters are specified.

Experimentation by users has also shown that values of around 
10

  and 
500
 produce good results

The original values (40, 2, self.p.period / 2) are kept for backwards
  compatibility

Lines:

hurst

Params:

period (40)

lag_start (None)

lag_end (None)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

hurst:

Ichimoku

Developed and published in his book in 1969 by journalist Goichi Hosoda

Formula:

tenkan_sen = (Highest(High, tenkan) + Lowest(Low, tenkan)) / 2.0

kijun_sen = (Highest(High, kijun) + Lowest(Low, kijun)) / 2.0

The next 2 are pushed 26 bars into the future

senkou_span_a = (tenkan_sen + kijun_sen) / 2.0

senkou_span_b = ((Highest(High, senkou) + Lowest(Low, senkou)) / 2.0

This is pushed 26 bars into the past

chikou = close

The cloud (Kumo) is formed by the area between the senkou_spans

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ichimoku_cloud

Lines:

tenkan_sen

kijun_sen

senkou_span_a

senkou_span_b

chikou_span

Params:

tenkan (9)

kijun (26)

senkou (52)

senkou_lead (26)

chikou (26)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

senkou_span_a:

_fill_gt ((‘senkou_span_b’, ‘g’))

_fill_lt ((‘senkou_span_b’, ‘r’))

tenkan_sen:

kijun_sen:

senkou_span_b:

chikou_span:

KnowSureThing

Alias:

KST

It is a “summed” momentum indicator. Developed by Martin Pring and
published in 1992 in Stocks & Commodities.

Formula:

rcma1 = MovAv(roc100(rp1), period)

rcma2 = MovAv(roc100(rp2), period)

rcma3 = MovAv(roc100(rp3), period)

rcma4 = MovAv(roc100(rp4), period)

kst = 1.0 * rcma1 + 2.0 * rcma2 + 3.0 * rcma3 + 4.0 * rcma4

signal = MovAv(kst, speriod)

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:know_sure_thing_kst

Params

rma1
, 
rma2
, 
rma3
, 
rma4
: for the MovingAverages on ROCs

rp1
, 
rp2
, 
rp3
, 
rp4
: for the ROCs

rsig
: for the MovingAverage for the signal line

rfactors
: list of factors to apply to the different MovAv(ROCs)

_movav
 and 
_movavs
, allows to change the Moving Average type
    applied for the calculation of kst and signal

Lines:

kst

signal

Params:

rp1 (10)

rp2 (15)

rp3 (20)

rp4 (30)

rma1 (10)

rma2 (10)

rma3 (10)

rma4 (10)

rsignal (9)

rfactors ([1.0, 2.0, 3.0, 4.0])

_rmovav (SMA)

_smovav (SMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

kst:

signal:

LaguerreFilter

Alias:

LAGF

Defined by John F. Ehlers in Cybernetic Analysis for Stock and Futures,
2004, published by Wiley. ISBN: 978-0-471-46307-8

gamma
 is meant to have values between 
0.2
 and 
0.8
, with the
best balance found theoretically at the default of 
0.5

Lines:

lfilter

Params:

period (1)

gamma (0.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

lfilter:

LaguerreRSI

Alias:

LRSI

Defined by John F. Ehlers in Cybernetic Analysis for Stock and Futures,
2004, published by Wiley. ISBN: 978-0-471-46307-8

The Laguerre RSI tries to implements a better RSI by providing a sort of

Time Warp without Time Travel
 using a Laguerre filter. This provides for
faster reactions to price changes

gamma
 is meant to have values between 
0.2
 and 
0.8
, with the
best balance found theoretically at the default of 
0.5

Lines:

lrsi

Params:

period (6)

gamma (0.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.15)

plotyhlines ([])

plotyticks ([0.0, 0.2, 0.5, 0.8, 1.0])

plothlines ([])

plotforce (False)

PlotLines:

lrsi:

LinePlotterIndicator

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

Lowest

Alias:

MinN

Calculates the lowest value for the data in a given period

Uses the built-in 
min
 for the calculation

Formula:

lowest = min(data, period)

Lines:

lowest

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

lowest:

MACD

Moving Average Convergence Divergence. Defined by Gerald Appel in the 70s.

It measures the distance of a short and a long term moving average to
try to identify the trend.

A second lagging moving average over the convergence-divergence should
provide a “signal” upon being crossed by the macd

Formula:

macd = ema(data, me1_period) - ema(data, me2_period)

signal = ema(macd, signal_period)

See:

http://en.wikipedia.org/wiki/MACD

Lines:

macd

signal

Params:

period_me1 (12)

period_me2 (26)

period_signal (9)

movav (ExponentialMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

signal:

ls (–)

macd:

MACDHisto

Alias:

MACDHistogram

Subclass of MACD which adds a “histogram” of the difference between the
macd and signal lines

Formula:

histo = macd - signal

See:

http://en.wikipedia.org/wiki/MACD

Lines:

macd

signal

histo

Params:

period_me1 (12)

period_me2 (26)

period_signal (9)

movav (ExponentialMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

signal:

ls (–)

macd:

histo:

_method (bar)

alpha (0.5)

width (1.0)

MeanDeviation

Alias:

MeanDev

MeanDeviation (alias MeanDev)

Calculates the Mean Deviation of the passed data for a given period

Note:

If 2 datas are provided as parameters, the 2
nd
 is considered to be the
      mean of the first

Formula:

mean = MovingAverage(data, period) (or provided mean)

absdeviation = abs(data - mean)

meandev = MovingAverage(absdeviation, period)

See:

https://en.wikipedia.org/wiki/Average_absolute_deviation

Lines:

meandev

Params:

period (20)

movav (MovingAverageSimple)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

meandev:

MinusDirectionalIndicator

Alias:

MinusDI

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
.

Intended to measure trend strength

This indicator shows -DI:

Use PlusDirectionalIndicator (PlusDI) to get +DI

Use Directional Indicator (DI) to get +DI, -DI

Use AverageDirectionalIndex (ADX) to get ADX

Use AverageDirectionalIndexRating (ADXR) to get ADX, ADXR

Use DirectionalMovementIndex (DMI) to get ADX, +DI, -DI

Use DirectionalMovement (DM) to get ADX, ADXR, +DI, -DI

Formula:

upmove = high - high(-1)

downmove = low(-1) - low

-dm = downmove if downmove > upmove and downmove > 0 else 0

-di = 100 * MovingAverage(-dm, period) / atr(period)

The moving average used is the one originally defined by Wilder,
the SmoothedMovingAverage

See:

https://en.wikipedia.org/wiki/Average_directional_movement_index

Lines:

minusDI

Params:

period (14)

movav (SmoothedMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname (-DirectionalIndicator)

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

plusDI:

_name (+DI)

minusDI:

Momentum

Measures the change in price by calculating the difference between the
current price and the price from a given period ago

Formula:

momentum = data - data_period

See:

http://en.wikipedia.org/wiki/Momentum_(technical_analysis

Lines:

momentum

Params:

period (12)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

momentum:

MomentumOscillator

Alias:

MomentumOsc

Measures the ratio of change in prices over a period

Formula:

mosc = 100 * (data / data_period)

See:

http://ta.mql4.com/indicators/oscillators/momentum

Lines:

momosc

Params:

period (12)

band (100.0)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

momosc:

MovingAverageBase

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

MovingAverageSimple

Alias:

SMA, SimpleMovingAverage

Non-weighted average of the last n periods

Formula:

movav = Sum(data, period) / period

See also:

http://en.wikipedia.org/wiki/Moving_average#Simple_moving_average

Lines:

sma

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

sma:

MovingAverageSimpleEnvelope

Alias:

SMAEnvelope, SimpleMovingAverageEnvelope

MovingAverageSimple and envelope bands separated “perc” from it

Formula:

sma (from MovingAverageSimple)

top = sma * (1 + perc)

bot = sma * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

sma

top

bot

Params:

period (30)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

sma:

top:

_samecolor (True)

bot:

_samecolor (True)

MovingAverageSimpleOscillator

Alias:

MovingAverageSimpleOsc, SMAOscillator, SMAOsc, SimpleMovingAverageOscillator, SimpleMovingAverageOsc

Oscillation of a MovingAverageSimple around its data

Lines:

sma

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

sma:

_0:

_name (osc)

NonZeroDifference

Alias:

NZD

Keeps track of the difference between two data inputs skipping, memorizing
the last non zero value if the current difference is zero

Formula:

diff = data - data1

nzd = diff if diff else diff(-1)

Lines:

nzd

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

nzd:

OLS_BetaN

Calculates a regression of data1 on data0 using 
pandas.ols

Uses 
pandas

Lines:

beta

Params:

period (10)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

beta:

OLS_Slope_InterceptN

Calculates a linear regression using 
statsmodel.OLS
 (Ordinary least
squares) of data1 on data0

Uses 
pandas
 and 
statsmodels

Use 
prepend_constant
 to influence the paramter 
prepend
 of
sm.add_constant

Lines:

slope

intercept

Params:

period (10)

prepend_constant (True)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

slope:

intercept:

OLS_TransformationN

Calculates the 
zscore
 for data0 and data1. Although it doesn’t directly
uses any external package it relies on 
OLS_SlopeInterceptN
 which uses

pandas
 and 
statsmodels

Lines:

spread

spread_mean

spread_std

zscore

Params:

period (10)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

spread:

spread_mean:

spread_std:

zscore:

OperationN

Calculates “func” for a given period

Serves as a base for classes that work with a period and can express the
logic in a callable object

Note:

```
Base classes must provide a “func” attribute which is a callable

```

Formula:

line = func(data, period)

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

Oscillator

Oscillation of a given data around another data

Datas:

```
This indicator can accept 1 or 2 datas for the calculation.

```

If 1 data is provided, it must be a complex “Lines” object (indicator)
      which also has “datas”. Example: A moving average

The calculated oscillation will be that of the Moving Average (in the
  example) around the data that was used for the average calculation

If 2 datas are provided the calculated oscillation will be that of the
      2
nd
 data around the 1
st
 data

Formula:

1 data -> osc = data.data - data

2 datas -> osc = data0 - data1

Lines:

osc

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

_0:

_name (osc)

osc:

OscillatorMixIn

MixIn class to create a subclass with another indicator. The main line of
that indicator will be substracted from the other base class main line
creating an oscillator

The usage is:

Class XXXOscillator(XXX, OscillatorMixIn)

Formula:

XXX calculates lines[0]

osc = self.data - XXX.lines[0]

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

_0:

_name (osc)

ParabolicSAR

Alias:

PSAR

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
 for the RSI

SAR stands for 
Stop and Reverse
 and the indicator was meant as a signal
for entry (and reverse)

How to select the 1
st
 signal is left unspecified in the book and the
increase/decrease of bars

See:

https://en.wikipedia.org/wiki/Parabolic_SAR

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:parabolic_sar

Lines:

psar

Params:

period (2)

af (0.02)

afmax (0.2)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

psar:

marker (.)

markersize (4.0)

color (black)

fillstyle (full)

ls ()

PercentChange

Alias:

PctChange

Measures the perccentage change of the current value with respect to that
of period bars ago

Lines:

pctchange

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

pctchange:

_name (%change)

PercentRank

Alias:

PctRank

Measures the percent rank of the current value with respect to that of
period bars ago

Lines:

pctrank

Params:

period (50)

func (
 at 0x000001F1E4478B70>)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

pctrank:

PercentagePriceOscillator

Alias:

PPO, PercPriceOsc

Shows the difference between a short and long exponential moving
averages expressed in percentage. The MACD does the same but expressed in
absolute points.

Expressing the difference in percentage allows to compare the indicator at
different points in time when the underlying value has significatnly
different values.

Formula:

po = 100 * (ema(short) - ema(long)) / ema(long)

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:price_oscillators_ppo

Lines:

ppo

signal

histo

Params:

period1 (12)

period2 (26)

_movav (ExponentialMovingAverage)

period_signal (9)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

histo:

_method (bar)

alpha (0.5)

width (1.0)

ppo:

signal:

PercentagePriceOscillatorShort

Alias:

PPOShort, PercPriceOscShort

Shows the difference between a short and long exponential moving
averages expressed in percentage. The MACD does the same but expressed in
absolute points.

Expressing the difference in percentage allows to compare the indicator at
different points in time when the underlying value has significatnly
different values.

Most on-line literature shows the percentage calculation having the long
exponential moving average as the denominator. Some sources like MetaStock
use the short one.

Formula:

po = 100 * (ema(short) - ema(long)) / ema(short)

See:

http://www.metastock.com/Customer/Resources/TAAZ/?c=3&p=94

Lines:

ppo

signal

histo

Params:

period1 (12)

period2 (26)

_movav (ExponentialMovingAverage)

period_signal (9)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

histo:

_method (bar)

alpha (0.5)

width (1.0)

ppo:

signal:

PeriodN

Base class for indicators which take a period (
init
 has to be called
either via super or explicitly)

This class has no defined lines

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PivotPoint

Defines a level of significance by taking into account the average of price
bar components of the past period of a larger timeframe. For example when
operating with days, the values are taking from the already “past” month
fixed prices.

Example of using this indicator:

data = btfeeds.ADataFeed(dataname=x, timeframe=bt.TimeFrame.Days)
  cerebro.adddata(data)
  cerebro.resampledata(data, timeframe=bt.TimeFrame.Months)

In the 
__init__
 method of the strategy:

pivotindicator = btind.PivotPoiont(self.data1)  # the resampled data

The indicator will try to automatically plo to the non-resampled data. To
disable this behavior use the following during construction:

_autoplot=False

Note:

The example shows 
days
 and 
months
, but any combination of timeframes
  can be used. See the literature for recommended combinations

Formula:

pivot = (h + l + c) / 3  # variants duplicate close or add open

support1 = 2.0 * pivot - high

support2 = pivot - (high - low)

resistance1 = 2.0 * pivot - low

resistance2 = pivot + (high - low)

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:pivot_points

https://en.wikipedia.org/wiki/Pivot_point_(technical_analysis

Lines:

p

s1

s2

r1

r2

Params:

open (False)

close (False)

_autoplot (True)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

p:

s1:

s2:

r1:

r2:

PlusDirectionalIndicator

Alias:

PlusDI

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
.

Intended to measure trend strength

This indicator shows +DI:

Use MinusDirectionalIndicator (MinusDI) to get -DI

Use Directional Indicator (DI) to get +DI, -DI

Use AverageDirectionalIndex (ADX) to get ADX

Use AverageDirectionalIndexRating (ADXR) to get ADX, ADXR

Use DirectionalMovementIndex (DMI) to get ADX, +DI, -DI

Use DirectionalMovement (DM) to get ADX, ADXR, +DI, -DI

Formula:

upmove = high - high(-1)

downmove = low(-1) - low

+dm = upmove if upmove > downmove and upmove > 0 else 0

+di = 100 * MovingAverage(+dm, period) / atr(period)

The moving average used is the one originally defined by Wilder,
the SmoothedMovingAverage

See:

https://en.wikipedia.org/wiki/Average_directional_movement_index

Lines:

plusDI

Params:

period (14)

movav (SmoothedMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname (+DirectionalIndicator)

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

plusDI:

minusDI:

_name (-DI)

PrettyGoodOscillator

Alias:

PGO, PrettyGoodOsc

The “Pretty Good Oscillator” (PGO) by Mark Johnson measures the distance of
the current close from its simple moving average of period
Average), expressed in terms of an average true range (see Average True
Range) over a similar period.

So for instance a PGO value of +2.5 would mean the current close is 2.5
average days’ range above the SMA.

Johnson’s approach was to use it as a breakout system for longer term
trades. If the PGO rises above 3.0 then go long, or below -3.0 then go
short, and in both cases exit on returning to zero (which is a close back
at the SMA).

Formula:

pgo = (data.close - sma(data, period)) / atr(data, period)

See also:

http://user42.tuxfamily.org/chart/manual/Pretty-Good-Oscillator.html

Lines:

pgo

Params:

period (14)

_movav (MovingAverageSimple)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

pgo:

PriceOscillator

Alias:

PriceOsc, AbsolutePriceOscillator, APO, AbsPriceOsc

Shows the difference between a short and long exponential moving
averages expressed in points.

Formula:

po = ema(short) - ema(long)

See:

http://www.metastock.com/Customer/Resources/TAAZ/?c=3&p=94

Lines:

po

Params:

period1 (12)

period2 (26)

_movav (ExponentialMovingAverage)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

po:

RSI_EMA

Uses an ExponentialMovingAverage as described in Wikipedia

See:

http://en.wikipedia.org/wiki/Relative_strength_index

Lines:

rsi

Params:

period (14)

movav (ExponentialMovingAverage)

upperband (70.0)

lowerband (30.0)

safediv (False)

safehigh (100.0)

safelow (50.0)

lookback (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

rsi:

RSI_SMA

Alias:

RSI_Cutler

Uses a SimpleMovingAverage as described in Wikipedia and other soures

See:

http://en.wikipedia.org/wiki/Relative_strength_index

Lines:

rsi

Params:

period (14)

movav (MovingAverageSimple)

upperband (70.0)

lowerband (30.0)

safediv (False)

safehigh (100.0)

safelow (50.0)

lookback (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

rsi:

RSI_Safe

Subclass of RSI which changes parameers 
safediv
 to 
True
 as the
default value

See:

http://en.wikipedia.org/wiki/Relative_strength_index

Lines:

rsi

Params:

period (14)

movav (SmoothedMovingAverage)

upperband (70.0)

lowerband (30.0)

safediv (True)

safehigh (100.0)

safelow (50.0)

lookback (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

rsi:

RateOfChange

Alias:

ROC

Measures the ratio of change in prices over a period

Formula:

roc = (data - data_period) / data_period

See:

http://en.wikipedia.org/wiki/Momentum_(technical_analysis

Lines:

roc

Params:

period (12)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

roc:

RateOfChange100

Alias:

ROC100

Measures the ratio of change in prices over a period with base 100

This is for example how ROC is defined in stockcharts

Formula:

roc = 100 * (data - data_period) / data_period

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:rate_of_change_roc_and_momentum

Lines:

roc100

Params:

period (12)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

roc100:

ReduceN

Calculates the Reduced value of the 
period
 data points applying

function

Uses the built-in 
reduce
 for the calculation plus the 
func
 that
subclassess define

Formula:

reduced = reduce(function(data, period)), initializer=initializer)

Notes:

In order to mimic the python 
reduce
, this indicator takes a

function
 non-named argument as the 1
st
 argument, unlike other
    Indicators which take only named arguments

Lines:

reduced

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

reduced:

RelativeMomentumIndex

Alias:

RMI

Description:
The Relative Momentum Index was developed by Roger Altman and was
introduced in his article in the February, 1993 issue of Technical Analysis
of Stocks & Commodities magazine.

While your typical RSI counts up and down days from close to close, the
Relative Momentum Index counts up and down days from the close relative to
a close x number of days ago. The result is an RSI that is a bit smoother.

Usage:
Use in the same way you would any other RSI . There are overbought and
oversold zones, and can also be used for divergence and trend analysis.

See:

https://www.marketvolume.com/technicalanalysis/relativemomentumindex.asp

https://www.tradingview.com/script/UCm7fIvk-FREE-INDICATOR-Relative-Momentum-Index-RMI/

https://www.prorealcode.com/prorealtime-indicators/relative-momentum-index-rmi/

Lines:

rsi

Params:

period (20)

movav (SmoothedMovingAverage)

upperband (70.0)

lowerband (30.0)

safediv (False)

safehigh (100.0)

safelow (50.0)

lookback (5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

rsi:

_name (rmi)

RelativeStrengthIndex

Alias:

RSI, RSI_SMMA, RSI_Wilder

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
.

It measures momentum by calculating the ration of higher closes and
lower closes after having been smoothed by an average, normalizing
the result between 0 and 100

Formula:

up = upday(data)

down = downday(data)

maup = movingaverage(up, period)

madown = movingaverage(down, period)

rs = maup / madown

rsi = 100 - 100 / (1 + rs)

The moving average used is the one originally defined by Wilder,
the SmoothedMovingAverage

See:

http://en.wikipedia.org/wiki/Relative_strength_index

Notes:

safediv
 (default: False) If this parameter is True the division
      rs = maup / madown will be checked for the special cases in which a

0 / 0
 or 
x / 0
 division will happen

safehigh
 (default: 100.0) will be used as RSI value for the

x / 0
 case

safelow
  (default: 50.0) will be used as RSI value for the

0 / 0
 case

Lines:

rsi

Params:

period (14)

movav (SmoothedMovingAverage)

upperband (70.0)

lowerband (30.0)

safediv (False)

safehigh (100.0)

safelow (50.0)

lookback (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

rsi:

Signal

Lines:

signal

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

signal:

SmoothedMovingAverage

Alias:

SMMA, WilderMA, MovingAverageSmoothed, MovingAverageWilder, ModifiedMovingAverage

Smoothing Moving Average used by Wilder in his 1978 book New Concepts in
Technical Trading

Defined in his book originally as:

new_value = (old_value * (period - 1) + new_data) / period

Can be expressed as a SmoothingMovingAverage with the following factors:

self.smfactor -> 1.0 / period

self.smfactor1 -> 1.0 - self.smfactor

Formula:

movav = prev * (1.0 - smoothfactor) + newdata * smoothfactor

See also:

http://en.wikipedia.org/wiki/Moving_average#Modified_moving_average

Lines:

smma

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

smma:

SmoothedMovingAverageEnvelope

Alias:

SMMAEnvelope, WilderMAEnvelope, MovingAverageSmoothedEnvelope, MovingAverageWilderEnvelope, ModifiedMovingAverageEnvelope

SmoothedMovingAverage and envelope bands separated “perc” from it

Formula:

smma (from SmoothedMovingAverage)

top = smma * (1 + perc)

bot = smma * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

smma

top

bot

Params:

period (30)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

smma:

top:

_samecolor (True)

bot:

_samecolor (True)

SmoothedMovingAverageOscillator

Alias:

SmoothedMovingAverageOsc, SMMAOscillator, SMMAOsc, WilderMAOscillator, WilderMAOsc, MovingAverageSmoothedOscillator, MovingAverageSmoothedOsc, MovingAverageWilderOscillator, MovingAverageWilderOsc, ModifiedMovingAverageOscillator, ModifiedMovingAverageOsc

Oscillation of a SmoothedMovingAverage around its data

Lines:

smma

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

smma:

_0:

_name (osc)

StandardDeviation

Alias:

StdDev

Calculates the standard deviation of the passed data for a given period

Note:

If 2 datas are provided as parameters, the 2
nd
 is considered to be the
      mean of the first

safepow
 (default: False) If this parameter is True, the standard
      deviation will be calculated as pow(abs(meansq - sqmean), 0.5) to safe
      guard for possible negative results of 
meansq - sqmean
 caused by
      the floating point representation.

Formula:

meansquared = SimpleMovingAverage(pow(data, 2), period)

squaredmean = pow(SimpleMovingAverage(data, period), 2)

stddev = pow(meansquared - squaredmean, 0.5)  # square root

See:

http://en.wikipedia.org/wiki/Standard_deviation

Lines:

stddev

Params:

period (20)

movav (MovingAverageSimple)

safepow (True)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

stddev:

Stochastic

Alias:

StochasticSlow

The regular (or slow version) adds an additional moving average layer and
thus:

The percD line of the StochasticFast becomes the percK line

percD becomes a  moving average of period_dslow of the original percD

Formula:

k = k

d = d

d = MovingAverage(d, period_dslow)

See:

http://en.wikipedia.org/wiki/Stochastic_oscillator

Lines:

percK

percD

Params:

period (14)

period_dfast (3)

movav (MovingAverageSimple)

upperband (80.0)

lowerband (20.0)

safediv (False)

safezero (0.0)

period_dslow (3)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

percD:

_name (%D)

ls (–)

percK:

_name (%K)

StochasticFast

By Dr. George Lane in the 50s. It compares a closing price to the price
range and tries to show convergence if the closing prices are close to the
extremes

It will go up if closing prices are close to the highs

It will roughly go down if closing prices are close to the lows

It shows divergence if the extremes keep on growing but closing prices
do not in the same manner (distance to the extremes grow)

Formula:

hh = highest(data.high, period)

ll = lowest(data.low, period)

knum = data.close - ll

kden = hh - ll

k = 100 * (knum / kden)

d = MovingAverage(k, period_dfast)

See:

http://en.wikipedia.org/wiki/Stochastic_oscillator

Lines:

percK

percD

Params:

period (14)

period_dfast (3)

movav (MovingAverageSimple)

upperband (80.0)

lowerband (20.0)

safediv (False)

safezero (0.0)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

percD:

_name (%D)

ls (–)

percK:

_name (%K)

StochasticFull

This version displays the 3 possible lines:

percK

percD

percSlow

Formula:

k = d

d = MovingAverage(k, period_dslow)

dslow =

See:

http://en.wikipedia.org/wiki/Stochastic_oscillator

Lines:

percK

percD

percDSlow

Params:

period (14)

period_dfast (3)

movav (MovingAverageSimple)

upperband (80.0)

lowerband (20.0)

safediv (False)

safezero (0.0)

period_dslow (3)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

percD:

_name (%D)

ls (–)

percK:

_name (%K)

percDSlow:

_name (%DSlow)

SumN

Calculates the Sum of the data values over a given period

Uses 
math.fsum
 for the calculation rather than the built-in 
sum
 to
avoid precision errors

Formula:

sumn = sum(data, period)

Lines:

sumn

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

sumn:

TripleExponentialMovingAverage

Alias:

TEMA, MovingAverageTripleExponential

TEMA was first time introduced in 1994, in the article “Smoothing Data with
Faster Moving Averages” by Patrick G. Mulloy in “Technical Analysis of
Stocks & Commodities” magazine.

It attempts to reduce the inherent lag associated to Moving Averages

Formula:

ema1 = ema(data, period)

ema2 = ema(ema1, period)

ema3 = ema(ema2, period)

tema = 3 * ema1 - 3 * ema2 + ema3

See:

```
(None)

```

Lines:

tema

Params:

period (30)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

tema:

TripleExponentialMovingAverageEnvelope

Alias:

TEMAEnvelope, MovingAverageTripleExponentialEnvelope

TripleExponentialMovingAverage and envelope bands separated “perc” from it

Formula:

tema (from TripleExponentialMovingAverage)

top = tema * (1 + perc)

bot = tema * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

tema

top

bot

Params:

period (30)

_movav (EMA)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

tema:

top:

_samecolor (True)

bot:

_samecolor (True)

TripleExponentialMovingAverageOscillator

Alias:

TripleExponentialMovingAverageOsc, TEMAOscillator, TEMAOsc, MovingAverageTripleExponentialOscillator, MovingAverageTripleExponentialOsc

Oscillation of a TripleExponentialMovingAverage around its data

Lines:

tema

Params:

period (30)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

tema:

_0:

_name (osc)

Trix

Alias:

TRIX

Defined by Jack Hutson in the 80s and shows the Rate of Change (%) or slope
of a triple exponentially smoothed moving average

Formula:

ema1 = EMA(data, period)

ema2 = EMA(ema1, period)

ema3 = EMA(ema2, period)

trix = 100 * (ema3 - ema3(-1)) / ema3(-1)

The final formula can be simplified to: 100 * (ema3 / ema3(-1) - 1)

The moving average used is the one originally defined by Wilder,
the SmoothedMovingAverage

See:

https://en.wikipedia.org/wiki/Trix_(technical_analysis

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:trix

Lines:

trix

Params:

period (15)

_rocperiod (1)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

trix:

TrixSignal

Extension of Trix with a signal line (ala MACD)

Formula:

trix = Trix(data, period)

signal = EMA(trix, sigperiod)

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:trix

Lines:

trix

signal

Params:

period (15)

_rocperiod (1)

_movav (EMA)

sigperiod (9)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([0.0])

plotforce (False)

PlotLines:

trix:

signal:

TrueHigh

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
 for the ATR

Records the “true high” which is the maximum of today’s high and
yesterday’s close

Formula:

truehigh = max(high, close_prev)

See:

http://en.wikipedia.org/wiki/Average_true_range

Lines:

truehigh

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

truehigh:

TrueLow

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
 for the ATR

Records the “true low” which is the minimum of today’s low and
yesterday’s close

Formula:

truelow = min(low, close_prev)

See:

http://en.wikipedia.org/wiki/Average_true_range

Lines:

truelow

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

truelow:

TrueRange

Alias:

TR

Defined by J. Welles Wilder, Jr. in 1978 in his book New Concepts in
Technical Trading Systems.

Formula:

max(high - low, abs(high - prev_close), abs(prev_close - low)

which can be simplified to

max(high, prev_close) - min(low, prev_close)

See:

http://en.wikipedia.org/wiki/Average_true_range

The idea is to take the previous close into account to calculate the range
if it yields a larger range than the daily range (High - Low)

Lines:

tr

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

tr:

TrueStrengthIndicator

Alias:

TSI

The True Strength Indicators was first introduced in Stocks & Commodities
Magazine by its author William Blau. It measures momentum with a double
exponential (default) of the prices.

It shows divergence if the extremes keep on growign but closing prices
do not in the same manner (distance to the extremes grow)

Formula:

price_change = close - close(pchange periods ago)

sm1_simple = EMA(price_close_change, period1)

sm1_double = EMA(sm1_simple, period2)

sm2_simple = EMA(abs(price_close_change), period1)

sm2_double = EMA(sm2_simple, period2)

tsi = 100.0 * sm1_double / sm2_double

See:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:true_strength_index

Params

period1
: the period for the 1
st
 smoothing

period2
: the period for the 2
nd
 smoothing

pchange
: the lookback period for the price change

_movav
: the moving average to apply for the smoothing

Lines:

tsi

Params:

period1 (25)

period2 (13)

pchange (1)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

tsi:

UltimateOscillator

Formula:

```
# Buying Pressure = Close - TrueLow
BP = Close - Minimum(Low or Prior Close)

# TrueRange = TrueHigh - TrueLow
TR = Maximum(High or Prior Close)  -  Minimum(Low or Prior Close)

Average7 = (7-period BP Sum) / (7-period TR Sum)
Average14 = (14-period BP Sum) / (14-period TR Sum)
Average28 = (28-period BP Sum) / (28-period TR Sum)

UO = 100 x [(4 x Average7)+(2 x Average14)+Average28]/(4+2+1)

```

See:

https://en.wikipedia.org/wiki/Ultimate_oscillator

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ultimate_oscillator

Lines:

uo

Params:

p1 (7)

p2 (14)

p3 (28)

upperband (70.0)

lowerband (30.0)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

uo:

UpDay

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
 for the RSI

Records days which have been “up”, i.e.: the close price has been
higher than the day before.

Formula:

upday = max(close - close_prev, 0)

See:

http://en.wikipedia.org/wiki/Relative_strength_index

Lines:

upday

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

upday:

UpDayBool

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
 for the RSI

Records days which have been “up”, i.e.: the close price has been
higher than the day before.

Note:

This version returns a bool rather than the difference

Formula:

upday = close > close_prev

See:

http://en.wikipedia.org/wiki/Relative_strength_index

Lines:

upday

Params:

period (1)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

upday:

UpMove

Defined by J. Welles Wilder, Jr. in 1978 in his book 
“New Concepts in
Technical Trading Systems”
 as part of the Directional Move System to
calculate Directional Indicators.

Positive if the given data has moved higher than the previous day

Formula:

upmove = data - data(-1)

See:

https://en.wikipedia.org/wiki/Average_directional_movement_index

Lines:

upmove

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

upmove:

Vortex

See:

http://www.vortexindicator.com/VFX_VORTEX.PDF

Lines:

vi_plus

vi_minus

Params:

period (14)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

vi_plus:

_name (+VI)

vi_minus:

_name (-VI)

WeightedAverage

Alias:

AverageWeighted

Calculates the weighted average of the given data over a period

The default weights (if none are provided) are linear to assigne more
weight to the most recent data

The result will be multiplied by a given “coef”

Formula:

av = coef * sum(mul(data, period), weights)

See:

https://en.wikipedia.org/wiki/Weighted_arithmetic_mean

Lines:

av

Params:

period (1)

coef (1.0)

weights (())

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

av:

WeightedMovingAverage

Alias:

WMA, MovingAverageWeighted

A Moving Average which gives an arithmetic weighting to values with the
newest having the more weight

Formula:

weights = range(1, period + 1)

coef = 2 / (period * (period + 1))

movav = coef * Sum(weight[i] * data[period - i] for i in range(period))

See also:

http://en.wikipedia.org/wiki/Moving_average#Weighted_moving_average

Lines:

wma

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

wma:

WeightedMovingAverageEnvelope

Alias:

WMAEnvelope, MovingAverageWeightedEnvelope

WeightedMovingAverage and envelope bands separated “perc” from it

Formula:

wma (from WeightedMovingAverage)

top = wma * (1 + perc)

bot = wma * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

wma

top

bot

Params:

period (30)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

wma:

top:

_samecolor (True)

bot:

_samecolor (True)

WeightedMovingAverageOscillator

Alias:

WeightedMovingAverageOsc, WMAOscillator, WMAOsc, MovingAverageWeightedOscillator, MovingAverageWeightedOsc

Oscillation of a WeightedMovingAverage around its data

Lines:

wma

Params:

period (30)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

wma:

_0:

_name (osc)

WilliamsAD

By Larry Williams. It does cumulatively measure if the price is
accumulating (upwards) or distributing (downwards) by using the concept of
UpDays and DownDays.

Prices can go upwards but do so in a fashion that no longer shows
accumulation because updays and downdays are canceling out each other,
creating a divergence.

See:
- 
http://www.metastock.com/Customer/Resources/TAAZ/?p=125

- 
http://ta.mql4.com/indicators/trends/williams_accumulation_distribution

Lines:

ad

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

ad:

WilliamsR

Developed by Larry Williams to show the relation of closing prices to
the highest-lowest range of a given period.

Known as Williams %R (but % is not allowed in Python identifiers)

Formula:

num = highest_period - close

den = highestg_period - lowest_period

percR = (num / den) * -100.0

See:

http://en.wikipedia.org/wiki/Williams_%25R

Lines:

percR

Params:

period (14)

upperband (-20.0)

lowerband (-80.0)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname (Williams R%)

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

percR:

_name (R%)

ZeroLagExponentialMovingAverage

Alias:

ZLEMA, ZeroLagEma

The zero-lag exponential moving average (ZLEMA) is a variation of the EMA
which adds a momentum term aiming to reduce lag in the average so as to
track current prices more closely.

Formula:

lag = (period - 1) / 2

zlema = ema(2 * data - data(-lag))

See also:

http://user42.tuxfamily.org/chart/manual/Zero_002dLag-Exponential-Moving-Average.html

Lines:

zlema

Params:

period (30)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

zlema:

ZeroLagExponentialMovingAverageEnvelope

Alias:

ZLEMAEnvelope, ZeroLagEmaEnvelope

ZeroLagExponentialMovingAverage and envelope bands separated “perc” from it

Formula:

zlema (from ZeroLagExponentialMovingAverage)

top = zlema * (1 + perc)

bot = zlema * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

zlema

top

bot

Params:

period (30)

_movav (EMA)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

zlema:

top:

_samecolor (True)

bot:

_samecolor (True)

ZeroLagExponentialMovingAverageOscillator

Alias:

ZeroLagExponentialMovingAverageOsc, ZLEMAOscillator, ZLEMAOsc, ZeroLagEmaOscillator, ZeroLagEmaOsc

Oscillation of a ZeroLagExponentialMovingAverage around its data

Lines:

zlema

Params:

period (30)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

zlema:

_0:

_name (osc)

ZeroLagIndicator

Alias:

ZLIndicator, ZLInd, EC, ErrorCorrecting

By John Ehlers and Ric Way

The zero-lag indicator (ZLIndicator) is a variation of the EMA
which modifies the EMA by trying to minimize the error (distance price -
error correction) and thus reduce the lag

Formula:

EMA(data, period)

For each iteration calculate a best-error-correction of the ema (see
      the paper and/or the code) iterating over 
-bestgain
 ->

+bestgain
 for the error correction factor (both incl.)

The default moving average is EMA, but can be changed with the
      parameter 
_movav

NOTE
: the passed moving average must calculate alpha (and 1 -
alpha) and make them available as attributes 
alpha
 and

alpha1
 in the instance

See also:

http://www.mesasoftware.com/papers/ZeroLag.pdf

Lines:

ec

Params:

period (30)

gainlimit (50)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

ec:

ZeroLagIndicatorEnvelope

Alias:

ZLIndicatorEnvelope, ZLIndEnvelope, ECEnvelope, ErrorCorrectingEnvelope

ZeroLagIndicator and envelope bands separated “perc” from it

Formula:

ec (from ZeroLagIndicator)

top = ec * (1 + perc)

bot = ec * (1 - perc)

See also:

http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:moving_average_envelopes

Lines:

ec

top

bot

Params:

period (30)

gainlimit (50)

_movav (EMA)

perc (2.5)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (False)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

ec:

top:

_samecolor (True)

bot:

_samecolor (True)

ZeroLagIndicatorOscillator

Alias:

ZeroLagIndicatorOsc, ZLIndicatorOscillator, ZLIndicatorOsc, ZLIndOscillator, ZLIndOsc, ECOscillator, ECOsc, ErrorCorrectingOscillator, ErrorCorrectingOsc

Oscillation of a ZeroLagIndicator around its data

Lines:

ec

Params:

period (30)

gainlimit (50)

_movav (EMA)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

ec:

_0:

_name (osc)

haDelta

Alias:

haD

Heikin Ashi Delta. Defined by Dan Valcu in his book “Heikin-Ashi: How to
Trade Without Candlestick Patterns “.

This indicator measures difference between Heikin Ashi close and open of
Heikin Ashi candles, the body of the candle.

To get signals add haDelta smoothed by 3 period moving average.

For correct use, the data for the indicator must have been previously
passed by the Heikin Ahsi filter.

Formula:

haDelta = Heikin Ashi close - Heikin Ashi open

smoothed = movav(haDelta, period)

Lines:

haDelta

smoothed

Params:

period (3)

movav (SMA)

autoheikin (True)

PlotInfo:

plot (True)

plotmaster (None)

legendloc (None)

subplot (True)

plotname ()

plotskip (False)

plotabove (False)

plotlinelabels (False)

plotlinevalues (True)

plotvaluetags (True)

plotymargin (0.0)

plotyhlines ([])

plotyticks ([])

plothlines ([])

plotforce (False)

PlotLines:

haDelta:

color (red)

smoothed:

color (grey)

_fill_gt ((0, ‘green’))

_fill_lt ((0, ‘red’))
########################################
docu-inddev.txt - lunghezza: 9670
########################################
Indicator Development

If anything (besides one or more winning Strategies) must ever be developed,
this something is a custom Indicator.

Such development within the platform is, according to the author, easy.

The following is needed:

A class derived from Indicator (either directly or from an already existing
    subclass)

Define the 
lines
 it will hold

An indicator must at least have 1 line. If deriving from an existing one,
the line(s) may have already be defined

Optionally define parameters which can alter the behavior

Optionally provided/customize some of the elements which enable sensible
    plotting of the indicators

Provide a fully defined operation in 
__init__
 with a binding
    (assignment) to the line(s) of the indicator or else provide 
next
 and
    (optionally) 
once
 methods

If an indicator can be fully defined with logic/arithmetic operations during
initialization and the result is assigned to the line: done

Be it not the case, at least a 
next
 has to be provided where the indicator
must assign a value to the line(s) at index 0

Optimization of the calculation for the 
runonce
 mode (batch operation) can
be achieved by providing a 
once
 method.

Important note: Idempotence

Indicators produce an output for each bar they receive. No assumption has to be
made about how many times the same bar will be sent. Operations have to be
idempotent.

The rationale behind this:

The same bar (index-wise) can be sent many times with changing values
    (namely the changing value is the closing price)

This enables, for example, “replaying” a daily session but using intraday data
which could be made of 5 minutes bars.

It could also allow the platform to get values from a live feed.

A dummy (but functional) indicator

So can it be:

```
class DummyInd(bt.Indicator):
    lines = ('dummyline',)

    params = (('value', 5),)

    def __init__(self):
        self.lines.dummyline = bt.Max(0.0, self.params.value)

```

Done! The indicator will output always the same value: either 0.0 or
self.params.value if it happens to be greater than 0.0.

The same indicator but using the next method:

```
class DummyInd(bt.Indicator):
    lines = ('dummyline',)

    params = (('value', 5),)

    def next(self):
        self.lines.dummyline[0] = max(0.0, self.params.value)

```

Done! Same behavior.

Note

Notice how in the 
__init__
 version 
bt.Max
 is used to assign to
the Line object 
self.lines.dummyline
.

bt.Max
 returns an 
lines
 object that is automatically iterated for
each bar passed to the indicator.

Had 
max
 been used instead, the assigment would have been
pointless, because instead of a line, the indicator would have a
member variable with a fixed value.

During 
next
 the work is done directly with floating point values
and the standard 
max
 built-in can be used

Let’s recall that 
self.lines.dummyline
 is the long notation and that it can
be shortened to:

self.l.dummyline

and even to:

self.dummyline

The latter being only possible if the code has not obscured this with a member
attribute.

The 3
rd
 and last version provides an additional 
once
 method to optimize the
calculation:

```
class DummyInd(bt.Indicator):
    lines = ('dummyline',)

    params = (('value', 5),)

    def next(self):
        self.lines.dummyline[0] = max(0.0, self.params.value)

    def once(self, start, end):
       dummy_array = self.lines.dummyline.array

       for i in xrange(start, end):
           dummy_array[i] = max(0.0, self.params.value)

```

A lot more effective but developing the 
once
 method has forced to scratch beyond
the surface. Actually the guts have been looked into.

The 
__init__
 version is in any case the best:

Everything is confined to the initialization

next
 and 
once
 (both optimized, because 
bt.Max
 already has them)
    are provided automatically with no need to play with indices and/or
    formulas

Be it needed for development, the indicator can also override the methods
associated to 
next
 and 
once
:

prenext
 and 
nexstart

preonce
 and 
oncestart

Manual/Automatic Minimum Period

If possible the platform will calculate it, but manual action may be needed.

Here is a potential implementation of a 
Simple Moving Average
:

```
class SimpleMovingAverage1(Indicator):
    lines = ('sma',)
    params = (('period', 20),)

    def next(self):
        datasum = math.fsum(self.data.get(size=self.p.period))
        self.lines.sma[0] = datasum / self.p.period

```

Although it seems sound, the platform doesn’t know what the minimum period is,
even if the parameter is named “period” (the name could be misleading and some
indicators receive several “period”s which have different usages)

In this case 
next
 would be called already for the 1
st
 bar and everthing
would explode because get cannot return the needed 
self.p.period
.

Before solving the situation something has to be taken into account:

The data feeds passed to the indicators may already carry a 
minimum
    period

The sample 
SimpleMovingAverage
 may be done on for example:

A regular data feed

This has a default mininum period of 1 (just wait for the 1
st
 bar that
enters the system)

Another Moving Average … and this in turn already has a 
period

If this is 20 and again our sample moving average has also 20, we end up
with a minimum period of 40 bars

Actually the internal calculation says 39 … because as soon as the first
moving average has produced a bar this counts for the next moving average,
which creates an overlapping bar, thus 39 are needed.

Other indicators/objects which also carry periods

Alleviating the situation is done as follows:

```
class SimpleMovingAverage1(Indicator):
    lines = ('sma',)
    params = (('period', 20),)

    def __init__(self):
        self.addminperiod(self.params.period)

    def next(self):
        datasum = math.fsum(self.data.get(size=self.p.period))
        self.lines.sma[0] = datasum / self.p.period

```

The 
addminperiod
 method is telling the system to take into account the extra

period
 bars needed by this indicator to whatever minimum period there may be
in existence.

Sometimes this is absolutely not needed, if all calculations are done with
objects which already communicate its period needs to the system.

A quick 
MACD
 implementation with Histogram:

```
from backtrader.indicators import EMA

class MACD(Indicator):
    lines = ('macd', 'signal', 'histo',)
    params = (('period_me1', 12), ('period_me2', 26), ('period_signal', 9),)

    def __init__(self):
        me1 = EMA(self.data, period=self.p.period_me1)
        me2 = EMA(self.data, period=self.p.period_me2)
        self.l.macd = me1 - me2
        self.l.signal = EMA(self.l.macd, period=self.p.period_signal)
        self.l.histo = self.l.macd - self.l.signal

```

Done! No need to think about mininum periods.

EMA
 stands for 
Exponential Moving Average
 (a platform built-in alias)

And this one (already in the platform) already states what it needs

The named lines of the indicator “macd” and “signal” are being assigned
    objects which already carry declared (behind the scenes) periods

macd takes the period from the operation “me1 - me2” which has in turn
    take the maximum from the periods of me1 and me2 (which are both
    exponential moving averages with different periods)

signal takes directly the period of the Exponential Moving Average over
    macd. This EMA also takes into account the already existing macd period
    and the needed amount of samples (period_signal) to calculate itself

histo takes the maximum of the two operands “signal - macd”. Once both
    are ready can histo also produce a value

A full custom indicator

Let’s develop a simple custom indicator which “indicates” if a moving average
(which can be modified with a parameter) is above the given data:

```
import backtrader as bt
import backtrader.indicators as btind

class OverUnderMovAv(bt.Indicator):
    lines = ('overunder',)
    params = dict(period=20, movav=btind.MovAv.Simple)

    def __init__(self):
        movav = self.p.movav(self.data, period=self.p.period)
        self.l.overunder = bt.Cmp(movav, self.data)

```

Done! The indicator will have a value of “1” if the average is above the data
and “-1” if below.

Be the data a regular data feed the 1s and -1s would be produced comparing with
the close price.

Although more can be seen in the 
Plotting
 section and to have a behaved and
nice citizen in the plotting world, a couple of things can be added:

```
import backtrader as bt
import backtrader.indicators as btind

class OverUnderMovAv(bt.Indicator):
    lines = ('overunder',)
    params = dict(period=20, movav=bt.ind.MovAv.Simple)

    plotinfo = dict(
        # Add extra margins above and below the 1s and -1s
        plotymargin=0.15,

        # Plot a reference horizontal line at 1.0 and -1.0
        plothlines=[1.0, -1.0],

        # Simplify the y scale to 1.0 and -1.0
        plotyticks=[1.0, -1.0])

    # Plot the line "overunder" (the only one) with dash style
    # ls stands for linestyle and is directly passed to matplotlib
    plotlines = dict(overunder=dict(ls='--'))

    def _plotlabel(self):
        # This method returns a list of labels that will be displayed
        # behind the name of the indicator on the plot

        # The period must always be there
        plabels = [self.p.period]

        # Put only the moving average if it's not the default one
        plabels += [self.p.movav] * self.p.notdefault('movav')

        return plabels

    def __init__(self):
        movav = self.p.movav(self.data, period=self.p.period)
        self.l.overunder = bt.Cmp(movav, self.data)

```
########################################
docu-induse.txt - lunghezza: 7976
########################################
Using Indicators

Indicators can be used in two places in the platform:

Inside Strategies

Inside other Indicators

Indicators in action

Indicators are always instantiated during 
__init__
 in the 
Strategy

Indicator values (or values thereof derived) are used/checked during

next

There is an important axiom to take into account:

Any 
Indicator
 (or value thereof derived) declared during 
__init__

    will be precalculated before 
next
 is called.

Let’s go for the differences an operation modes.

__init__
 vs 
next

Things works as follows:

Any 
operation
 involving 
lines
 objects during 
__init__
 generates
    another 
lines
 object

Any 
operation
 involving 
lines
 objects during 
next
 yields regular
    Python types like floats and bools.

During 
__init__

Example of an operation during 
__init__
:

```
hilo_diff = self.data.high - self.data.low

```

The variable 
hilo_diff
 holds a reference to a 
lines
 object which is
precalculated before calling 
next
 and can be accessed using the standard
array notation 
[]

It does obviously contains for each bar of the data feed the difference between
the high and the low.

This also works when mixing simple 
lines
 (like those in the self.data Data
Feed) and complex ones like indicators:

```
sma = bt.SimpleMovingAverage(self.data.close)
close_sma_diff = self.data.close - sma

```

Now 
close_sma_diff
 contains again a 
line
 object.

Using logical operatorss:

```
close_over_sma = self.data.close > sma

```

Now the generated 
lines
 object will contain an array of booleans.

During 
next

Example of an operation (logical operator):

```
close_over_sma = self.data.close > self.sma

```

Using the equivalent array (index 0 based notation):

```
close_over_sma = self.data.close[0] > self.sma[0]

```

In this case 
close_over_sma
 yields a boolen which is the result of
comparing two floating point values, the ones returned by the 
[0]
 operator
applied to 
self.data.close
 and 
self.sma

The 
__init__
 vs 
next

why

Logic simplification (and with it ease of use) is the key. Calculations and most
of the associated logic can be declared during 
__init__
 keeping the actual
operational logic to a minimum during 
next
.

There is actually a side benefit: 
speed
 (due to the precalculation explained
at the beginning)

A complete example which generates a 
buy
 signal during

__init__
:

```
class MyStrategy(bt.Strategy):

    def __init__(self):

        sma1 = btind.SimpleMovingAverage(self.data)
        ema1 = btind.ExponentialMovingAverage()

        close_over_sma = self.data.close > sma1
        close_over_ema = self.data.close > ema1
        sma_ema_diff = sma1 - ema1

        buy_sig = bt.And(close_over_sma, close_over_ema, sma_ema_diff > 0)

    def next(self):

        if buy_sig:
            self.buy()

```

Note

Python’s 
and
 operator cannot be overriden, forcing the platform to
define its own 
And
. The same applies to other constructs like

Or
 and 
If

It should be obvious that the “declarative” approach during 
__init__
 keeps
the bloating of 
next
 (where the actual strategy work happens) to a minimum.

(Don’t forget there is also a speed up factor)

Note

When the logic gets really complicated and involves several operations
it is usually much better to encapsulate that inside an

Indicator
.

Some notes

In the example above there are two things which have been simplified in

backtrader
 when compared to other platforms:

Declared 
Indicators
 are neither getting a 
parent
 parameter (like the
    strategy in which they are being created nor is any kind of “register”
    method/function being called.

And in spite of it the strategy will kick the calculation of the

Indicators
 and any 
lines
 object generated because of operations
(like 
sma - ema
)

ExponentialMovingAverage
 is being instantiated without 
self.data

This is intentional. If no 
data
 is passed, the 1
st
 data of the

parent
 (in this case the Strategy in which is being created) will be
automatically passed in the background

Indicator Plotting

First and foremost:

Declared 
Indicators
 get automatically plotted (if cerebro.plot is
    called)

lines
 objects from operations DO NOT GET plotted (like 
close_over_sma
    = self.data.close > self.sma
)

There is an auxiliary 
LinePlotterIndicator
 which plots such operations
if wished with the following approach:

```
close_over_sma = self.data.close > self.sma
LinePlotterIndicator(close_over_sma, name='Close_over_SMA')

```

The 
name
 parameter gives name to the 
single
 line held by this
indicator.

Controlling plotting

During the development of an 
Indicator
 a 
plotinfo
 declaration can be
added. It can be a tuple of tuples (2 elements), a 
dict
 or an

OrderedDict
. It looks like:

```
class MyIndicator(bt.Indicator):

    ....
    plotinfo = dict(subplot=False)
    ....

```

The value can be later accessed (and set) as follows (if needed):

```
myind = MyIndicator(self.data, someparam=value)
myind.plotinfo.subplot = True

```

The value can even be set during instantiation:

```
myind = MyIndicator(self.data, someparams=value, subplot=True)

```

The 
subplot=True
 will be passed to the (behind the scenes) intantiated
member variable 
plotinfo
 for the indicator.

The 
plotinfo
 offers the following parameters to control plotting behavior:

plot
 (default: 
True
)

Whether the indicator is to be plotted or not

subplot
 (default: 
True
)

Whether to plot the indicator in a different window. For indicators like
moving averages the default is changed to 
False

plotname
 (default: 
''
)

Sets the plotname to show on the plot. The empty value means the canonical
name of the indicator (
class.__name__
) will be used. This has some
limitations because Python identifiers cannot use for example arithmetic
operators.

An indicator like DI+ will be declared as follows:

```
class DIPlus(bt.Indicator):
    plotinfo=dict(plotname='DI+')

```

Making the plot “nicer”

plotabove
 (default: 
False
)

Indicators are usually plotted (those with 
subplot=True
) below the data
they have operated on. Setting this to 
True
 will make the indicator be
plotted above the data.

plotlinelabels
 (default: 
False
)

Meant for “indicators” on “indicators”. If one calculates the
SimpleMovingAverage of the RSI the plot will usually show the name
“SimpleMovingAverage” for the corresponding plotted line. This is the name
of the “Indicator” and not the actual line being plotted.

This default behavior makes sense because the user wants to usually see that
a SimpleMovingAverage has been created using the RSI.

if the value is set to 
True
 the actual name of the line inside the
SimpleMovingAverage will be used.

plotymargin
 (default: 
0.0
)

Amount of margin to leave at the top and bottom of the indicator (
0.15

-> 15%). Sometimes the 
matplotlib
 plots go too far to the top/bottom of
the axis and a margin may be wished

plotyticks
 (default: 
[]
)

Used to control the drawn y scale ticks

If an empty list is passed the “y ticks” will be automatically
calculated. For something like a Stochastic it may make sense to set this to
well-known idustry standards like: 
[20.0, 50.0, 80.0]

Some indicators offer parameters like 
upperband
 and 
lowerband
 that
are actually used to manipulate the y ticks

plothlines
 (default: 
[]
)

Used to control the drawing of horizontal lines along the indicator axis.

If an empty list is passed no horizontal lines will drawn.

For something like a Stochastic it may make sense to draw lines for
well-known idustry standards like: 
[20.0, 80.0]

Some indicators offer parameters like 
upperband
 and 
lowerband
 that
are actually used to manipulate the horizontal lines

plotyhlines
 (default: 
[]
)

Used to simultaneously control plotyticks and plothlines using a single parameter.

plotforce
 (default: 
False
)

If for some reason you believe an indicator should be plotting and it is not
plotting … set this to 
True
 as a last resort.
########################################
docu-installation.txt - lunghezza: 1683
########################################
Installation

Requirements and versions

backtrader
 is self-contained with no external dependencies (except if you
want to plot)

Basic requirements are:

Python 2.7

Python 3.2 / 3.3/ 3.4 / 3.5

pypy/pypy3

Additional requirements if plotting is wished:

Matplotlib >= 1.4.1

It may work with previous versions, but this the one used for
development

NOTE
: At the time of writing Matplotlib is not supported under 
pypy/pypy3

Python 2.x/3.x compatibility

Development takes place under Python 2.7 and sometimes under 3.4. Tests are run
locally with both versions.

Compatibility with 3.2 / 3.3 / 3.5 and pypy/pyp3 is checked with continuous
integration under Travis

Install from pypi

For example using pip:

```
pip install backtrader

```

easy_install
 with the same syntax can also be applied

Install from pypi (including 
matplotlib
)

Use this if plotting capabilities are wished:

```
pip install backtrader[plotting]

```

This pulls in matplotlib which will in turn pull in other dependencies.

Again you may prefer (or only have access to …) 
easy_install

Install from source

First downloading a release or the latest tarball from the github site:

https://github.com/mementum/backtrader

And after unpacking run the command:

```
python setup.py install

```

Run from source in your project

Download a release or the latest tarball from the github site:

https://github.com/mementum/backtrader

And then copy the 
backtrader
 package directory to your own project. Under a
Unix-like OS for example:

```
tar xzf backtrader.tgz
cd backtrader
cp -r backtrader project_directory

```

Remember that you would then need to manually install 
matplotlib
 for
plotting.
########################################
docu-live-live.txt - lunghezza: 154
########################################
Live Data Feeds and Live Trading

Starting with release 
1.5.0

backtrader
 supports live data and live
trading.

Interactive Brokers

Visual Chart

Oanda
########################################
docu-memory-savings-memory-savings.txt - lunghezza: 12631
########################################
Saving Memory

Release 1.3.1.92
 has reworked
and fully implemented the memory saving schemes that were previously in place,
although not much touted and less used.

backtrader
 was (and will be further) developed in machines with nice
amounts of RAM and that put together with the fact that visual feedback through
plotting is a nice to have and almost a must have, mde it easy for a design
decision: keep everything in memory.

This decision has some drawbacks:

array.array
 which is used for data storage has to allocate and move
    data when some bounds are exceeded

Machines with low amounts of RAM may suffer

Connection to a live data feed which can be online for weeks/months feeded
    thousands of seconds/minutes resolution ticks into the system

The latter being even more important than the 1
st
 due to another design
decision which was made for 
backtrader
:

Be pure Python to allow to run in embedded systems if needed be

A scenario in the future could have 
backtrader
 connected to a 2
nd

machine which provides the live feed, whilst 
backtrader
 itself runs
inside a 
Raspberry Pi
 or something even more limited like an ADSL Router
(AVM Frit!Box 7490 with a 
Freetz
 image)

Hence the need to have 
backtrader
 support dynamic memory schemes. Now

Cerebro
 can be instantiated or 
run
 with the following semantics:

exactbars (default: False)

With the default 
False
 value each and every value stored in a line
is kept in memory

Possible values:

True
 or 
1
: all “lines” objects reduce memory usage to the
    automatically calculated minimum period.

If a Simple Moving Average has a period of 30, the underlying data
will have always a running buffer of 30 bars to allow the
calculation of the Simple Moving Average

This setting will deactivate 
preload
 and 
runonce

Using this setting also deactivates 
plotting

-1
: datas and indicators/operations at strategy level will keep
    all data in memory.

For example: a 
RSI
 internally uses the indicator 
UpDay
 to
make calculations. This subindicator will not keep all data in
memory

This allows to keep 
plotting
 and 
preloading
 active.

runonce
 will be deactivated

-2
: datas and indicators kept as attributes of the strategy
    will keep all data in memory.

For example: a 
RSI
 internally uses the indicator 
UpDay
 to
make calculations. This subindicator will not keep all data in
memory

If in the 
__init__
 something like

a = self.data.close - self.data.high
 is defined, then 
a

will not keep all data in memory

This allows to keep 
plotting
 and 
preloading
 active.

runonce
 will be deactivated

As always, an example is worth a thousand words. A sample script shows the
differences. It runs against the 
Yahoo
 daily data for the years 1996 to 2015,
for a total of 
4965
 days.

Note

This is a small sample. The EuroStoxx50 future which trades 14 hours
a day, would produce approximately 18000 1-minute bars in just 1
month of trading.

The script 1
st
 executed to see how many memory positions are used when no
memory savings are requested:

```
$ ./memory-savings.py --save 0
Total memory cells used: 506430

```

For level 1 (total savings):

```
$ ./memory-savings.py --save 1
Total memory cells used: 2041

```

OMG!!! Down from 
half-a-million
 to 
2041
. Indeed. Each an every 
lines

object in the system uses a 
collections.deque
 as buffer (instead of

array.array
) and is length-bounding to the absolute needed minimum for the
requested operations. Example:

A Strategy using a 
SimpleMovingAverage
 of period 
30
 on the data
    feed.

In this case the following adjustments would be made:

The 
data feed
 will have a buffer of 
30
 positions, the amount needed
    by the 
SimpleMovingAverage
 to produce the next value

The 
SimpleMovingAverage
 will have a buffer of 
1
 position, because
    unless needed by other 
indicator
 (which would rely on the moving average)
    there is no need to keep a larger buffer in place.

Note

The most attractive and probably important feature of this mode is that the
amount of memory used remains constant throughout the entire life of a
script.

Regardless of the size of the data feed.

This would be of great use if for example connected to a live feed for a
long period of time.

But take into account:

Plotting
 is not available

There are other sources of memory consumption which would accumulate
     over time like 
orders
 generated by the strategy.

This mode can only be used with 
runonce=False
 in 
cerebro
. This
     would also be compulsory for a live data feed, but in case of simple
     backtesting this is slower than 
runonce=True
.

There is for sure a trade off point from which memory management is
 more expensive than the step-by-step execution of the backtesting, but
 this can only be judged by the end-user of the platform on a case by
 case basis.

Now the negative levels. These are meant to keep 
plotting
 available whilst
still saving a decent amount of memory. First level 
-1
:

```
$ ./memory-savings.py --save -1
Total memory cells used: 184623

```

In this case the 1
st
 level of 
indicators
 (those declared in the strategy)
keep its full length buffers. But if this indicators rely on others (which is
the case) to do its work, the subobjects will be length-bounded. In this case
we have gone from:

506430
 memory positions to -> 
184623

Over 50% savings.

Note

Of course 
array.array
 objects have been traded for

collections.deque
 which are more expensive in memory terms
although faster in operation terms. But the 
collection.deque

objects are rather small and the savings approach the roughly
counted memory positions used.

Level 
-2
 now, which is meant to also save on the indicators declared at the
strategy level which have been marked as no to be plotted:

```
$ ./memory-savings.py --save -2
Total memory cells used: 174695

```

Not much has been saved now. This being because a single indicator has been
tagged as not be plotted: 
TestInd().plotinfo.plot = False

Let’s see the plotting from this last example:

```
$ ./memory-savings.py --save -2 --plot
Total memory cells used: 174695

```

For the interested reader, the sample script can produce a detailed analysis of
each 
lines
 object traversed in the hierarchy of 
indicators
. Running with

plotting
 enabled (saving at 
-1
):

```
$ ./memory-savings.py --save -1 --lendetails
-- Evaluating Datas
---- Data 0 Total Cells 34755 - Cells per Line 4965
-- Evaluating Indicators
---- Indicator 1.0 Average Total Cells 30 - Cells per line 30
---- SubIndicators Total Cells 1
---- Indicator 1.1 _LineDelay Total Cells 1 - Cells per line 1
---- SubIndicators Total Cells 1
...
---- Indicator 0.5 TestInd Total Cells 9930 - Cells per line 4965
---- SubIndicators Total Cells 0
-- Evaluating Observers
---- Observer 0 Total Cells 9930 - Cells per Line 4965
---- Observer 1 Total Cells 9930 - Cells per Line 4965
---- Observer 2 Total Cells 9930 - Cells per Line 4965
Total memory cells used: 184623

```

The same but with maximum savings (
1
) enabled:

```
$ ./memory-savings.py --save 1 --lendetails
-- Evaluating Datas
---- Data 0 Total Cells 266 - Cells per Line 38
-- Evaluating Indicators
---- Indicator 1.0 Average Total Cells 30 - Cells per line 30
---- SubIndicators Total Cells 1
...
---- Indicator 0.5 TestInd Total Cells 2 - Cells per line 1
---- SubIndicators Total Cells 0
-- Evaluating Observers
---- Observer 0 Total Cells 2 - Cells per Line 1
---- Observer 1 Total Cells 2 - Cells per Line 1
---- Observer 2 Total Cells 2 - Cells per Line 1

```

The 2
nd
 output immediately shows how the lines in the 
data feed
 have been
capped to 
38
 memory positions instead of the 
4965
 which comprises the
full data source length.

And 
indicators
 and 
observers
 have been when possible capped to 
1
 as
seen in the last lines of the output.

Script Code and Usage

Available as sample in the sources of 
backtrader
. Usage:

```
$ ./memory-savings.py --help
usage: memory-savings.py [-h] [--data DATA] [--save SAVE] [--datalines]
                         [--lendetails] [--plot]

Check Memory Savings

optional arguments:
  -h, --help    show this help message and exit
  --data DATA   Data to be read in (default: ../../datas/yhoo-1996-2015.txt)
  --save SAVE   Memory saving level [1, 0, -1, -2] (default: 0)
  --datalines   Print data lines (default: False)
  --lendetails  Print individual items memory usage (default: False)
  --plot        Plot the result (default: False)

```

The code:

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import sys

import backtrader as bt
import backtrader.feeds as btfeeds
import backtrader.indicators as btind
import backtrader.utils.flushfile

class TestInd(bt.Indicator):
    lines = ('a', 'b')

    def __init__(self):
        self.lines.a = b = self.data.close - self.data.high
        self.lines.b = btind.SMA(b, period=20)

class St(bt.Strategy):
    params = (
        ('datalines', False),
        ('lendetails', False),
    )

    def __init__(self):
        btind.SMA()
        btind.Stochastic()
        btind.RSI()
        btind.MACD()
        btind.CCI()
        TestInd().plotinfo.plot = False

    def next(self):
        if self.p.datalines:
            txt = ','.join(
                ['%04d' % len(self),
                 '%04d' % len(self.data0),
                 self.data.datetime.date(0).isoformat()]
            )

            print(txt)

    def loglendetails(self, msg):
        if self.p.lendetails:
            print(msg)

    def stop(self):
        super(St, self).stop()

        tlen = 0
        self.loglendetails('-- Evaluating Datas')
        for i, data in enumerate(self.datas):
            tdata = 0
            for line in data.lines:
                tdata += len(line.array)
                tline = len(line.array)

            tlen += tdata
            logtxt = '---- Data {} Total Cells {} - Cells per Line {}'
            self.loglendetails(logtxt.format(i, tdata, tline))

        self.loglendetails('-- Evaluating Indicators')
        for i, ind in enumerate(self.getindicators()):
            tlen += self.rindicator(ind, i, 0)

        self.loglendetails('-- Evaluating Observers')
        for i, obs in enumerate(self.getobservers()):
            tobs = 0
            for line in obs.lines:
                tobs += len(line.array)
                tline = len(line.array)

            tlen += tdata
            logtxt = '---- Observer {} Total Cells {} - Cells per Line {}'
            self.loglendetails(logtxt.format(i, tobs, tline))

        print('Total memory cells used: {}'.format(tlen))

    def rindicator(self, ind, i, deep):
        tind = 0
        for line in ind.lines:
            tind += len(line.array)
            tline = len(line.array)

        thisind = tind

        tsub = 0
        for j, sind in enumerate(ind.getindicators()):
            tsub += self.rindicator(sind, j, deep + 1)

        iname = ind.__class__.__name__.split('.')[-1]

        logtxt = '---- Indicator {}.{} {} Total Cells {} - Cells per line {}'
        self.loglendetails(logtxt.format(deep, i, iname, tind, tline))
        logtxt = '---- SubIndicators Total Cells {}'
        self.loglendetails(logtxt.format(deep, i, iname, tsub))

        return tind + tsub

def runstrat():
    args = parse_args()

    cerebro = bt.Cerebro()
    data = btfeeds.YahooFinanceCSVData(dataname=args.data)
    cerebro.adddata(data)
    cerebro.addstrategy(
        St, datalines=args.datalines, lendetails=args.lendetails)

    cerebro.run(runonce=False, exactbars=args.save)
    if args.plot:
        cerebro.plot(style='bar')

def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Check Memory Savings')

    parser.add_argument('--data', required=False,
                        default='../../datas/yhoo-1996-2015.txt',
                        help='Data to be read in')

    parser.add_argument('--save', required=False, type=int, default=0,
                        help=('Memory saving level [1, 0, -1, -2]'))

    parser.add_argument('--datalines', required=False, action='store_true',
                        help=('Print data lines'))

    parser.add_argument('--lendetails', required=False, action='store_true',
                        help=('Print individual items memory usage'))

    parser.add_argument('--plot', required=False, action='store_true',
                        help=('Plot the result'))

    return parser.parse_args()

if __name__ == '__main__':
    runstrat()

```
########################################
docu-mixing-timeframes-indicators-mixing-timeframes.txt - lunghezza: 7581
########################################
Mixing Timeframes in Indicators

Release 1.3.0.92
 brings up the
possibility to have data (from either data feeds and/or indicators) from
different timeframes mixed.

Background: 
Indicators are smart dumb objects.

They are smart because they can make complex calculations.

They are dumb because they operate with no knowledge of what sources are
    providing the data for the calculations

As such:

If the data sources providing the values have different timeframes,
    different lengths inside the 
Cerebro
 engine, the indicator will break.

Example of a calculation, in which 
data0
 has a timeframe of days and

data1
 has a timeframe of 
months
:

```
pivotpoint = btind.PivotPoint(self.data1)
sellsignal = self.data0.close < pivotpoint.s1

```

Here a 
sell signal
 is sought when the close is below the 
s1
 line (
1
st

support
)

Note

PivotPoint
 works in a larger timeframe by definition

This will in the past with the following error:

```
return self.array[self.idx + ago]
IndexError: array index out of range

```

And for a good reason: 
self.data.close
 provides values from the very 1
st

instant, but 
PivotPoint
 (and hence the 
s1
 line) will only deliver
values once a 
full month
 has gone by, which is roughly equivalent to 22
values of 
self.data0.close
. During this 22 
closes
 there isn’t yet a value
for 
s1
 and the attempt to fetch it from the underlying array fails.

Lines
 objects support the 
(ago)
 operator (
__call__
 special method in

Python
) for deliver a delayed version of itself:

```
close1 = self.data.close(-1)

```

In this example the object 
close1
 (when accessed via 
[0]
) always contains
the previous value (
-1
) delivered by 
close
. The syntax has been
reused to accomodate adapting timeframes. Let’s rewrite the above

pivotpoint
 snippet:

```
pivotpoint = btind.PivotPoint(self.data1)
sellsignal = self.data0.close < pivotpoint.s1()

```

See how the 
()
 is executed with no arguments (in the background a 
None

is being supplied). The following is happening:

pivotpoint.s1()
 is returning an internal 
LinesCoupler
 object which
    follows the rhythm of the larger scope. This coupler fills itself with the
    latest delivered value from the real 
s1
 (starting with a default value
    of 
NaN
)

But something extra is needed to make the magic work. 
Cerebro
 has to be
created with:

```
cerebro = bt.Cerebro(runonce=False)

```

or executed with:

```
cerebro.run(runonce=False)

```

In this mode the indicators and late-evaluated automatic 
lines
 objects are
executed step by step rather than in tight loops. This makes the entire
operation slower, but it makes it 
possible

The sample script at the bottom which was breaking above, now runs:

```
$ ./mixing-timeframes.py

```

With output:

```
0021,0021,0001,2005-01-31,2984.75,2935.96,0.00
0022,0022,0001,2005-02-01,3008.85,2935.96,0.00
...
0073,0073,0003,2005-04-15,3013.89,3010.76,0.00
0074,0074,0003,2005-04-18,2947.79,3010.76,1.00
...

```

At line 74 the 1
st
 instance of 
close < s1
 takes place.

The script also provides insight into the additional possiblity: 
couple all
lines of an indicator
. Before we had:

```
self.sellsignal = self.data0.close < pp.s1()

```

Being the alternative:

```
pp1 = pp()
self.sellsignal = self.data0.close < pp1.s1

```

Now the entire 
PivotPoint
 indicator has been coupled and any of its lines
can be accessed (namely 
p
, 
r1
, 
r2
, 
s1
, 
s2
). The script has
only interest in 
s1
 and the access is direct.:

```
$ ./mixing-timeframes.py --multi

```

The output:

```
0021,0021,0001,2005-01-31,2984.75,2935.96,0.00
0022,0022,0001,2005-02-01,3008.85,2935.96,0.00
...
0073,0073,0003,2005-04-15,3013.89,3010.76,0.00
0074,0074,0003,2005-04-18,2947.79,3010.76,1.00
...

```

No surprises here. The same as before. The “coupled” object can even be
plotted:

```
$ ./mixing-timeframes.py --multi --plot

```

Full coupling syntax

For 
lines
 objects with multiple lines (for example 
Indicators
 like

PivotPoint
):

obj(clockref=None, line=-1)

clockref

  If 
clockref
 is 
None
, the surrounding object (in the examples a

Strategy
) will be the reference to adapt larger timeframes (for
  example: 
Months
) to smaller/faster timeframes (for example: 
Days
)

Another reference can be used if desired

line

```
* If the default `-1` is given, all *lines* are coupled.

* If another integer (for example, `0` or `1`) a single line will be
  coupled and fetched by index (from `obj.lines[x]`)

* If a string is passed, the line will be fetched by name.

  In the sample, the following could have been done:

  ```python
  coupled_s1 = pp(line='s1')
  ```

```

For 
lines
 objects with a single line (for example line 
s1
 from the
indicator 
PivotPoint
):

obj(clockref=None)
 (see above for 
clockref
)

Conclusion

Integrated in the regular 
()
 syntax, data feeds from different timeframes can be
mixed in indicators, always taking into account that 
cerebro
 needs to be
instantiated or created with 
runonce=False
.

Script Code and Usage

Available as sample in the sources of 
backtrader
. Usage:

```
$ ./mixing-timeframes.py --help
usage: mixing-timeframes.py [-h] [--data DATA] [--multi] [--plot]

Sample for pivot point and cross plotting

optional arguments:
  -h, --help   show this help message and exit
  --data DATA  Data to be read in (default: ../../datas/2005-2006-day-001.txt)
  --multi      Couple all lines of the indicator (default: False)
  --plot       Plot the result (default: False)

```

The code:

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse

import backtrader as bt
import backtrader.feeds as btfeeds
import backtrader.indicators as btind
import backtrader.utils.flushfile

class St(bt.Strategy):
    params = dict(multi=True)

    def __init__(self):
        self.pp = pp = btind.PivotPoint(self.data1)
        pp.plotinfo.plot = False  # deactivate plotting

        if self.p.multi:
            pp1 = pp()  # couple the entire indicators
            self.sellsignal = self.data0.close < pp1.s1
        else:
            self.sellsignal = self.data0.close < pp.s1()

    def next(self):
        txt = ','.join(
            ['%04d' % len(self),
             '%04d' % len(self.data0),
             '%04d' % len(self.data1),
             self.data.datetime.date(0).isoformat(),
             '%.2f' % self.data0.close[0],
             '%.2f' % self.pp.s1[0],
             '%.2f' % self.sellsignal[0]])

        print(txt)

def runstrat():
    args = parse_args()

    cerebro = bt.Cerebro()
    data = btfeeds.BacktraderCSVData(dataname=args.data)
    cerebro.adddata(data)
    cerebro.resampledata(data, timeframe=bt.TimeFrame.Months)

    cerebro.addstrategy(St, multi=args.multi)

    cerebro.run(stdstats=False, runonce=False)
    if args.plot:
        cerebro.plot(style='bar')

def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Sample for pivot point and cross plotting')

    parser.add_argument('--data', required=False,
                        default='../../datas/2005-2006-day-001.txt',
                        help='Data to be read in')

    parser.add_argument('--multi', required=False, action='store_true',
                        help='Couple all lines of the indicator')

    parser.add_argument('--plot', required=False, action='store_true',
                        help=('Plot the result'))

    return parser.parse_args()

if __name__ == '__main__':
    runstrat()

```
########################################
docu-observer-benchmark-benchmarking.txt - lunghezza: 14967
########################################
Benchmarking

Ticket #89
 is about
adding benchmarking against an asset. Sensible as one may actually have a
strategy that even if positive is below what simply tracking the asset would
have delivered.

backtrader
 includes 2 different types of objects which can aid with tracking:

Observers

Analyzers

In the realm of 
Analyzers
 there was already a 
TimeReturn
 object which
tracks the evolution of the returns of the entire portfolio value (i.e:
including cash)

This could have also obviously been an 
Observer
, so whilst adding some

benchmarking
 some work has also gone into being able to plug together an

Observer
 and an 
Analyzer
 which are meant to track the same thing.

Note

The major difference between 
Observers
 and 
Analyzers
 is the 
lines

nature of 
observers
, which record every value and this makes them suitable

s    for plotting and real time querying. This of course consumes memory.

Analyzers
 on the other hand return a set of results via 
get_analysis

and the implementation may not deliver any result until the very end of a

run
.

Analyzers - Benchmarking

The standard 
TimeReturn
 analyzer has been extended to support tracking a

data feed
. The 2 major parameters invoved:

timeframe
 (default: 
None
)
    If 
None
 then the complete return over the entire backtested period
    will be reported

Pass 
TimeFrame.NoTimeFrame
 to consider the entire dataset with no
time constraints

data
 (default: 
None
)

Reference asset to track instead of the portfolio value.

Note

this data must have been added to a 
cerebro
 instance with

addata
, 
resampledata
 or 
replaydata

For more details and parameters: Analyzers Reference

As such, the returns of the porftolio on a yearly basis can be tracked like
this

```
import backtrader as bt

cerebro = bt.Cerebro()
cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years)

...  # add datas, strategies ...

results = cerebro.run()
strat0 = results[0]

# If no name has been specified, the name is the class name lowercased
tret_analyzer = strat0.analyzers.getbyname('timereturn')
print(tret_analyzer.get_analysis())

```

If we wanted to track the returns of a 
data

```
import backtrader as bt

cerebro = bt.Cerebro()

data = bt.feeds.OneOfTheFeeds(dataname='abcde', ...)
cerebro.adddata(data)

cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years,
                    data=data)

...  # add strategies ...

results = cerebro.run()
strat0 = results[0]

# If no name has been specified, the name is the class name lowercased
tret_analyzer = strat0.analyzers.getbyname('timereturn')
print(tret_analyzer.get_analysis())

```

If both are to be tracked, the best is to assign names to the 
analyzers

```
import backtrader as bt

cerebro = bt.Cerebro()

data = bt.feeds.OneOfTheFeeds(dataname='abcde', ...)
cerebro.adddata(data)

cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years,
                    data=data, _name='datareturns')

cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years)
                    _name='timereturns')

...  # add strategies ...

results = cerebro.run()
strat0 = results[0]

# If no name has been specified, the name is the class name lowercased
tret_analyzer = strat0.analyzers.getbyname('timereturns')
print(tret_analyzer.get_analysis())
tdata_analyzer = strat0.analyzers.getbyname('datareturns')
print(tdata_analyzer.get_analysis())

```

Observers - Benchmarking

Thanks to the background machinery allowing the usage of 
Analyzers
 inside

Observers
, 2 new observers have been added:

TimeReturn

Benchmark

Both use the 
bt.analyzers.TimeReturn
 analyzer to collect results.

Rather than having code snippets like above, a full sample with some runs to
show their functionality.

Observing TimeReturn

Execution:

```
$ ./observer-benchmark.py --plot --timereturn --timeframe notimeframe

```

Notice the execution options:

--timereturn
 telling the sample to do just that

--timeframe notimeframe
 telling the analyzer to consider the entire
    data set disregarding timeframe boundaries.

The last plotted value is 
-0.26
.

The starting cash (obvious from the chart) are 
50K
 monetary units and the strategy ends
    up with 
36,970
 monetary units and hence a 
-26%
 value decrement.

Observing Benchmarking

Because 
benchmarking
 will also display the 
timereturn
 results, let’s run
the same thing but with 
benchmarking
 active:

```
$ ./observer-benchmark.py --plot --timeframe notimeframe

```

Hey, hey hey!!!

The strategy is better than the asset: 
-0.26
 vs 
-0.33

It shouldn’t be a matter for celebration but at least is clear the strategy
is not even as bad as the asset.

Moving down to track things on a 
yearly
 basis:

```
$ ./observer-benchmark.py --plot --timeframe years

```

Watch out!

The strategy last value has changed very slightly from 
-0.26
 to

-0.27

The asset on the on the other hand shows a last value of 
-0.35
 (versus

-0.33
 above)

The reason for values so close to each other is that when moving from 2005 to
2006, both the strategy and the benchmarking asset were almost at the starting
level from the beginning of 2005.

Switching to a lower timeframe like 
weeks
, the entire picture changes:

```
$ ./observer-benchmark.py --plot --timeframe weeks

.. image:: 04-benchmarking-weeks.png

```

Now:

The 
Benchmark
 observer shows a much more nervous aspect. Things move up
    and down, because now 
weekly
 returns for both the portfolio and the
    data are being tracked

And because no trade was active in the last week of the year and the asset
    barely moved, the last displayed values are 0.00 (The last closing value
    before the last week was 
25.54
 and the sample data closed at 
25.55
,
    and the difference is felt first at the 4
th
 decimal point)

Observing Benchmarking - Another data

The sample allows to benchmark against a different data. The default is to
benchmark against 
Oracle
 when using 
--benchdata1
. Considering the entire
dataset with 
--timeframe notimeframe
:

```
$ ./observer-benchmark.py --plot --timeframe notimeframe --benchdata1

```

It’s clear now why there was no reason for celebration above:

The results of the strategy have not changed for 
notimeframe
 and remain
    at 
-26%
 (
-0.26
)

But when benchmarking against another data, this data has a 
+23%

    (
0.23
 ) in the same period

Either the strategy needs a change or another asset better be traded.

Concluding

There are now two ways, using the same underlying code/calculations, to track
the 
TimeReturn
 and 
Benchmark

Observers
  (
TimeReturn
 and 
Benchmark
)

and

Analyzer
 (
TimeReturn
 and 
TimeReturn
 with a 
data
 parameter)

Of course 
benchmarking
 doesn’t guarantee profit, just 
comparison
.

Usage of the sample:

```
$ ./observer-benchmark.py --help
usage: observer-benchmark.py [-h] [--data0 DATA0] [--data1 DATA1]
                             [--benchdata1] [--fromdate FROMDATE]
                             [--todate TODATE] [--printout] [--cash CASH]
                             [--period PERIOD] [--stake STAKE] [--timereturn]
                             [--timeframe {months,days,notimeframe,years,None,weeks}]
                             [--plot [kwargs]]

Benchmark/TimeReturn Observers Sample

optional arguments:
  -h, --help            show this help message and exit
  --data0 DATA0         Data0 to be read in (default:
                        ../../datas/yhoo-1996-2015.txt)
  --data1 DATA1         Data1 to be read in (default:
                        ../../datas/orcl-1995-2014.txt)
  --benchdata1          Benchmark against data1 (default: False)
  --fromdate FROMDATE   Starting date in YYYY-MM-DD format (default:
                        2005-01-01)
  --todate TODATE       Ending date in YYYY-MM-DD format (default: 2006-12-31)
  --printout            Print data lines (default: False)
  --cash CASH           Cash to start with (default: 50000)
  --period PERIOD       Period for the crossover moving average (default: 30)
  --stake STAKE         Stake to apply for the buy operations (default: 1000)
  --timereturn          Use TimeReturn observer instead of Benchmark (default:
                        None)
  --timeframe {months,days,notimeframe,years,None,weeks}
                        TimeFrame to apply to the Observer (default: None)
  --plot [kwargs], -p [kwargs]
                        Plot the read data applying any kwargs passed For
                        example: --plot style="candle" (to plot candles)
                        (default: None)

```

The code

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime
import random

import backtrader as bt

class St(bt.Strategy):
    params = (
        ('period', 10),
        ('printout', False),
        ('stake', 1000),
    )

    def __init__(self):
        sma = bt.indicators.SMA(self.data, period=self.p.period)
        self.crossover = bt.indicators.CrossOver(self.data, sma)

    def start(self):
        if self.p.printout:
            txtfields = list()
            txtfields.append('Len')
            txtfields.append('Datetime')
            txtfields.append('Open')
            txtfields.append('High')
            txtfields.append('Low')
            txtfields.append('Close')
            txtfields.append('Volume')
            txtfields.append('OpenInterest')
            print(','.join(txtfields))

    def next(self):
        if self.p.printout:
            # Print only 1st data ... is just a check that things are running
            txtfields = list()
            txtfields.append('%04d' % len(self))
            txtfields.append(self.data.datetime.datetime(0).isoformat())
            txtfields.append('%.2f' % self.data0.open[0])
            txtfields.append('%.2f' % self.data0.high[0])
            txtfields.append('%.2f' % self.data0.low[0])
            txtfields.append('%.2f' % self.data0.close[0])
            txtfields.append('%.2f' % self.data0.volume[0])
            txtfields.append('%.2f' % self.data0.openinterest[0])
            print(','.join(txtfields))

        if self.position:
            if self.crossover < 0.0:
                if self.p.printout:
                    print('CLOSE {} @%{}'.format(size,
                                                 self.data.close[0]))
                self.close()

        else:
            if self.crossover > 0.0:
                self.buy(size=self.p.stake)
                if self.p.printout:
                    print('BUY   {} @%{}'.format(self.p.stake,
                                                self.data.close[0]))

TIMEFRAMES = {
    None: None,
    'days': bt.TimeFrame.Days,
    'weeks': bt.TimeFrame.Weeks,
    'months': bt.TimeFrame.Months,
    'years': bt.TimeFrame.Years,
    'notimeframe': bt.TimeFrame.NoTimeFrame,
}

def runstrat(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()
    cerebro.broker.set_cash(args.cash)

    dkwargs = dict()
    if args.fromdate:
        fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')
        dkwargs['fromdate'] = fromdate

    if args.todate:
        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')
        dkwargs['todate'] = todate

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0, **dkwargs)
    cerebro.adddata(data0, name='Data0')

    cerebro.addstrategy(St,
                        period=args.period,
                        stake=args.stake,
                        printout=args.printout)

    if args.timereturn:
        cerebro.addobserver(bt.observers.TimeReturn,
                            timeframe=TIMEFRAMES[args.timeframe])
    else:
        benchdata = data0
        if args.benchdata1:
            data1 = bt.feeds.YahooFinanceCSVData(dataname=args.data1, **dkwargs)
            cerebro.adddata(data1, name='Data1')
            benchdata = data1

        cerebro.addobserver(bt.observers.Benchmark,
                            data=benchdata,
                            timeframe=TIMEFRAMES[args.timeframe])

    cerebro.run()

    if args.plot:
        pkwargs = dict()
        if args.plot is not True:  # evals to True but is not True
            pkwargs = eval('dict(' + args.plot + ')')  # args were passed

        cerebro.plot(**pkwargs)

def parse_args(pargs=None):

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Benchmark/TimeReturn Observers Sample')

    parser.add_argument('--data0', required=False,
                        default='../../datas/yhoo-1996-2015.txt',
                        help='Data0 to be read in')

    parser.add_argument('--data1', required=False,
                        default='../../datas/orcl-1995-2014.txt',
                        help='Data1 to be read in')

    parser.add_argument('--benchdata1', required=False, action='store_true',
                        help=('Benchmark against data1'))

    parser.add_argument('--fromdate', required=False,
                        default='2005-01-01',
                        help='Starting date in YYYY-MM-DD format')

    parser.add_argument('--todate', required=False,
                        default='2006-12-31',
                        help='Ending date in YYYY-MM-DD format')

    parser.add_argument('--printout', required=False, action='store_true',
                        help=('Print data lines'))

    parser.add_argument('--cash', required=False, action='store',
                        type=float, default=50000,
                        help=('Cash to start with'))

    parser.add_argument('--period', required=False, action='store',
                        type=int, default=30,
                        help=('Period for the crossover moving average'))

    parser.add_argument('--stake', required=False, action='store',
                        type=int, default=1000,
                        help=('Stake to apply for the buy operations'))

    parser.add_argument('--timereturn', required=False, action='store_true',
                        default=None,
                        help=('Use TimeReturn observer instead of Benchmark'))

    parser.add_argument('--timeframe', required=False, action='store',
                        default=None, choices=TIMEFRAMES.keys(),
                        help=('TimeFrame to apply to the Observer'))

    # Plot options
    parser.add_argument('--plot', '-p', nargs='?', required=False,
                        metavar='kwargs', const=True,
                        help=('Plot the read data applying any kwargs passed\n'
                              '\n'
                              'For example:\n'
                              '\n'
                              '  --plot style="candle" (to plot candles)\n'))

    if pargs:
        return parser.parse_args(pargs)

    return parser.parse_args()

if __name__ == '__main__':
    runstrat()

```
########################################
docu-observers-and-statistics-observers-and-statistics.txt - lunghezza: 14624
########################################
Observers and Statistics

Strategies running inside the 
backtrader
 do mostly deal with 
data feeds

and 
indicators
.

Data feeds are added to 
Cerebro
 instances and end up being part of the
input of strategies (parsed and served as attributes of the instance) whereas
Indicators are declared and managed by the Strategy itself.

All 
backtrader
 sample charts have so far had 3 things plotted which seem to
be taken for granted because they are not declared anywhere:

Cash and Value (what’s happening with the money in the broker)

Trades (aka Operations)

Buy/Sell Orders

They are 
Observers
 and exist within the submodule

backtrader.observers
. They are there because 
Cerebro
 supports a
parameter to automatically add (or not) them to the Strategy:

stdstats
 (default: 
True
)

If the default is respected 
Cerebro
 executes the following equivalent user
code:

```
import backtrader as bt

...

cerebro = bt.Cerebro()  # default kwarg: stdstats=True

cerebro.addobserver(bt.observers.Broker)
cerebro.addobserver(bt.observers.Trades)
cerebro.addobserver(bt.observers.BuySell)

```

Let’s see the usual chart with those 3 default observers (even if no order is
issued and therefore no trade happens and there is no change to the cash and
portfolio value)

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import backtrader as bt
import backtrader.feeds as btfeeds

if __name__ == '__main__':
    cerebro = bt.Cerebro(stdstats=False)
    cerebro.addstrategy(bt.Strategy)

    data = bt.feeds.BacktraderCSVData(dataname='../../datas/2006-day-001.txt')
    cerebro.adddata(data)

    cerebro.run()
    cerebro.plot()

```

Now let’s change the value of 
stdstats
 to 
False
 when creating the

Cerebro
 instance (can also be done when invoking 
run
):

```
cerebro = bt.Cerebro(stdstats=False)

```

The chart is different now.

Accesing the Observers

The Observers as seen above are already there in the default case and collecting
information which can be used for statistical purposes and that’s why acess to
the observers can be done through an attribute of the strategy called:

stats

It is simply a placeholder. If we recall the addition of one of the default

Observers
 as laid out above:

```
...
cerebro.addobserver(backtrader.observers.Broker)
...

```

The obvious question would be how to access the 
Broker
 observer. Here for
example how it’s done from the 
next
 method of a strategy:

```
class MyStrategy(bt.Strategy):

    def next(self):

        if self.stats.broker.value[0] < 1000.0:
           print('WHITE FLAG ... I LOST TOO MUCH')
        elif self.stats.broker.value[0] > 10000000.0:
           print('TIME FOR THE VIRGIN ISLANDS ....!!!')

```

The 
Broker
 observer just like a Data, an Indicator and the Strategy itself
is also a 
Lines
 objects. In this case the 
Broker
 has 2 lines:

cash

value

Observer Implementation

The implementation is very similar to that of an Indicator:

```
class Broker(Observer):
    alias = ('CashValue',)
    lines = ('cash', 'value')

    plotinfo = dict(plot=True, subplot=True)

    def next(self):
        self.lines.cash[0] = self._owner.broker.getcash()
        self.lines.value[0] = value = self._owner.broker.getvalue()

```

Steps:

Derive from 
Observer
 (and not from 
Indicator
)

Declare lines and params as needed (
Broker
 has 2 lines but no params)

There will be an automatic attribute 
_owner
 which is the strategy
    holding the observer

Observers come in action:

After all Indicators have been calculated

After the Strategy 
next
 method has been executed

That means: at the end of the cycle … they 
observe
 what has happened

In the 
Broker
 case it’s simply blindly recording the broker cash and
portfolio values at each point in time.

Adding Observers to the Strategy

As already pointed out above, 
Cerebro
 is using the 
stdstats
 parameter to
decide whether to add 3 default 
Observers
, alleviating the work of the end
user.

Adding other Observers to the mix is possible, be it along the 
stdstats
 or
removing those.

Let’s go for the usual strategy which buys when the 
close
 price goes above a

SimpleMovingAverage
 and sells if the opposite is true.

With one “addition”:

DrawDown
 which is an already existing observer in the 
backtrader

    ecosystem

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime
import os.path
import time
import sys

import backtrader as bt
import backtrader.feeds as btfeeds
import backtrader.indicators as btind

class MyStrategy(bt.Strategy):
    params = (('smaperiod', 15),)

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.data.datetime[0]
        if isinstance(dt, float):
            dt = bt.num2date(dt)
        print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # SimpleMovingAverage on main data
        # Equivalent to -> sma = btind.SMA(self.data, period=self.p.smaperiod)
        sma = btind.SMA(period=self.p.smaperiod)

        # CrossOver (1: up, -1: down) close / sma
        self.buysell = btind.CrossOver(self.data.close, sma, plot=True)

        # Sentinel to None: new ordersa allowed
        self.order = None

    def next(self):
        # Access -1, because drawdown[0] will be calculated after "next"
        self.log('DrawDown: %.2f' % self.stats.drawdown.drawdown[-1])
        self.log('MaxDrawDown: %.2f' % self.stats.drawdown.maxdrawdown[-1])

        # Check if we are in the market
        if self.position:
            if self.buysell < 0:
                self.log('SELL CREATE, %.2f' % self.data.close[0])
                self.sell()

        elif self.buysell > 0:
            self.log('BUY CREATE, %.2f' % self.data.close[0])
            self.buy()

def runstrat():
    cerebro = bt.Cerebro()

    data = bt.feeds.BacktraderCSVData(dataname='../../datas/2006-day-001.txt')
    cerebro.adddata(data)

    cerebro.addobserver(bt.observers.DrawDown)

    cerebro.addstrategy(MyStrategy)
    cerebro.run()

    cerebro.plot()

if __name__ == '__main__':
    runstrat()

```

The visual output shows the evolution of the drawdown

And part of the text output:

```
...
2006-12-14T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-15T23:59:59+00:00, DrawDown: 0.22
2006-12-15T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-18T23:59:59+00:00, DrawDown: 0.00
2006-12-18T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-19T23:59:59+00:00, DrawDown: 0.00
2006-12-19T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-20T23:59:59+00:00, DrawDown: 0.10
2006-12-20T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-21T23:59:59+00:00, DrawDown: 0.39
2006-12-21T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-22T23:59:59+00:00, DrawDown: 0.21
2006-12-22T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-27T23:59:59+00:00, DrawDown: 0.28
2006-12-27T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-28T23:59:59+00:00, DrawDown: 0.65
2006-12-28T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-29T23:59:59+00:00, DrawDown: 0.06
2006-12-29T23:59:59+00:00, MaxDrawDown: 2.62

```

Note

As seen in the text output and in the code, the 
DrawDown
 observer has
actually 2 lines:

drawdown

maxdrawdown

The choice is not to plot the 
maxdrawdown
 line, but make it is still
available to the user.

Actually the last value of 
maxdrawdown
 is also available in a direct
attribute (not a line) with the name of 
maxdd

Developing Observers

The implementation of the 
Broker
 observer was shown above. To produce a
meaningful observer, the implementation can use the following information:

self._owner
 is the currently strategy being executed

As such anything within the strategy is available to the observer

Default internal things available in the strategy which may be useful:

broker
 -> attribute giving access to the broker instance the strategy
  creates order against

As seen in 
Broker
, cash and portfolio values are collected by invoking
  the methods 
getcash
 and 
getvalue

_orderspending
 -> list orders created by the strategy and for which the
  broker has notified an event to the strategy.

The 
BuySell
 observer traverses the list looking for orders which have
  executed (totally or partially) to create an average execution price for
  the given point in time (index 0)

_tradespending
 -> list of trades (a set of completed buy/sell or
  sell/buy pairs) which is compiled from the buy/sell orders

An 
Observer
 can obviously access other observers over the

self._owner.stats
 path.

Custom 
OrderObserver

The standard 
BuySell
 observer does only care about operations which have
executed. We can create an observer which shows when orders where created and if
they expired.

For the sake of 
visibility
 the display will not be plotted along the price but
on a separate axis.

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import math

import backtrader as bt

class OrderObserver(bt.observer.Observer):
    lines = ('created', 'expired',)

    plotinfo = dict(plot=True, subplot=True, plotlinelabels=True)

    plotlines = dict(
        created=dict(marker='*', markersize=8.0, color='lime', fillstyle='full'),
        expired=dict(marker='s', markersize=8.0, color='red', fillstyle='full')
    )

    def next(self):
        for order in self._owner._orderspending:
            if order.data is not self.data:
                continue

            if not order.isbuy():
                continue

            # Only interested in "buy" orders, because the sell orders
            # in the strategy are Market orders and will be immediately
            # executed

            if order.status in [bt.Order.Accepted, bt.Order.Submitted]:
                self.lines.created[0] = order.created.price

            elif order.status in [bt.Order.Expired]:
                self.lines.expired[0] = order.created.price

```

The custom observer only cares about 
buy
 orders, because this is a strategy
which only buys to try to make a profit. Sell orders are Market orders and will
be executed immediately.

The Close-SMA CrossOver strategy is changed to:

Create a Limit order with a price below 1.0% the close price at the moment
    of the signal

A validity for the order of 7 (calendar) days

The resulting chart.

Several orders have expired as can be seen in the new subchart (red squares) and
we can also appreciate that between “creation” and “execution” several days
happen to be.

Finally the code for this strategy which applies the new 
observer

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime

import backtrader as bt
import backtrader.feeds as btfeeds
import backtrader.indicators as btind

from orderobserver import OrderObserver

class MyStrategy(bt.Strategy):
    params = (
        ('smaperiod', 15),
        ('limitperc', 1.0),
        ('valid', 7),
    )

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.data.datetime[0]
        if isinstance(dt, float):
            dt = bt.num2date(dt)
        print('%s, %s' % (dt.isoformat(), txt))

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            self.log('ORDER ACCEPTED/SUBMITTED', dt=order.created.dt)
            self.order = order
            return

        if order.status in [order.Expired]:
            self.log('BUY EXPIRED')

        elif order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    'BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

            else:  # Sell
                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

        # Sentinel to None: new orders allowed
        self.order = None

    def __init__(self):
        # SimpleMovingAverage on main data
        # Equivalent to -> sma = btind.SMA(self.data, period=self.p.smaperiod)
        sma = btind.SMA(period=self.p.smaperiod)

        # CrossOver (1: up, -1: down) close / sma
        self.buysell = btind.CrossOver(self.data.close, sma, plot=True)

        # Sentinel to None: new ordersa allowed
        self.order = None

    def next(self):
        if self.order:
            # pending order ... do nothing
            return

        # Check if we are in the market
        if self.position:
            if self.buysell < 0:
                self.log('SELL CREATE, %.2f' % self.data.close[0])
                self.sell()

        elif self.buysell > 0:
            plimit = self.data.close[0] * (1.0 - self.p.limitperc / 100.0)
            valid = self.data.datetime.date(0) + \
                datetime.timedelta(days=self.p.valid)
            self.log('BUY CREATE, %.2f' % plimit)
            self.buy(exectype=bt.Order.Limit, price=plimit, valid=valid)

def runstrat():
    cerebro = bt.Cerebro()

    data = bt.feeds.BacktraderCSVData(dataname='../../datas/2006-day-001.txt')
    cerebro.adddata(data)

    cerebro.addobserver(OrderObserver)

    cerebro.addstrategy(MyStrategy)
    cerebro.run()

    cerebro.plot()

if __name__ == '__main__':
    runstrat()

```

Saving/Keeping the statistics

As of now 
backtrader
 has not implemented any mechanism to track the values
of observers storing them into files. The best way to do it:

Open a file in the 
start
 method of the strategy

Write the values down in the 
next
 method of the strategy

Considering the 
DrawDown
 observer, it could be done like this

```
class MyStrategy(bt.Strategy):

    def start(self):

        self.mystats = open('mystats.csv', 'wb')
        self.mystats.write('datetime,drawdown, maxdrawdown\n')

    def next(self):
        self.mystats.write(self.data.datetime.date(0).strftime('%Y-%m-%d'))
        self.mystats.write(',%.2f' % self.stats.drawdown.drawdown[-1])
        self.mystats.write(',%.2f' % self.stats.drawdown.maxdrawdown-1])
        self.mystats.write('\n')

```

To save the values of index 0, once all observers have been processed a custom
observer which writes to a file could be added as the last observer to the
system to save values to a csv file.

Note

The Writer functionality can automate this task.
########################################
docu-observers-reference.txt - lunghezza: 6133
########################################
Observers Reference

Benchmark

class backtrader.observers.Benchmark()

This observer stores the 
returns
 of the strategy and the 
return
 of a
reference asset which is one of the datas passed to the system.

Params:

timeframe
 (default: 
None
)
    If 
None
 then the complete return over the entire backtested period
    will be reported

compression
 (default: 
None
)

Only used for sub-day timeframes to for example work on an hourly
timeframe by specifying “TimeFrame.Minutes” and 60 as compression

data
 (default: 
None
)

Reference asset to track to allow for comparison.

NOTE
: this data must have been added to a 
cerebro
 instance with

addata
, 
resampledata
 or 
replaydata
.

_doprenext
 (default: 
False
)

Benchmarking will take place from the point at which the strategy kicks
in (i.e.: when the minimum period of the strategy has been met).

Setting this to 
True
 will record benchmarking values from the
starting point of the data feeds

firstopen
 (default: 
False
)

Keepint it as 
False
 ensures that the 1
st
 comparison point between
the value and the benchmark starts at 0%, because the benchmark will
not use its opening price.

See the 
TimeReturn
 analyzer reference for a full explanation of the
meaning of the parameter

fund
 (default: 
None
)

If 
None
 the actual mode of the broker (fundmode - True/False) will
be autodetected to decide if the returns are based on the total net
asset value or on the fund value. See 
set_fundmode
 in the broker
documentation

Set it to 
True
 or 
False
 for a specific behavior

Remember that at any moment of a 
run
 the current values can be checked
by looking at the 
lines
 by name at index 
0
.

Broker

class backtrader.observers.Broker(*args, **kwargs)

This observer keeps track of the current cash amount and portfolio value in
the broker (including the cash)

Params: None

Broker - Cash

class backtrader.observers.Cash(*args, **kwargs)

This observer keeps track of the current amount of cash in the broker

Params: None

Broker - Value

class backtrader.observers.Value(*args, **kwargs)

This observer keeps track of the current portfolio value in the broker
including the cash

Params:

fund
 (default: 
None
)

If 
None
 the actual mode of the broker (fundmode - True/False) will
be autodetected to decide if the returns are based on the total net
asset value or on the fund value. See 
set_fundmode
 in the broker
documentation

Set it to 
True
 or 
False
 for a specific behavior

BuySell

class backtrader.observers.BuySell(*args, **kwargs)

This observer keeps track of the individual buy/sell orders (individual
executions) and will plot them on the chart along the data around the
execution price level

Params:

```
* `barplot` (default: `False`) Plot buy signals below the minimum and
  sell signals above the maximum.

  If `False` it will plot on the average price of executions during a
  bar

* `bardist` (default: `0.015` 1.5%) Distance to max/min when
  `barplot` is `True`

```

DrawDown

class backtrader.observers.DrawDown()

This observer keeps track of the current drawdown level (plotted) and
the maxdrawdown (not plotted) levels

Params:

fund
 (default: 
None
)

If 
None
 the actual mode of the broker (fundmode - True/False) will
be autodetected to decide if the returns are based on the total net
asset value or on the fund value. See 
set_fundmode
 in the broker
documentation

Set it to 
True
 or 
False
 for a specific behavior

TimeReturn

class backtrader.observers.TimeReturn()

This observer stores the 
returns
 of the strategy.

Params:

timeframe
 (default: 
None
)
    If 
None
 then the complete return over the entire backtested period
    will be reported

Pass 
TimeFrame.NoTimeFrame
 to consider the entire dataset with no
time constraints

compression
 (default: 
None
)

Only used for sub-day timeframes to for example work on an hourly
timeframe by specifying “TimeFrame.Minutes” and 60 as compression

fund
 (default: 
None
)

If 
None
 the actual mode of the broker (fundmode - True/False) will
be autodetected to decide if the returns are based on the total net
asset value or on the fund value. See 
set_fundmode
 in the broker
documentation

Set it to 
True
 or 
False
 for a specific behavior

Remember that at any moment of a 
run
 the current values can be checked
by looking at the 
lines
 by name at index 
0
.

Trades

class backtrader.observers.Trades()

This observer keeps track of full trades and plot the PnL level achieved
when a trade is closed.

A trade is open when a position goes from 0 (or crossing over 0) to X and
is then closed when it goes back to 0 (or crosses over 0 in the opposite
direction)

Params:

```
* `pnlcomm` (def: `True`)

  Show net/profit and loss, i.e.: after commission. If set to `False`
  if will show the result of trades before commission

```

LogReturns

class backtrader.observers.LogReturns()

This observer stores the 
log returns
 of the strategy or a

Params:

timeframe
 (default: 
None
)
    If 
None
 then the complete return over the entire backtested period
    will be reported

Pass 
TimeFrame.NoTimeFrame
 to consider the entire dataset with no
time constraints

compression
 (default: 
None
)

Only used for sub-day timeframes to for example work on an hourly
timeframe by specifying “TimeFrame.Minutes” and 60 as compression

fund
 (default: 
None
)

If 
None
 the actual mode of the broker (fundmode - True/False) will
be autodetected to decide if the returns are based on the total net
asset value or on the fund value. See 
set_fundmode
 in the broker
documentation

Set it to 
True
 or 
False
 for a specific behavior

Remember that at any moment of a 
run
 the current values can be checked
by looking at the 
lines
 by name at index 
0
.

LogReturns2

class backtrader.observers.LogReturns2()

Extends the observer LogReturns to show two instruments

FundValue

class backtrader.observers.FundValue(*args, **kwargs)

This observer keeps track of the current fund-like value

Params: None

FundShares

class backtrader.observers.FundShares(*args, **kwargs)

This observer keeps track of the current fund-like shares

Params: None
########################################
docu-operating.txt - lunghezza: 14852
########################################
Operating the platform

Line Iterators

To engage into operations, the plaftorm uses the notion of line
iterators. They have been loosely modeled after Python’s iterators but have
actually nothing to do with them.

Strategies and Indicators are line iterators.

The line iterator concept tries to describe the following:

A Line Iterator kicks slave line iterators telling them to iterate

A Line Iterator then iterates over its own declared named lines setting
    values

The key to iteration, just like with regular Python iterators, is:

The 
next
 method

It will be called for each iteration. The 
datas
 array which the 
line
iterator
 has and serve as basis for logic/calculations will have already
been moved to the next index by the platform (barring data replay)

Called when the 
minimum period
 for the line iterator has been met. A
bit more on this below.

But because they are not regular iterators, two additional methods exist:

prenext

Called before the 
minimum period
 for the line iterator` has been met.

nextstart

Called exactly 
ONCE
 when the 
minimum period
 for the line iterator`
has been met.

The default behavior is to forward the call to 
next
, but can of course
be overriden if needed.

Extra methods for 
Indicators

To speed up operations, Indicators support a batch operation mode which has
been termed as runonce. It is not strictly needed (a 
next
 method suffices)
but it greatly reduces time.

The runonce methods rules void the get/set point with index 0 and relies on
direct access to the underlying arrays holding the data and being passed the
right indices for each state.

The defined methods follow the naming of the next family:

once(self, start, end)

Called when the minimum period has been met. The internal array must be
processed between start and end which are zero based from the start of the
internal array

preonce(self, start, end)

Called before the minimum period has been met.

oncestart(self, start, end)

Called exactly 
ONCE
 when the minimum period has been met.

The default behavior is to forward the call to 
once
, but can of course
be overriden if needed.

Minimum Period

A picture is worth a thousand words and in this case possibly an example
too. A SimpleMovingAverage is capable of explaining it:

```
class SimpleMovingAverage(Indicator):
    lines = ('sma',)
    params = dict(period=20)

    def __init__(self):
        ...  # Not relevant for the explanation

    def prenext(self):
        print('prenext:: current period:', len(self))

    def nextstart(self):
        print('nextstart:: current period:', len(self))
        # emulate default behavior ... call next
        self.next()

    def next(self):
        print('next:: current period:', len(self))

```

And the instantiation could look like:

```
sma = btind.SimpleMovingAverage(self.data, period=25)

```

Briefly explained:

Assuming the data passed to the moving average is a standard data feed its
    default period is 
1
 that is: the data feed produces a bar with no
    initial delay.

Then the 
“period=25”
 instantiated moving average would have its methods
    called as follows:

prenext
 24 times

nextstart
 1 time (in turn calling 
next
)

next
 n additional times until the 
data feed
 has been exhausted

Let’s go for the killer indicator: 
a SimpleMovingAverage
 over another

SimpleMovingAverage
. The instantiation could look like:

```
sma1 = btind.SimpleMovingAverage(self.data, period=25)

sma2 = btind.SimpleMovingAverage(sma1, period=20)

```

What now goes on:

The same as above for 
sma1

sma2
 is receiving a 
data feed
 which has a 
minimum period
 of 25 which
    is our 
sma1
 and therefore

The 
sma2
 methods are called as indicated:

prenext
 the first 25 + 18 times for a total of 43 times

25 times to let 
sma1
 produce its 1
st
 sensible value

18 times to accumulate extra 
sma1
 values

For a total of 19 values (1 after 25 calls and then 18 more)

nextstart
 then 1 time (in turn calling 
next
)

next
 the n additional times until the 
data feed
 has been exhausted

The platform is calling 
next
 when the system has already processed 44 bars.

The 
minimum period
 has been automatically adjusted to the incoming data.

Strategies and Indicators adhere to this behavior:

Only when the automatically calculated minimum period has been reached will

next
 be called (barring the initial hook call to 
nextstart
)

Note

The same rules apply to 
preonce
, 
oncestart
 and 
once
 for
the 
runonce
 batch operation mode

Note

The 
minimum period
 behavior can be manipulated although it’s not
recommended. Should it be wished used the 
setminperiod(minperiod)

method in either Strategies or Indicators

Up and Running

Getting up and running involves at least 3 
Lines
 objects:

A Data feed

A Strategy (actually a class derived from Strategy)

A Cerebro (
brain
 in Spanish)

Data Feeds

These objects, obviously, provide the data which will be backtested by applying
calculations (direct and/or with Indicators)

The platform provides several data feeds:

Several CSV Format and a Generic CSV reader

Yahoo online fetcher

Support for receiving 
Pandas DataFrames
 and 
blaze
 objects

Live Data Feeds with 
Interacive Brokers
, 
Visual Chart
 and 
Oanda

The platform makes no assumption about the content of the data feed such as
timeframe and compression. Those values, together with a name, can be supplied
for informational purposes and advance operations like Data Feed Resampling
(turning a for example a 5 minute Data Feed into a Daily Data Feed)

Example of setting up a Yahoo Finance Data Feed:

```
import backtrader as bt
import backtrader.feeds as btfeeds

...

datapath = 'path/to/your/yahoo/data.csv'

data = btfeeds.YahooFinanceCSVData(
    dataname=datapath,
    reversed=True)

```

The optional 
reversed
 parameter for Yahoo is shown, because the CSV files
directly downloaded from Yahoo start with the latest date, rather than with the
oldest.

If your data spans a large time range, the actual loaded data can be limited as follows:

```
data = btfeeds.YahooFinanceCSVData(
    dataname=datapath,
    reversed=True
    fromdate=datetime.datetime(2014, 1, 1),
    todate=datetime.datetime(2014, 12, 31))

```

Both the 
fromdate
 and the 
todate
 will be included if present in the data
feed.

As already mentioned timeframe, compression and name can be added:

```
data = btfeeds.YahooFinanceCSVData(
    dataname=datapath,
    reversed=True
    fromdate=datetime.datetime(2014, 1, 1),
    todate=datetime.datetime(2014, 12, 31)
    timeframe=bt.TimeFrame.Days,
    compression=1,
    name='Yahoo'
   )

```

If the data is plotted, those values will be used.

A Strategy (derived) class

Note

Before going on and for a more simplified approach, please check the

Signals
 section of the documentation if subclassing a strategy is
not wished.

The goal of anyone using the platform is backtesting the data and this is done
inside a Strategy (derived class).

There are 2 methods which at least need customization:

__init__

next

During initialization indicators on data and other calculations are created
prepared to later apply the logic.

The next method is later called to apply the logic for each and every bar of the
data.

Note

If data feeds of different timeframes (and thus different bar counts)
are passed the 
next
 method will be called for the master data
(the 1
st
 one passed to cerebro, see below) which must be the the data
with the smaller timeframe

Note

If the Data Replay functionality is used, the 
next
 method will be
called several time for the same bar as the development of the bar is
replayed.

A basic Strategy derived class:

```
class MyStrategy(bt.Strategy):

    def __init__(self):

        self.sma = btind.SimpleMovingAverage(self.data, period=20)

    def next(self):

        if self.sma > self.data.close:
            self.buy()

        elif self.sma < self.data.close:
            self.sell()

```

Strategies have other methods (or hook points) which can be overriden:

```
class MyStrategy(bt.Strategy):

    def __init__(self):

        self.sma = btind.SimpleMovingAverage(self.data, period=20)

    def next(self):

        if self.sma > self.data.close:
            submitted_order = self.buy()

        elif self.sma < self.data.close:
            submitted_order = self.sell()

    def start(self):
        print('Backtesting is about to start')

    def stop(self):
        print('Backtesting is finished')

    def notify_order(self, order):
        print('An order new/changed/executed/canceled has been received')

```

The 
start
 and 
stop
 methods should be self-explanatory. As expected and
following the text in the print function, the 
notify_order
 method will be
called when the strategy needs a notification. Use case:

A buy or sell is requested (as seen in next)

buy/sell will return an 
order
 which is submitted to the broker. Keeping a
reference to this submitted order is up to the caller.

It can for example be used to ensure that no new orders are submitted if an
order is still pending.

If the order is Accepted/Executed/Canceled/Changed the broker will notify
    the status change (and for example execution size) back to the strategy via
    the notify method

The QuickStart guide has a complete and functional example of order management
in the 
notify_order
 method.

More can be done with other Strategy classes:

buy
 / 
sell
 / 
close

Use the underlying 
broker
 and 
sizer
 to send the broker a buy/sell
order

The same could be done by manually creating an Order and passing it over to
the broker. But the platform is about making it easy for those using it.

close
 will get the current market position and close it immediately.

getposition
 (or the property “position”)

Returns the current market position

setsizer
/
getsizer
 (or the property “sizer”)

These allow setting/getting the underlying stake Sizer. The same logic can
be checked against Sizers which provide different stakes for the same
situation (fixed size, proportional to capital, exponential)

There is plenty of literature but Van K. Tharp has excellent books on the
subject.

A Strategy is a 
Lines
 object and these support parameters, which are collected
using the standard Python kwargs argument:

```
class MyStrategy(bt.Strategy):

    params = (('period', 20),)

    def __init__(self):

        self.sma = btind.SimpleMovingAverage(self.data, period=self.params.period)

    ...
    ...

```

Notice how the 
SimpleMovingAverage
 is no longer instantiated with a fixed
value of 20, but rather with the parameter “period” which has been defined for
the strategy.

A Cerebro

Once Data Feeds are available and the Strategy has been defined, a Cerebro
instance is what brings everything together and execute the
actions. Instantiating one is easy:

```
cerebro = bt.Cerebro()

```

Defaults are taking care of if nothing special is wished.

A default broker is created

No commission for the operations

Data Feeds will be preloaded

The default execution mode will be runonce (batch operation) which is the
    faster

All indicators must support the 
runonce
 mode for full speed. The ones
included in the platform do.

Custom indicators do not need to implement the runonce
functionality. 
Cerebro
 will simulate it, which means those non-runonce
compatible indicators will run slower. But still most of the system will
run in batch mode.

Since a Data feed is already available and a Strategy too (created earlier) the
standard way to put it all together and get it up and running is:

```
cerebro.adddata(data)
cerebro.addstrategy(MyStrategy, period=25)
cerebro.run()

```

Notice the following:

The Data Feed “instance” is added

The MyStrategy “class” is added along with parameters (kwargs) that will be
    passed to it.

The instantiation of MyStrategy will be done by cerebro in the background
and any kwargs in “addstrategy” will be passed to it

The user may add as many Strategies and Data Feeds as wished. How Strategies
communicate with each other to achieve coordination (if wished be) is not
enforced/restricted by the platform.

Of course a Cerebro offers additional possibilities:

Decide about preloading and operation mode:

```
cerebro = bt.Cerebro(runonce=True, preload=True)

```

There is a constraint here: 
runonce
 needs preloading (if not, a batch
operation cannot be run) Of course preloading Data Feeds does not enforce

runonce

setbroker
 / 
getbroker
 (and the 
broker
 property)

A custom broker can be set if wished. The actual broker instance can also be
accesed

Plotting. In a regular case as easy as:

```
cerebro.run()
cerebro.plot()

```

plot takes some arguments for the customization

numfigs=1

If the plot is too dense it may be broken down into several plots

plotter=None

A customer plotter instance can be passed and cerebro will not
instantiate a default one

**kwargs
 - standard keyword arguments

Which will get passed to the plotter.

Please see the plotting section for more information.

Optimization of strategies.

As mentioned above, Cerebro gets a Strategy derived class (not an instance)
and the keyword arguments that will be passed to it upon instantiation,
which will happen when “run” is called.

This is so to enable optimization. The same Strategy class will be
instantiated as many times as needed with new parameters. If an instance had
been passed to cerebro … this would not be possible.

Optimization is requested as follows:

```
cerebro.optstrategy(MyStrategy, period=xrange(10, 20))

```

The method 
optstrategy
 has the same signature as 
addstrategy
 but
does extra housekeeping to ensure optimization runs as expected. A strategy
could be expecting a 
range
 as a normal parameter for a strategy and

addstrategy
 will make no assumptions about the passed parameter.

On the other hand, 
optstrategy
 will understand that an iterable is a set
of values that has to be passed in sequence to each instantiation of the
Strategy class.

Notice that instead of a single value a 
range
 of values is passed. In this
simple case 10 values 10 -> 19 (20 is the upper limit) will be tried for
this strategy.

If a more complex strategy is developed with extra parameters they can all
be passed to 
optstrategy
. Parameters which must not undergo optimization
can be passed directly without the end user having to create a dummy
iterable of just one value. Example:

```
cerebro.optstrategy(MyStrategy, period=xrange(10, 20), factor=3.5)

```

The 
optstrategy
 method sees factor and creates (a needed) dummy iterable
in the background for factor which has a single element (in the example 3.5)

Note

Interactive Python shells and some types of frozen executables
under 
Windows
 have problems with the Python 
multiprocessing
 module

Please read the Python documentation about 
multiprocessing
.
########################################
docu-optimization-improvements.txt - lunghezza: 7527
########################################
Optimization improvements

Version 
1.8.12.99
 of 
backtrader
 includes an improvement in how

data feeds
 and 
results
 are managed during multiprocessing.

Note

The behavior for both has been made

The behavior of these options can be controlled through two new 
Cerebro

parameters:

optdatas
 (default: 
True
)

If 
True
 and optimizing (and the system can 
preload
 and use

runonce
, data preloading will be done only once in the main process
to save time and resources.

optreturn
 (default: 
True
)

If 
True
 the optimization results will not be full 
Strategy

objects (and all 
datas
, 
indicators
, 
observers
 …) but and object
with the following attributes (same as in 
Strategy
):

params
 (or 
p
) the strategy had for the execution

analyzers
 the strategy has executed

In most occassions, only the 
analyzers
 and with which 
params
 are
the things needed to evaluate a the performance of a strategy. If
detailed analysis of the generated values for (for example)

indicators
 is needed, turn this off

Data Feed Management

In a 
Optimization
 scenario this is a likely combination of 
Cerebro

parameters:

preload=True
 (default)

Data Feeeds will be preloaded before running any backtesting code

runonce=True
 (default)

Indicators
 will be calculated in batch mode a tight 
for
 loop, instead
of step by step.

If both conditions are 
True
 and 
optdatas=True
, then:

The 
Data Feeds
 will be preloaded in the main process before spawning new
    subprocesses (the ones in charge of executing the 
backtesting
)

Results management

In a 
Optimization
 scenario two things should play the most important role
when evaluating the different parameters with which each 
Strategy
 was run:

strategy.params
 (or 
strategy.p
)

The actual set of values used for the backtesting

strategy.analyzers

The objects in charge of providing the evaluation of how the 
Strategy

has actually performed. Example:

SharpeRatio_A
 (the annualized 
SharpeRatio
)

When 
optreturn=True
, instead of returning full 
strategy
 instances,
placeholder objects will be created which carry the two attributes
aforementioned to let the evaluation take place.

This avoids passing back lots of generated data like for example the values
generated by indicators during the 
backtesting

Should the 
full strategy objects
 be wished, simply set 
optreturn=False

during cerebro 
instantiation
 or when doing 
cerebro.run
.

Some test runs

The 
optimization
 sample in the 
backtrader
 sources has been extended to add
control for 
optdatas
 and 
optreturn
 (actually to disable them)

Single Core Run

As a reference what happens when the amount of CPUs is limited to 
1
 and the

multiprocessing
 module is not used:

```
$ ./optimization.py --maxcpus 1
==================================================
**************************************************
--------------------------------------------------
OrderedDict([(u'smaperiod', 10), (u'macdperiod1', 12), (u'macdperiod2', 26), (u'macdperiod3', 9)])
**************************************************
--------------------------------------------------
OrderedDict([(u'smaperiod', 10), (u'macdperiod1', 13), (u'macdperiod2', 26), (u'macdperiod3', 9)])
...
...
OrderedDict([(u'smaperiod', 29), (u'macdperiod1', 19), (u'macdperiod2', 29), (u'macdperiod3', 14)])
==================================================
Time used: 184.922727833

```

Multiple Core Runs

Without limiting the number of CPUs, the Python 
multiprocessing
 module will
try to use all of them. 
optdatas
 and 
optreturn
 will be disabled

Both 
optdata
 and 
optreturn
 active

The default behavior:

```
$ ./optimization.py
...
...
...
==================================================
Time used: 56.5889185394

```

The total improvement by having multicore and the 
data feed
 and 
results

improvements means going down from 
184.92
 to 
56.58
 seconds.

Take into account that the sample is using 
252
 bars and the indicators
generate only values with a length of 
252
 points. This is just an example.

The real question is how much of this is attributable to the new behavior.

optreturn
 deactivated

Let’s pass full 
strategy
 objects back to the caller:

```
$ ./optimization.py --no-optreturn
...
...
...
==================================================
Time used: 67.056914007

```

The execution time has increased 
18.50%
 (or a speed-up of 
15.62%
) is in
place.

optdatas
 deactivated

Each subproccess is forced to load its own set of values for the 
data feeds
:

```
$ ./optimization.py --no-optdatas
...
...
...
==================================================
Time used: 72.7238112637

```

The execution time has increased 
28.52%
 (or a speed-up of 
22.19%
) is in
place.

Both deactivated

Still using multicore but with the old non-improved behavior:

```
$ ./optimization.py --no-optdatas --no-optreturn
...
...
...
==================================================
Time used: 83.6246643786

```

The execution time has increased 
47.79%
 (or a speed-up of 
32.34%
) is in
place.

This shows that the used of multiple cores is the major contributor to the time
improvement.

Note

The executions have been done in a Laptop with a 
i7-4710HQ
 (4-core / 8
logical) with 16 GBytes of RAM under Windows 10 64bit. The mileage may vary
under other conditions

Concluding

The greatest factor in time reduction during optimization is the use of the
    multiple cores

The sample runs with 
optdatas
 and 
optreturn
 show speed-ups of
    around 
22.19%
 and 
15.62%
 each (
32.34%
 both together in the test)

Sample Usage

```
$ ./optimization.py --help
usage: optimization.py [-h] [--data DATA] [--fromdate FROMDATE]
                       [--todate TODATE] [--maxcpus MAXCPUS] [--no-runonce]
                       [--exactbars EXACTBARS] [--no-optdatas]
                       [--no-optreturn] [--ma_low MA_LOW] [--ma_high MA_HIGH]
                       [--m1_low M1_LOW] [--m1_high M1_HIGH] [--m2_low M2_LOW]
                       [--m2_high M2_HIGH] [--m3_low M3_LOW]
                       [--m3_high M3_HIGH]

Optimization

optional arguments:
  -h, --help            show this help message and exit
  --data DATA, -d DATA  data to add to the system
  --fromdate FROMDATE, -f FROMDATE
                        Starting date in YYYY-MM-DD format
  --todate TODATE, -t TODATE
                        Starting date in YYYY-MM-DD format
  --maxcpus MAXCPUS, -m MAXCPUS
                        Number of CPUs to use in the optimization
                          - 0 (default): use all available CPUs
                          - 1 -> n: use as many as specified
  --no-runonce          Run in next mode
  --exactbars EXACTBARS
                        Use the specified exactbars still compatible with preload
                          0 No memory savings
                          -1 Moderate memory savings
                          -2 Less moderate memory savings
  --no-optdatas         Do not optimize data preloading in optimization
  --no-optreturn        Do not optimize the returned values to save time
  --ma_low MA_LOW       SMA range low to optimize
  --ma_high MA_HIGH     SMA range high to optimize
  --m1_low M1_LOW       MACD Fast MA range low to optimize
  --m1_high M1_HIGH     MACD Fast MA range high to optimize
  --m2_low M2_LOW       MACD Slow MA range low to optimize
  --m2_high M2_HIGH     MACD Slow MA range high to optimize
  --m3_low M3_LOW       MACD Signal range low to optimize
  --m3_high M3_HIGH     MACD Signal range high to optimize

```
