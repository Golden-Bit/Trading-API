########################################
docu-order-creation-execution-order-creation-execution.txt - lunghezza: 29493
########################################
Order Management and Execution

Backtesting, and hence 
backtrader
, would not be complete if orders could not
be simulated. To do so, the following is available in the platform.

For order management 3 primitives:

buy

sell

cancel

Note

An 
update
 primitive is obviously something logic but common sense
dictates that such a method is mostly used by manual operators working with
a judgmental trading approach.

For order execution logic the following execution types:

Market

Close

Limit

Stop

StopLimit

Order Management

Some examples:

```
# buy the main date, with sizer default stake, Market order
order = self.buy()

# Market order - valid will be "IGNORED"
order = self.buy(valid=datetime.datetime.now() + datetime.timedelta(days=3))

# Market order - price will be IGNORED
order = self.buy(price=self.data.close[0] * 1.02)

# Market order - manual stake
order = self.buy(size=25)

# Limit order - want to set the price and can set a validity
order = self.buy(exectype=Order.Limit,
                 price=self.data.close[0] * 1.02,
                 valid=datetime.datetime.now() + datetime.timedelta(days=3)))

# StopLimit order - want to set the price, price limit
order = self.buy(exectype=Order.StopLimit,
                 price=self.data.close[0] * 1.02,
                 plimit=self.data.close[0] * 1.07)

# Canceling an existing order
self.broker.cancel(order)

```

Note

All order types can be create by creating an 
Order
 instance (or one of
its subclasses) and then passed to to the broker with:

```
order = self.broker.submit(order)

```

Note

There are 
buy
 and 
sell
 primitives in the 
broker
 itself, but they
are less forgiving with regards to default parameters.

Order Execution Logic

The 
broker
 uses 2 main guidelines (assumptions?) for order execution.

The current data has already happened and cannot be used to execcute an
    order.

If the logic in the strategy is something like:

```
 if self.data.close > self.sma:  # where sma is a Simple Moving Average
     self.buy()

```

The expectation CANNOT be that the order will be executed with the

close
 price which is being examined in the logic BECAUSE it has already
happened.

The order CAN BE 1
st
 EXECUTED withing the bounds of the next set of
Open/High/Low/Close price points (and the conditions set forth herein by
the order)

Volume does not play a role

It actually does in real trading if the trader goes for non-liquid assets or
precisely the extremes (high/low) of a price bar are hit.

But hitting the high/low points is a seldom occurrence (if you do … you
don’t need 
backtrader
) and the chosen assets will have enough liquidity
to absorb the orders of any regular trading

Market

Execution:

Opening price of the next set of Open/High/Low/Close prices (commonly
    referred as 
bar
)

Rationale:

If the logic has executed at point X in time and issued a 
Market
 order,
    the next price spot that will happen is the upcoming 
open
 price

Note

This order executes always and disregards any 
price
 and 
valid

parameters used to create it

Close

Execution:

Using the 
close
 price of the next barwhen the next bar actually CLOSES

Rationale:

Most 
backtesting
 feeds contain already 
closed
 bars and the order
    will execute immediately with the 
close
 price of the next bar. A daily
    data feed is the most common example.

But the system could be fed with “tick” prices and the actual bar
(time/date wise) is being udpated constantly with the new ticks, without
actually moving to the 
next
 bar (because time and/or date have not
changed)

Only when the time or date changes, the bar has actually been closed and
the order gets executed

Limit

Execution:

The 
price
 set at order creation if the 
data
 touches it, starting
    with the next price bar.

The order will be canceled if 
valid
 is set and the time point is
reached

Price Matching:

backtrader
 tries to provide 
most realistic execution price
 for

Limit
 orders.

Using the 4 price spots (Open/High/Low/Close) it can be partially inferred
if the requested 
price
 can be improved.

For 
Buy
 Orders

Case 1:

If the 
open
 price of the bar is below the limit price the order
executes immediately with the 
open
 price. The order has been swept
during the opening phase of the session

Case 2:

If the 
open
 price has not penetrated below the limit price but the

low
 price is below the limit price, then the limit price has been
seen during the session and the order can be executed

The logic is obviously inverted for 
Sell
 orders.

Stop

Execution:

The trigger 
price
 set at order creation if the 
data
 touches it,
    starting with the next price bar.

The order will be canceled if 
valid
 is set and the time point is reached

Price Matching:

backtrader
 tries to provide 
most realistic trigger price
 for

Stop
 orders.

Using the 4 price spots (Open/High/Low/Close) it can be partially inferred
if the requested 
price
 can be improved.

For 
\
Stop
orders which
Buy`

Case 1:

If the 
open
 price of the bar is above the stop price the order is
executed immediately with the 
open
 price.

Intended to stop a loss if the price is moving upwards against an
existing short position

Case 2:

If the 
open
 price has not penetrated above the stop price but the

high
 price is above the stop price, then the stop price has been
seen during the session and the order can be executed

The logic is obviously inverted for 
Stop
 orders which 
Sell
.

StopLimit

Execution:

The trigger 
price
 sets the order in motion starting with the next
    price bar.

Price Matching:

Trigger
: Uses the 
Stop
 matching logic (but only triggers and turns
    the order into a 
Limit
 order)

Limit
: Uses the 
Limit
 price matching logic

Some samples

As always pictures (with code) are worth several million long explanations.
Please note that the snippets concentrate on the order creation part. The full
code is at the bottom.

A 
price closes above/below a simple moving average
 strategy will be used for
the generation of the buy/sell signals

The signal is seen at the bottom of the charts: the 
CrossOver
 using the
crossover indicator.

A reference to generated “buy” orders will be kept to only allow one
simultaneous order at most in the system.

Execution Type: Market

See in the chart how how the orders are executed one bar after the signal is
generated with the opening price.

```
            if self.p.exectype == 'Market':
                self.buy(exectype=bt.Order.Market)  # default if not given

                self.log('BUY CREATE, exectype Market, price %.2f' %
                         self.data.close[0])

```

The output chart.

The command line and output:

```
$ ./order-execution-samples.py --exectype Market
2006-01-26T23:59:59+00:00, BUY CREATE, exectype Market, price 3641.42
2006-01-26T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-01-27T23:59:59+00:00, BUY EXECUTED, Price: 3643.35, Cost: 3643.35, Comm 0.00
2006-03-02T23:59:59+00:00, SELL CREATE, 3763.73
2006-03-02T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-03-03T23:59:59+00:00, SELL EXECUTED, Price: 3763.95, Cost: 3763.95, Comm 0.00
...
...
2006-12-11T23:59:59+00:00, BUY CREATE, exectype Market, price 4052.89
2006-12-11T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-12-12T23:59:59+00:00, BUY EXECUTED, Price: 4052.55, Cost: 4052.55, Comm 0.00

```

Execution Type: Close

Now the orders are also executed one bar after the signal but with the closing
price.

```
            elif self.p.exectype == 'Close':
                self.buy(exectype=bt.Order.Close)

                self.log('BUY CREATE, exectype Close, price %.2f' %
                         self.data.close[0])

```

The output chart.

The command line and output:

```
$ ./order-execution-samples.py --exectype Close
2006-01-26T23:59:59+00:00, BUY CREATE, exectype Close, price 3641.42
2006-01-26T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-01-27T23:59:59+00:00, BUY EXECUTED, Price: 3685.48, Cost: 3685.48, Comm 0.00
2006-03-02T23:59:59+00:00, SELL CREATE, 3763.73
2006-03-02T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-03-03T23:59:59+00:00, SELL EXECUTED, Price: 3763.95, Cost: 3763.95, Comm 0.00
...
...
2006-11-06T23:59:59+00:00, BUY CREATE, exectype Close, price 4045.22
2006-11-06T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-11-07T23:59:59+00:00, BUY EXECUTED, Price: 4072.86, Cost: 4072.86, Comm 0.00
2006-11-24T23:59:59+00:00, SELL CREATE, 4048.16
2006-11-24T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-11-27T23:59:59+00:00, SELL EXECUTED, Price: 4045.05, Cost: 4045.05, Comm 0.00
2006-12-11T23:59:59+00:00, BUY CREATE, exectype Close, price 4052.89
2006-12-11T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-12-12T23:59:59+00:00, BUY EXECUTED, Price: 4059.74, Cost: 4059.74, Comm 0.00

```

Execution Type: Limit

Validity is being calculated some lines before in case it has been passed as
argument.

```
            if self.p.valid:
                valid = self.data.datetime.date(0) + \
                        datetime.timedelta(days=self.p.valid)
            else:
                valid = None

```

A limit price 1% below the signal generation price (the close at the signal
bar) is set. Notice how this prevents many from the orders above from being executed.

```
            elif self.p.exectype == 'Limit':
                price = self.data.close * (1.0 - self.p.perc1 / 100.0)

                self.buy(exectype=bt.Order.Limit, price=price, valid=valid)

                if self.p.valid:
                    txt = 'BUY CREATE, exectype Limit, price %.2f, valid: %s'
                    self.log(txt % (price, valid.strftime('%Y-%m-%d')))
                else:
                    txt = 'BUY CREATE, exectype Limit, price %.2f'
                    self.log(txt % price)

```

The output chart.

Just 4 orders have been issued. Limiting the price trying to catch a small dip
has completly changed the output.

The command line and output:

```
$ ./order-execution-samples.py --exectype Limit --perc1 1
2006-01-26T23:59:59+00:00, BUY CREATE, exectype Limit, price 3605.01
2006-01-26T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-05-18T23:59:59+00:00, BUY EXECUTED, Price: 3605.01, Cost: 3605.01, Comm 0.00
2006-06-05T23:59:59+00:00, SELL CREATE, 3604.33
2006-06-05T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-06-06T23:59:59+00:00, SELL EXECUTED, Price: 3598.58, Cost: 3598.58, Comm 0.00
2006-06-21T23:59:59+00:00, BUY CREATE, exectype Limit, price 3491.57
2006-06-21T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-06-28T23:59:59+00:00, BUY EXECUTED, Price: 3491.57, Cost: 3491.57, Comm 0.00
2006-07-13T23:59:59+00:00, SELL CREATE, 3562.56
2006-07-13T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-07-14T23:59:59+00:00, SELL EXECUTED, Price: 3545.92, Cost: 3545.92, Comm 0.00
2006-07-24T23:59:59+00:00, BUY CREATE, exectype Limit, price 3596.60
2006-07-24T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED

```

Execution Type: Limit with validity

To not wait forever on a limit order which may only execute when the price is
moving against the “buy” order, the order will only be valid 4 (calendar) days.

The output chart.

More orders have been generated, but all but one “buy” order expired, further
limiting the amount of operations.

The command line and output:

```
$ ./order-execution-samples.py --exectype Limit --perc1 1 --valid 4
2006-01-26T23:59:59+00:00, BUY CREATE, exectype Limit, price 3605.01, valid: 2006-01-30
2006-01-26T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-01-30T23:59:59+00:00, BUY EXPIRED
2006-03-10T23:59:59+00:00, BUY CREATE, exectype Limit, price 3760.48, valid: 2006-03-14
2006-03-10T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-03-14T23:59:59+00:00, BUY EXPIRED
2006-03-30T23:59:59+00:00, BUY CREATE, exectype Limit, price 3835.86, valid: 2006-04-03
2006-03-30T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-04-03T23:59:59+00:00, BUY EXPIRED
2006-04-20T23:59:59+00:00, BUY CREATE, exectype Limit, price 3821.40, valid: 2006-04-24
2006-04-20T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-04-24T23:59:59+00:00, BUY EXPIRED
2006-05-04T23:59:59+00:00, BUY CREATE, exectype Limit, price 3804.65, valid: 2006-05-08
2006-05-04T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-05-08T23:59:59+00:00, BUY EXPIRED
2006-06-01T23:59:59+00:00, BUY CREATE, exectype Limit, price 3611.85, valid: 2006-06-05
2006-06-01T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-06-05T23:59:59+00:00, BUY EXPIRED
2006-06-21T23:59:59+00:00, BUY CREATE, exectype Limit, price 3491.57, valid: 2006-06-25
2006-06-21T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-06-26T23:59:59+00:00, BUY EXPIRED
2006-07-24T23:59:59+00:00, BUY CREATE, exectype Limit, price 3596.60, valid: 2006-07-28
2006-07-24T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-07-28T23:59:59+00:00, BUY EXPIRED
2006-09-12T23:59:59+00:00, BUY CREATE, exectype Limit, price 3751.07, valid: 2006-09-16
2006-09-12T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-09-18T23:59:59+00:00, BUY EXPIRED
2006-09-20T23:59:59+00:00, BUY CREATE, exectype Limit, price 3802.90, valid: 2006-09-24
2006-09-20T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-09-22T23:59:59+00:00, BUY EXECUTED, Price: 3802.90, Cost: 3802.90, Comm 0.00
2006-11-02T23:59:59+00:00, SELL CREATE, 3974.62
2006-11-02T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-11-03T23:59:59+00:00, SELL EXECUTED, Price: 3979.73, Cost: 3979.73, Comm 0.00
2006-11-06T23:59:59+00:00, BUY CREATE, exectype Limit, price 4004.77, valid: 2006-11-10
2006-11-06T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-11-10T23:59:59+00:00, BUY EXPIRED
2006-12-11T23:59:59+00:00, BUY CREATE, exectype Limit, price 4012.36, valid: 2006-12-15
2006-12-11T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-12-15T23:59:59+00:00, BUY EXPIRED

```

Execution Type: Stop

A stop price 1% above the signal price is set. That means that the strategy only
buys if the signal is generated and the price continues climbing up, which could
be intrepreted as a signal of strength.

This completely alters the execution panorama.

```
            elif self.p.exectype == 'Stop':
                price = self.data.close * (1.0 + self.p.perc1 / 100.0)

                self.buy(exectype=bt.Order.Stop, price=price, valid=valid)

                if self.p.valid:
                    txt = 'BUY CREATE, exectype Stop, price %.2f, valid: %s'
                    self.log(txt % (price, valid.strftime('%Y-%m-%d')))
                else:
                    txt = 'BUY CREATE, exectype Stop, price %.2f'
                    self.log(txt % price)

```

The output chart.

The command line and output:

```
$ ./order-execution-samples.py --exectype Stop --perc1 1
2006-01-26T23:59:59+00:00, BUY CREATE, exectype Stop, price 3677.83
2006-01-26T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-01-27T23:59:59+00:00, BUY EXECUTED, Price: 3677.83, Cost: 3677.83, Comm 0.00
2006-03-02T23:59:59+00:00, SELL CREATE, 3763.73
2006-03-02T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-03-03T23:59:59+00:00, SELL EXECUTED, Price: 3763.95, Cost: 3763.95, Comm 0.00
2006-03-10T23:59:59+00:00, BUY CREATE, exectype Stop, price 3836.44
2006-03-10T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-03-15T23:59:59+00:00, BUY EXECUTED, Price: 3836.44, Cost: 3836.44, Comm 0.00
2006-03-28T23:59:59+00:00, SELL CREATE, 3811.45
2006-03-28T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-03-29T23:59:59+00:00, SELL EXECUTED, Price: 3811.85, Cost: 3811.85, Comm 0.00
2006-03-30T23:59:59+00:00, BUY CREATE, exectype Stop, price 3913.36
2006-03-30T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-09-29T23:59:59+00:00, BUY EXECUTED, Price: 3913.36, Cost: 3913.36, Comm 0.00
2006-11-02T23:59:59+00:00, SELL CREATE, 3974.62
2006-11-02T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-11-03T23:59:59+00:00, SELL EXECUTED, Price: 3979.73, Cost: 3979.73, Comm 0.00
2006-11-06T23:59:59+00:00, BUY CREATE, exectype Stop, price 4085.67
2006-11-06T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-11-13T23:59:59+00:00, BUY EXECUTED, Price: 4085.67, Cost: 4085.67, Comm 0.00
2006-11-24T23:59:59+00:00, SELL CREATE, 4048.16
2006-11-24T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-11-27T23:59:59+00:00, SELL EXECUTED, Price: 4045.05, Cost: 4045.05, Comm 0.00
2006-12-11T23:59:59+00:00, BUY CREATE, exectype Stop, price 4093.42
2006-12-11T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-12-13T23:59:59+00:00, BUY EXECUTED, Price: 4093.42, Cost: 4093.42, Comm 0.00

```

Execution Type: StopLimit

A stop price 1% above the signal price is set. But the limit price is set 0.5%
above the signal (close) price which could be interpreted as: wait for the
strength to show up but do not buy the peak. Wait for a dip.

Validity is capped at 20 (calendar) days

```
            elif self.p.exectype == 'StopLimit':
                price = self.data.close * (1.0 + self.p.perc1 / 100.0)

                plimit = self.data.close * (1.0 + self.p.perc2 / 100.0)

                self.buy(exectype=bt.Order.StopLimit, price=price, valid=valid,
                         plimit=plimit)

                if self.p.valid:
                    txt = ('BUY CREATE, exectype StopLimit, price %.2f,'
                           ' valid: %s, pricelimit: %.2f')
                    self.log(txt % (price, valid.strftime('%Y-%m-%d'), plimit))
                else:
                    txt = ('BUY CREATE, exectype StopLimit, price %.2f,'
                           ' pricelimit: %.2f')
                    self.log(txt % (price, plimit))

```

The output chart.

The command line and output:

```
$ ./order-execution-samples.py --exectype StopLimit --perc1 1 --perc2 0.5 --valid 20
2006-01-26T23:59:59+00:00, BUY CREATE, exectype StopLimit, price 3677.83, valid: 2006-02-15, pricelimit: 3659.63
2006-01-26T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-02-03T23:59:59+00:00, BUY EXECUTED, Price: 3659.63, Cost: 3659.63, Comm 0.00
2006-03-02T23:59:59+00:00, SELL CREATE, 3763.73
2006-03-02T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-03-03T23:59:59+00:00, SELL EXECUTED, Price: 3763.95, Cost: 3763.95, Comm 0.00
2006-03-10T23:59:59+00:00, BUY CREATE, exectype StopLimit, price 3836.44, valid: 2006-03-30, pricelimit: 3817.45
2006-03-10T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-03-21T23:59:59+00:00, BUY EXECUTED, Price: 3817.45, Cost: 3817.45, Comm 0.00
2006-03-28T23:59:59+00:00, SELL CREATE, 3811.45
2006-03-28T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-03-29T23:59:59+00:00, SELL EXECUTED, Price: 3811.85, Cost: 3811.85, Comm 0.00
2006-03-30T23:59:59+00:00, BUY CREATE, exectype StopLimit, price 3913.36, valid: 2006-04-19, pricelimit: 3893.98
2006-03-30T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-04-19T23:59:59+00:00, BUY EXPIRED
...
...
2006-12-11T23:59:59+00:00, BUY CREATE, exectype StopLimit, price 4093.42, valid: 2006-12-31, pricelimit: 4073.15
2006-12-11T23:59:59+00:00, ORDER ACCEPTED/SUBMITTED
2006-12-22T23:59:59+00:00, BUY EXECUTED, Price: 4073.15, Cost: 4073.15, Comm 0.00

```

Test Script Execution

Detailed in the command line 
help
:

```
$ ./order-execution-samples.py --help
usage: order-execution-samples.py [-h] [--infile INFILE]
                                  [--csvformat {bt,visualchart,sierrachart,yahoo,yahoo_unreversed}]
                                  [--fromdate FROMDATE] [--todate TODATE]
                                  [--plot] [--plotstyle {bar,line,candle}]
                                  [--numfigs NUMFIGS] [--smaperiod SMAPERIOD]
                                  [--exectype EXECTYPE] [--valid VALID]
                                  [--perc1 PERC1] [--perc2 PERC2]

Showcase for Order Execution Types

optional arguments:
  -h, --help            show this help message and exit
  --infile INFILE, -i INFILE
                        File to be read in
  --csvformat {bt,visualchart,sierrachart,yahoo,yahoo_unreversed},
  -c {bt,visualchart,sierrachart,yahoo,yahoo_unreversed}
                        CSV Format
  --fromdate FROMDATE, -f FROMDATE
                        Starting date in YYYY-MM-DD format
  --todate TODATE, -t TODATE
                        Ending date in YYYY-MM-DD format
  --plot, -p            Plot the read data
  --plotstyle {bar,line,candle}, -ps {bar,line,candle}
                        Plot the read data
  --numfigs NUMFIGS, -n NUMFIGS
                        Plot using n figures
  --smaperiod SMAPERIOD, -s SMAPERIOD
                      Simple Moving Average Period
  --exectype EXECTYPE, -e EXECTYPE
                        Execution Type: Market (default), Close, Limit,
                        Stop, StopLimit
  --valid VALID, -v VALID
                        Validity for Limit sample: default 0 days
  --perc1 PERC1, -p1 PERC1
                        % distance from close price at order creation time for
                        the limit/trigger price in Limit/Stop orders
  --perc2 PERC2, -p2 PERC2
                        % distance from close price at order creation time for
                        the limit price in StopLimit orders

```

The full code

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime
import os.path
import time
import sys

import backtrader as bt
import backtrader.feeds as btfeeds
import backtrader.indicators as btind

class OrderExecutionStrategy(bt.Strategy):
    params = (
        ('smaperiod', 15),
        ('exectype', 'Market'),
        ('perc1', 3),
        ('perc2', 1),
        ('valid', 4),
    )

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.data.datetime[0]
        if isinstance(dt, float):
            dt = bt.num2date(dt)
        print('%s, %s' % (dt.isoformat(), txt))

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            self.log('ORDER ACCEPTED/SUBMITTED', dt=order.created.dt)
            self.order = order
            return

        if order.status in [order.Expired]:
            self.log('BUY EXPIRED')

        elif order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    'BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

            else:  # Sell
                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

        # Sentinel to None: new orders allowed
        self.order = None

    def __init__(self):
        # SimpleMovingAverage on main data
        # Equivalent to -> sma = btind.SMA(self.data, period=self.p.smaperiod)
        sma = btind.SMA(period=self.p.smaperiod)

        # CrossOver (1: up, -1: down) close / sma
        self.buysell = btind.CrossOver(self.data.close, sma, plot=True)

        # Sentinel to None: new ordersa allowed
        self.order = None

    def next(self):
        if self.order:
            # An order is pending ... nothing can be done
            return

        # Check if we are in the market
        if self.position:
            # In the maerket - check if it's the time to sell
            if self.buysell < 0:
                self.log('SELL CREATE, %.2f' % self.data.close[0])
                self.sell()

        elif self.buysell > 0:
            if self.p.valid:
                valid = self.data.datetime.date(0) + \
                        datetime.timedelta(days=self.p.valid)
            else:
                valid = None

            # Not in the market and signal to buy
            if self.p.exectype == 'Market':
                self.buy(exectype=bt.Order.Market)  # default if not given

                self.log('BUY CREATE, exectype Market, price %.2f' %
                         self.data.close[0])

            elif self.p.exectype == 'Close':
                self.buy(exectype=bt.Order.Close)

                self.log('BUY CREATE, exectype Close, price %.2f' %
                         self.data.close[0])

            elif self.p.exectype == 'Limit':
                price = self.data.close * (1.0 - self.p.perc1 / 100.0)

                self.buy(exectype=bt.Order.Limit, price=price, valid=valid)

                if self.p.valid:
                    txt = 'BUY CREATE, exectype Limit, price %.2f, valid: %s'
                    self.log(txt % (price, valid.strftime('%Y-%m-%d')))
                else:
                    txt = 'BUY CREATE, exectype Limit, price %.2f'
                    self.log(txt % price)

            elif self.p.exectype == 'Stop':
                price = self.data.close * (1.0 + self.p.perc1 / 100.0)

                self.buy(exectype=bt.Order.Stop, price=price, valid=valid)

                if self.p.valid:
                    txt = 'BUY CREATE, exectype Stop, price %.2f, valid: %s'
                    self.log(txt % (price, valid.strftime('%Y-%m-%d')))
                else:
                    txt = 'BUY CREATE, exectype Stop, price %.2f'
                    self.log(txt % price)

            elif self.p.exectype == 'StopLimit':
                price = self.data.close * (1.0 + self.p.perc1 / 100.0)

                plimit = self.data.close * (1.0 + self.p.perc2 / 100.0)

                self.buy(exectype=bt.Order.StopLimit, price=price, valid=valid,
                         plimit=plimit)

                if self.p.valid:
                    txt = ('BUY CREATE, exectype StopLimit, price %.2f,'
                           ' valid: %s, pricelimit: %.2f')
                    self.log(txt % (price, valid.strftime('%Y-%m-%d'), plimit))
                else:
                    txt = ('BUY CREATE, exectype StopLimit, price %.2f,'
                           ' pricelimit: %.2f')
                    self.log(txt % (price, plimit))

def runstrat():
    args = parse_args()

    cerebro = bt.Cerebro()

    data = getdata(args)
    cerebro.adddata(data)

    cerebro.addstrategy(
        OrderExecutionStrategy,
        exectype=args.exectype,
        perc1=args.perc1,
        perc2=args.perc2,
        valid=args.valid,
        smaperiod=args.smaperiod
    )
    cerebro.run()

    if args.plot:
        cerebro.plot(numfigs=args.numfigs, style=args.plotstyle)

def getdata(args):

    dataformat = dict(
        bt=btfeeds.BacktraderCSVData,
        visualchart=btfeeds.VChartCSVData,
        sierrachart=btfeeds.SierraChartCSVData,
        yahoo=btfeeds.YahooFinanceCSVData,
        yahoo_unreversed=btfeeds.YahooFinanceCSVData
    )

    dfkwargs = dict()
    if args.csvformat == 'yahoo_unreversed':
        dfkwargs['reverse'] = True

    if args.fromdate:
        fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')
        dfkwargs['fromdate'] = fromdate

    if args.todate:
        fromdate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')
        dfkwargs['todate'] = todate

    dfkwargs['dataname'] = args.infile

    dfcls = dataformat[args.csvformat]

    return dfcls(**dfkwargs)

def parse_args():
    parser = argparse.ArgumentParser(
        description='Showcase for Order Execution Types')

    parser.add_argument('--infile', '-i', required=False,
                        default='../../datas/2006-day-001.txt',
                        help='File to be read in')

    parser.add_argument('--csvformat', '-c', required=False, default='bt',
                        choices=['bt', 'visualchart', 'sierrachart',
                                 'yahoo', 'yahoo_unreversed'],
                        help='CSV Format')

    parser.add_argument('--fromdate', '-f', required=False, default=None,
                        help='Starting date in YYYY-MM-DD format')

    parser.add_argument('--todate', '-t', required=False, default=None,
                        help='Ending date in YYYY-MM-DD format')

    parser.add_argument('--plot', '-p', action='store_false', required=False,
                        help='Plot the read data')

    parser.add_argument('--plotstyle', '-ps', required=False, default='bar',
                        choices=['bar', 'line', 'candle'],
                        help='Plot the read data')

    parser.add_argument('--numfigs', '-n', required=False, default=1,
                        help='Plot using n figures')

    parser.add_argument('--smaperiod', '-s', required=False, default=15,
                        help='Simple Moving Average Period')

    parser.add_argument('--exectype', '-e', required=False, default='Market',
                        help=('Execution Type: Market (default), Close, Limit,'
                              ' Stop, StopLimit'))

    parser.add_argument('--valid', '-v', required=False, default=0, type=int,
                        help='Validity for Limit sample: default 0 days')

    parser.add_argument('--perc1', '-p1', required=False, default=0.0,
                        type=float,
                        help=('%% distance from close price at order creation'
                              ' time for the limit/trigger price in Limit/Stop'
                              ' orders'))

    parser.add_argument('--perc2', '-p2', required=False, default=0.0,
                        type=float,
                        help=('%% distance from close price at order creation'
                              ' time for the limit price in StopLimit orders'))

    return parser.parse_args()

if __name__ == '__main__':
    runstrat()

```
########################################
docu-order.txt - lunghezza: 11709
########################################
Orders

Cerebro
 is the key control system in 
backtrader
 and 
Strategy
 (a
subclass) is the key control point of the end user. The latter needs a chaining
method to other parts of the system and that’s where 
orders
 play a key
role.

Orders
 translate the decisions made by the logic in a 
Strategy
 into a
message suitable for the 
Broker
 to execute an action. This is done with:

Creation

Through Strategy’s methods: 
buy\``,
sell
and
close
(Strategy) which return an
order` instance as a reference

Cancellation

Through Strategy’s method: 
cancel
 (Strategy) which takes an
order instance to operate on

And the 
orders
 serve also as a communication method back to the user, to
notify how things are running in the broker.

Notification

To Strategy method: 
notify_order
 (Strategy) which reports an

order
 instance

Order creation

When invoking the 
buy
, 
sell
 and 
close
 the following parameters
apply for creation:

data
 (default: 
None
)

For which data the order has to be created. If 
None
 then the
first data in the system, 
self.datas[0] or self.data0
 (aka

self.data
) will be used

size
 (default: 
None
)

Size to use (positive) of units of data to use for the order.

If 
None
 the 
sizer
 instance retrieved via 
getsizer
 will
be used to determine the size.

price
 (default: 
None
)

Price to use (live brokers may place restrictions on the actual
format if it does not comply to minimum tick size requirements)

None
 is valid for 
Market
 and 
Close
 orders (the market
determines the price)

For 
Limit
, 
Stop
 and 
StopLimit
 orders this value
determines the trigger point (in the case of 
Limit
 the trigger
is obviously at which price the order should be matched)

plimit
 (default: 
None
)

Only applicable to 
StopLimit
 orders. This is the price at which
to set the implicit 
Limit
 order, once the 
Stop
 has been
triggered (for which 
price
 has been used)

exectype
 (default: 
None
)

Possible values:

Order.Market
 or 
None
. A market order will be executed
  with the next available price. In backtesting it will be the
  opening price of the next bar

Order.Limit
. An order which can only be executed at the given

price
 or better

Order.Stop
. An order which is triggered at 
price
 and
  executed like an 
Order.Market
 order

Order.StopLimit
. An order which is triggered at 
price
 and
  executed as an implicit 
Limit
 order with price given by

pricelimit

valid
 (default: 
None
)

Possible values:

None
: this generates an order that will not expire (aka

Good till cancel
) and remain in the market until matched or
    canceled. In reality brokers tend to impose a temporal limit,
    but this is usually so far away in time to consider it as not
    expiring

datetime.datetime
 or 
datetime.date
 instance: the date
    will be used to generate an order valid until the given
    datetime (aka 
good till date
)

Order.DAY
 or 
0
 or 
timedelta()
: a day valid until
    the 
End of the Session
 (aka 
day
 order) will be generated

numeric value
: This is assumed to be a value corresponding
    to a datetime in 
matplotlib
 coding (the one used by

backtrader
) and will used to generate an order valid until
    that time (
good till date
)

tradeid
 (default: 
0
)

This is an internal value applied by 
backtrader
 to keep track
of overlapping trades on the same asset. This 
tradeid
 is sent
back to the 
strategy
 when notifying changes to the status of the
orders.

**kwargs
: additional broker implementations may support extra
    parameters. 
backtrader
 will pass the 
kwargs
 down to the
    created order objects

Example: if the 4 order execution types directly supported by

backtrader
 are not enough, in the case of for example

Interactive Brokers
 the following could be passed as 
kwargs
:

```
orderType='LIT', lmtPrice=10.0, auxPrice=9.8

```

This would override the settings created by 
backtrader
 and
generate a 
LIMIT IF TOUCHED
 order with a 
touched
 price of 9.8
and a 
limit
 price of 10.0.

Note

The 
close
 method will examine the current position and
correspondingly use 
buy
 or 
sell
 to effectively 
close
 the
position. 
size
 will also be automatically calculated unless the
parameter is an input from the user, in which case a partial 
close

or a 
reversal
 can be achieved

Order notification

To receive notifications the 
notify_order
 method has to be overriden in the
user subclassed 
Strategy
 (the default behavior is to do nothing). The
following applies to those notifications:

Issued before the strategy’s 
next
 method is called

May (and will) happen several times for the same 
order
 with the same or
    different status during the same 
next
 cycle.

An 
order
 may be submitted to the 
broker
 and be 
accepted
 and its
execution 
completed
 before 
next
 will be invoked again.

In this case at least 3 notifications will happen with the following

status
 values:

Order.Submitted
 because the order was sent to the 
broker

Order.Accepted
 because the order was taken by the 
broker
 and
    awaits potential execution

Order.Completed
 because in the example it was quickly matched and
    completely filled (which may be the case usually for 
Market
 orders)

Notifications may happen even several times for the same status in the case of

Order.Partial
. This status will not be seen in the 
backtesting
 broker
(which doesn’t consider volume when matching) but it will for sure be set by
real brokers.

Real brokers may issue one or more executions before updating a position, and
this group of executions will make up for an 
Order.Partial
 notification.

Actual execution data is in the attribute: 
order.executed
 which is an
object of type 
OrderData
 (see below for the reference), with usual fields
as 
size
 and 
price

The values at the time of creation are stored in 
order.created
 which
remains unchanged throughout the lifecycle of an 
order

Order Status values

The following are defined:

Order.Created
: set when the 
Order
 instance is created. Never to be
    seen by end-users unless 
order
 instances are manually created rather
    than through 
buy
, 
sell
 and 
close

Order.Submitted
: set when the 
order
 instance has been transmitted
    to the 
broker
. This simply means it has been 
sent
. In 
backtesting

    mode this will be an immediate action, but it may take actual 
time
 with a
    real broker, which may receive the order and only first notify when it has
    been forwarded to an exchange

Order.Accepted
: the 
broker
 has taken the order and it is in the
    system (or already in a exchange) awaiting execution according to the set
    parameters like execution type, size, price and validity

Order.Partial
: the 
order
 has been partially
    executed. 
order.executed
 contains the current filled 
size
 and
    average price.

order.executed.exbits
 contains a complete list of 
ExecutionBits

detailing the partial fillings

Order.Complete
: the 
order
 has been completely filled
    average price.

Order.Rejected
: the 
broker
 has rejected the order. A parameter
    (like for example 
valid
 to determine its lifetime) may not be accepted
    by the 
broker
 and the 
order
 cannot be accepted.

The reason will be notified via the 
notify_store
 method of the

strategy
. Although this may seem awkward, the reason is that real life
brokers will notify this over an event, which may or may not be direclty
related to the order. But the notification from the broker can still be
seen in 
notify_store
.

This status will not be seen in the 
backtesting
 broker

Order.Margin
: the order execution would imply a margin call and the
    previously accepted order has been taken off the system

Order.Cancelled
 (or 
Order.Canceled
): confirmation of the user
    requested cancellation

It must be taken into account that a request to 
cancel
 an order via the

cancel
 method of the strategy is no guarantee of cancellation. The
order may have been already executed but such execution may not have yet
notified by the broker and/or the notification may not have yet been
delivered to the strategy

Order.Expired
: a previously accepted 
order
 which had a time validity
    has expired and been taken off the system

Reference: Order and associated classes

These objects are the generic classes in the 
backtrader
 ecosystem. They may
been extended and/or contain extra embedded information when operating with
other brokers. See the reference of the appropriate broker

class backtrader.order.Order()

Class which holds creation/execution data and type of oder.

The order may have the following status:

Submitted: sent to the broker and awaiting confirmation

Accepted: accepted by the broker

Partial: partially executed

Completed: fully exexcuted

Canceled/Cancelled: canceled by the user

Expired: expired

Margin: not enough cash to execute the order.

Rejected: Rejected by the broker

This can happen during order submission (and therefore the order will
not reach the Accepted status) or before execution with each new bar
price because cash has been drawn by other sources (future-like
instruments may have reduced the cash or orders orders may have been
executed)

Member Attributes:

ref: unique order identifier

created: OrderData holding creation data

executed: OrderData holding execution data

info: custom information passed over method 
addinfo()
. It is kept
    in the form of an OrderedDict which has been subclassed, so that keys
    can also be specified using ‘.’ notation

User Methods:

isbuy(): returns bool indicating if the order buys

issell(): returns bool indicating if the order sells

alive(): returns bool if order is in status Partial or Accepted

class backtrader.order.OrderData(dt=None, size=0, price=0.0, pricelimit=0.0, remsize=0, pclose=0.0, trailamount=0.0, trailpercent=0.0)

Holds actual order data for Creation and Execution.

In the case of Creation the request made and in the case of Execution the
actual outcome.

Member Attributes:

exbits : iterable of OrderExecutionBits for this OrderData

dt: datetime (float) creation/execution time

size: requested/executed size

price: execution price
    Note: if no price is given and no pricelimite is given, the closing
    price at the time or order creation will be used as reference

pricelimit: holds pricelimit for StopLimit (which has trigger first)

trailamount: absolute price distance in trailing stops

trailpercent: percentage price distance in trailing stops

value: market value for the entire bit size

comm: commission for the entire bit execution

pnl: pnl generated by this bit (if something was closed)

margin: margin incurred by the Order (if any)

psize: current open position size

pprice: current open position price

class backtrader.order.OrderExecutionBit(dt=None, size=0, price=0.0, closed=0, closedvalue=0.0, closedcomm=0.0, opened=0, openedvalue=0.0, openedcomm=0.0, pnl=0.0, psize=0, pprice=0.0)

Intended to hold information about order execution. A “bit” does not
determine if the order has been fully/partially executed, it just holds
information.

Member Attributes:

dt: datetime (float) execution time

size: how much was executed

price: execution price

closed: how much of the execution closed an existing postion

opened: how much of the execution opened a new position

openedvalue: market value of the “opened” part

closedvalue: market value of the “closed” part

closedcomm: commission for the “closed” part

openedcomm: commission for the “opened” part

value: market value for the entire bit size

comm: commission for the entire bit execution

pnl: pnl generated by this bit (if something was closed)

psize: current open position size

pprice: current open position price
########################################
docu-order_target-order_target.txt - lunghezza: 15782
########################################
Target Orders

Until version 
1.8.10.96
 smart staking was possible with 
backtrader
 over
the 
Strategy
 methods: 
buy
 and 
sell
. It was all about adding a

Sizer
 to the equation which is responsible for the size of the stake.

What a 
Sizer
 cannot do is decide if the operation has to be a 
buy
 or a

sell
. And that means that a new concept is needed in which a small
intelligence layer is added to make such decision.

Here is where the family of 
order_target_xxx
 methods in the 
Strategy
 come
into play. Inspired by the ones in 
zipline
, the methods offer the chance to
simply specify the final 
target
, be the target:

size
 -> amount of shares, contracts in the portfolio of a specific
    asset

value
 -> value in monetary units of the asset in the portfolio

percent
 -> percentage (from current portfolio) value of the asset in
    the current portfolio

Note

The reference for the methods can be found in Strategy. The
summary is that the methods use the same 
signature
 as 
buy
 and

sell
 except for the parameter 
size
 which is replaced by the
parameter 
target

In this case it is all about specifying the final 
target
 and the method
decides if an operation will be a 
buy
 or a 
sell
. The same logic applies to
the 3 methods. Let’s tart with 
order_target_size

If the 
target
 is greater than the position a 
buy
 is issued, with the
    difference 
target - position_size

Examples:

Pos: 
0
, 
target
: 
7
 -> 
buy(size=7 - 0)
 -> 
buy(size=7)

Pos: 
3
, 
target
: 
7
 -> 
buy(size=7 - 3)
 -> 
buy(size=4)

Pos: 
-3
, 
target
: 
7
 -> 
buy(size=7 - -3)
 -> 
buy(size=10)

Pos: 
-3
, 
target
: 
-2
 -> 
buy(size=-2 - -3)
 -> 
buy(size=1)

If the 
target
 is smaller than the position a 
sell
 is issued with the
    difference 
position_size - target

Examples:

Pos: 
0
, 
target
: 
-7
 -> 
sell(size=0 - -7)
 -> 
sell(size=7)

Pos: 
3
, 
target
: 
-7
 -> 
sell(size=3 - -7)
 -> 
sell(size=10)

Pos: 
-3
, 
target
: 
-7
 -> 
sell(size=-3 - -7)
 -> 
sell(size=4)

Pos: 
3
, 
target
: 
2
 -> 
sell(size=3 - 2)
 -> 
sell(size=1)

When targetting a value with 
order_target_value
, the current 
value
 of the
asset in the portfolio and the 
position size
 are both taken into account to
decide what the final underlying operation will be. The reasoning:

If 
position size
 is negative (
short
) and the 
target value
 has to be
    greater than the current value, this means: 
sell
 more

As such the logic works as follows:

If 
target > value
 and 
size >=0
 -> 
buy

If 
target > value
 and 
size < 0
 -> 
sell

If 
target < value
 and 
size >= 0
 -> 
sell

If 
target < value
 and 
size < 0
 -> 
buy

The logic for 
order_target_percent
 is the same as that of

order_target_value
. This method simply takes into account the current total
value of the portfolio to determine the 
target value
 for the asset.

The Sample

backtrader
 tries to have a sample for each new functionality and this is no
exception. No bells and whistles, just something to test the results are as
expected. This one is under the 
order_target
 directory in the samples.

The logic in the sample is rather dumb and only meaant for testing:

During 
odd months
 (Jan, Mar, …), use the 
day
 as target (in the case
    of 
order_target_value
 multiplying the day by 
1000
)

This mimics an increasing 
target

During 
even months
 (Feb, Apr, …) use 
31 - day
 as the 
target

This mimics an decreasing 
target

order_target_size

Let’s see what happens in 
Jan
 and 
Feb
.

```
$ ./order_target.py --target-size -- plot
0001 - 2005-01-03 - Position Size:     00 - Value 1000000.00
0001 - 2005-01-03 - Order Target Size: 03
0002 - 2005-01-04 - Position Size:     03 - Value 999994.39
0002 - 2005-01-04 - Order Target Size: 04
0003 - 2005-01-05 - Position Size:     04 - Value 999992.48
0003 - 2005-01-05 - Order Target Size: 05
0004 - 2005-01-06 - Position Size:     05 - Value 999988.79
...
0020 - 2005-01-31 - Position Size:     28 - Value 999968.70
0020 - 2005-01-31 - Order Target Size: 31
0021 - 2005-02-01 - Position Size:     31 - Value 999954.68
0021 - 2005-02-01 - Order Target Size: 30
0022 - 2005-02-02 - Position Size:     30 - Value 999979.65
0022 - 2005-02-02 - Order Target Size: 29
0023 - 2005-02-03 - Position Size:     29 - Value 999966.33
0023 - 2005-02-03 - Order Target Size: 28
...

```

In 
Jan
 the 
target
 starts at 
3
 with the 1
st
 trading day of the year and
increases. And the 
position
 size moves initially from 
0
 to 
3
 and then
in increments of 
1
.

Finishing 
Jan
 the last 
order_target
 is for 
31
 and that 
position size

is reported when entering the 1
st
 day of 
Feb
, when the new 
target side
 is
requested to be 
30
 and goes changing along with the position in decrements
of ´1`.

order_target_value

A similar behavior is expected from 
target values

```
$ ./order_target.py --target-value --plot
0001 - 2005-01-03 - Position Size:     00 - Value 1000000.00
0001 - 2005-01-03 - data value 0.00
0001 - 2005-01-03 - Order Target Value: 3000.00
0002 - 2005-01-04 - Position Size:     78 - Value 999854.14
0002 - 2005-01-04 - data value 2853.24
0002 - 2005-01-04 - Order Target Value: 4000.00
0003 - 2005-01-05 - Position Size:     109 - Value 999801.68
0003 - 2005-01-05 - data value 3938.17
0003 - 2005-01-05 - Order Target Value: 5000.00
0004 - 2005-01-06 - Position Size:     138 - Value 999699.57
...
0020 - 2005-01-31 - Position Size:     808 - Value 999206.37
0020 - 2005-01-31 - data value 28449.68
0020 - 2005-01-31 - Order Target Value: 31000.00
0021 - 2005-02-01 - Position Size:     880 - Value 998807.33
0021 - 2005-02-01 - data value 30580.00
0021 - 2005-02-01 - Order Target Value: 30000.00
0022 - 2005-02-02 - Position Size:     864 - Value 999510.21
0022 - 2005-02-02 - data value 30706.56
0022 - 2005-02-02 - Order Target Value: 29000.00
0023 - 2005-02-03 - Position Size:     816 - Value 999130.05
0023 - 2005-02-03 - data value 28633.44
0023 - 2005-02-03 - Order Target Value: 28000.00
...

```

There is an extra line of information telling what the actual 
data value
 (in
the portfolio) is. This helps in finding out if the 
target value
 has been
reachec.

The initial target is 
3000.0
 and the reported initial value is

2853.24
. The question here is whether this is 
close enough
. And the
answer is 
Yes

The sample uses a 
Market
 order at the end of a daily bar and the last
    available price to calculate a 
target size
 which meets the 
target value

The execution uses then the 
open
 price of the next day and this is
    unlikely to be the previous 
close

Doing it in any other way would mean one is 
cheating
 him/herfself.

The next 
target value
 and 
final value
 are much closer: 
4000
 and

3938.17
.

When changing into 
Feb
 the 
target value
 starts decreasing from 
31000
 to

30000
 and 
29000
. So does the 
data value
 with from 
30580.00
 to

30706.56
 and then to 
28633.44
. Wait:

30580
 -> 
30706.56
 is a positive change

Indeed. In this case the calculated 
size
 for the 
target value
 met an

opening price
 which bumped the value to 
30706.56

How this effect can be avoided:

The sample uses a 
Market
 type execution for the orders and this effect
    cannot be avoided

The methods 
order_target_xxx
 allow specifying the 
execution type
 and

price
.

One could specify 
Limit
 as the execution order and let the price be the

close
 price (chosen by the method if nothing else be provided) or even
provide specific pricing

order_target_percent

In this case it is simply a percentage of the current portfolio value.

```
$ ./order_target.py --target-percent --plot
0001 - 2005-01-03 - Position Size:     00 - Value 1000000.00
0001 - 2005-01-03 - data percent 0.00
0001 - 2005-01-03 - Order Target Percent: 0.03
0002 - 2005-01-04 - Position Size:     785 - Value 998532.05
0002 - 2005-01-04 - data percent 0.03
0002 - 2005-01-04 - Order Target Percent: 0.04
0003 - 2005-01-05 - Position Size:     1091 - Value 998007.44
0003 - 2005-01-05 - data percent 0.04
0003 - 2005-01-05 - Order Target Percent: 0.05
0004 - 2005-01-06 - Position Size:     1381 - Value 996985.64
...
0020 - 2005-01-31 - Position Size:     7985 - Value 991966.28
0020 - 2005-01-31 - data percent 0.28
0020 - 2005-01-31 - Order Target Percent: 0.31
0021 - 2005-02-01 - Position Size:     8733 - Value 988008.94
0021 - 2005-02-01 - data percent 0.31
0021 - 2005-02-01 - Order Target Percent: 0.30
0022 - 2005-02-02 - Position Size:     8530 - Value 995005.45
0022 - 2005-02-02 - data percent 0.30
0022 - 2005-02-02 - Order Target Percent: 0.29
0023 - 2005-02-03 - Position Size:     8120 - Value 991240.75
0023 - 2005-02-03 - data percent 0.29
0023 - 2005-02-03 - Order Target Percent: 0.28
...

```

And the information has been changed to see the 
%
 the data represents in
the portfolio.

Sample Usage

```
$ ./order_target.py --help
usage: order_target.py [-h] [--data DATA] [--fromdate FROMDATE]
                       [--todate TODATE] [--cash CASH]
                       (--target-size | --target-value | --target-percent)
                       [--plot [kwargs]]

Sample for Order Target

optional arguments:
  -h, --help            show this help message and exit
  --data DATA           Specific data to be read in (default:
                        ../../datas/yhoo-1996-2015.txt)
  --fromdate FROMDATE   Starting date in YYYY-MM-DD format (default:
                        2005-01-01)
  --todate TODATE       Ending date in YYYY-MM-DD format (default: 2006-12-31)
  --cash CASH           Ending date in YYYY-MM-DD format (default: 1000000)
  --target-size         Use order_target_size (default: False)
  --target-value        Use order_target_value (default: False)
  --target-percent      Use order_target_percent (default: False)
  --plot [kwargs], -p [kwargs]
                        Plot the read data applying any kwargs passed For
                        example: --plot style="candle" (to plot candles)
                        (default: None)

```

Sample Code

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
from datetime import datetime

import backtrader as bt

class TheStrategy(bt.Strategy):
    '''
    This strategy is loosely based on some of the examples from the Van
    K. Tharp book: *Trade Your Way To Financial Freedom*. The logic:

      - Enter the market if:
        - The MACD.macd line crosses the MACD.signal line to the upside
        - The Simple Moving Average has a negative direction in the last x
          periods (actual value below value x periods ago)

     - Set a stop price x times the ATR value away from the close

     - If in the market:

       - Check if the current close has gone below the stop price. If yes,
         exit.
       - If not, update the stop price if the new stop price would be higher
         than the current
    '''

    params = (
        ('use_target_size', False),
        ('use_target_value', False),
        ('use_target_percent', False),
    )

    def notify_order(self, order):
        if order.status == order.Completed:
            pass

        if not order.alive():
            self.order = None  # indicate no order is pending

    def start(self):
        self.order = None  # sentinel to avoid operrations on pending order

    def next(self):
        dt = self.data.datetime.date()

        portfolio_value = self.broker.get_value()
        print('%04d - %s - Position Size:     %02d - Value %.2f' %
              (len(self), dt.isoformat(), self.position.size, portfolio_value))

        data_value = self.broker.get_value([self.data])

        if self.p.use_target_value:
            print('%04d - %s - data value %.2f' %
                  (len(self), dt.isoformat(), data_value))

        elif self.p.use_target_percent:
            port_perc = data_value / portfolio_value
            print('%04d - %s - data percent %.2f' %
                  (len(self), dt.isoformat(), port_perc))

        if self.order:
            return  # pending order execution

        size = dt.day
        if (dt.month % 2) == 0:
            size = 31 - size

        if self.p.use_target_size:
            target = size
            print('%04d - %s - Order Target Size: %02d' %
                  (len(self), dt.isoformat(), size))

            self.order = self.order_target_size(target=size)

        elif self.p.use_target_value:
            value = size * 1000

            print('%04d - %s - Order Target Value: %.2f' %
                  (len(self), dt.isoformat(), value))

            self.order = self.order_target_value(target=value)

        elif self.p.use_target_percent:
            percent = size / 100.0

            print('%04d - %s - Order Target Percent: %.2f' %
                  (len(self), dt.isoformat(), percent))

            self.order = self.order_target_percent(target=percent)

def runstrat(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()
    cerebro.broker.setcash(args.cash)

    dkwargs = dict()
    if args.fromdate is not None:
        dkwargs['fromdate'] = datetime.strptime(args.fromdate, '%Y-%m-%d')
    if args.todate is not None:
        dkwargs['todate'] = datetime.strptime(args.todate, '%Y-%m-%d')

    # data
    data = bt.feeds.YahooFinanceCSVData(dataname=args.data, **dkwargs)
    cerebro.adddata(data)

    # strategy
    cerebro.addstrategy(TheStrategy,
                        use_target_size=args.target_size,
                        use_target_value=args.target_value,
                        use_target_percent=args.target_percent)

    cerebro.run()

    if args.plot:
        pkwargs = dict(style='bar')
        if args.plot is not True:  # evals to True but is not True
            npkwargs = eval('dict(' + args.plot + ')')  # args were passed
            pkwargs.update(npkwargs)

        cerebro.plot(**pkwargs)

def parse_args(pargs=None):

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Sample for Order Target')

    parser.add_argument('--data', required=False,
                        default='../../datas/yhoo-1996-2015.txt',
                        help='Specific data to be read in')

    parser.add_argument('--fromdate', required=False,
                        default='2005-01-01',
                        help='Starting date in YYYY-MM-DD format')

    parser.add_argument('--todate', required=False,
                        default='2006-12-31',
                        help='Ending date in YYYY-MM-DD format')

    parser.add_argument('--cash', required=False, action='store',
                        type=float, default=1000000,
                        help='Ending date in YYYY-MM-DD format')

    pgroup = parser.add_mutually_exclusive_group(required=True)

    pgroup.add_argument('--target-size', required=False, action='store_true',
                        help=('Use order_target_size'))

    pgroup.add_argument('--target-value', required=False, action='store_true',
                        help=('Use order_target_value'))

    pgroup.add_argument('--target-percent', required=False,
                        action='store_true',
                        help=('Use order_target_percent'))

    # Plot options
    parser.add_argument('--plot', '-p', nargs='?', required=False,
                        metavar='kwargs', const=True,
                        help=('Plot the read data applying any kwargs passed\n'
                              '\n'
                              'For example:\n'
                              '\n'
                              '  --plot style="candle" (to plot candles)\n'))

    if pargs is not None:
        return parser.parse_args(pargs)

    return parser.parse_args()

if __name__ == '__main__':
    runstrat()

```
########################################
docu-pandas-datafeed-pandas-datafeed.txt - lunghezza: 5411
########################################
Pandas DataFeed Example

Note

pandas
 and its dependencies have to be installed

Supporting 
Pandas
 Dataframes seems to be of concern to
lots of people, who rely on the already available parsing code for different
data sources (including CSV) and other functionalities offered by Pandas.

The important declarations for the Datafeed.

Note

These are 
ONLY
 declarations. Don't copy this code blindly. See the
actual usage in the example below

```
class PandasData(feed.DataBase):
    '''
    The ``dataname`` parameter inherited from ``feed.DataBase`` is the pandas
    DataFrame
    '''

    params = (
        # Possible values for datetime (must always be present)
        #  None : datetime is the "index" in the Pandas Dataframe
        #  -1 : autodetect position or case-wise equal name
        #  >= 0 : numeric index to the colum in the pandas dataframe
        #  string : column name (as index) in the pandas dataframe
        ('datetime', None),

        # Possible values below:
        #  None : column not present
        #  -1 : autodetect position or case-wise equal name
        #  >= 0 : numeric index to the colum in the pandas dataframe
        #  string : column name (as index) in the pandas dataframe
        ('open', -1),
        ('high', -1),
        ('low', -1),
        ('close', -1),
        ('volume', -1),
        ('openinterest', -1),
    )

```

The above excerpt from the 
PandasData
 class shows the keys:

The 
dataname
 parameter to the class during instantiation holds the
    Pandas Dataframe

This parameter is inherited from the base class 
feed.DataBase

The new parameters have the names of the regular fields in the

DataSeries
 and follow these conventions

datetime
 (default: None)

None : datetime is the “index” in the Pandas Dataframe

-1 : autodetect position or case-wise equal name

= 0 : numeric index to the colum in the pandas dataframe

string : column name (as index) in the pandas dataframe

open
, 
high
, 
low
, 
high
, 
close
, 
volume
,

openinterest
 (default: -1 for all of them)

None : column not present

-1 : autodetect position or case-wise equal name

= 0 : numeric index to the colum in the pandas dataframe

string : column name (as index) in the pandas dataframe

A small sample should be able to load the standar 2006 sample, having been
parsed by 
Pandas
, rather than directly by 
backtrader

Running the sample to use the exiting “headers” in the CSV data:

```
$ ./panda-test.py
--------------------------------------------------
               Open     High      Low    Close  Volume  OpenInterest
Date
2006-01-02  3578.73  3605.95  3578.73  3604.33       0             0
2006-01-03  3604.08  3638.42  3601.84  3614.34       0             0
2006-01-04  3615.23  3652.46  3615.23  3652.46       0             0

```

The same but telling the script to skip the headers:

```
$ ./panda-test.py --noheaders
--------------------------------------------------
                  1        2        3        4  5  6
0
2006-01-02  3578.73  3605.95  3578.73  3604.33  0  0
2006-01-03  3604.08  3638.42  3601.84  3614.34  0  0
2006-01-04  3615.23  3652.46  3615.23  3652.46  0  0

```

The 2
nd
 run is using tells 
pandas.read_csv
:

To skip the first input row (
skiprows
 keyword argument set to 1)

Not to look for a headers row (
header
 keyword argument set to None)

The 
backtrader
 support for Pandas tries to automatically detect if column
names have been used or else numeric indices and acts accordingly, trying to
offer a best match.

The following chart is the tribute to success. The Pandas Dataframe has been
correctly loaded (in both cases)

The sample code for the test.

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse

import backtrader as bt
import backtrader.feeds as btfeeds

import pandas

def runstrat():
    args = parse_args()

    # Create a cerebro entity
    cerebro = bt.Cerebro(stdstats=False)

    # Add a strategy
    cerebro.addstrategy(bt.Strategy)

    # Get a pandas dataframe
    datapath = ('../../datas/2006-day-001.txt')

    # Simulate the header row isn't there if noheaders requested
    skiprows = 1 if args.noheaders else 0
    header = None if args.noheaders else 0

    dataframe = pandas.read_csv(datapath,
                                skiprows=skiprows,
                                header=header,
                                parse_dates=True,
                                index_col=0)

    if not args.noprint:
        print('--------------------------------------------------')
        print(dataframe)
        print('--------------------------------------------------')

    # Pass it to the backtrader datafeed and add it to the cerebro
    data = bt.feeds.PandasData(dataname=dataframe)

    cerebro.adddata(data)

    # Run over everything
    cerebro.run()

    # Plot the result
    cerebro.plot(style='bar')

def parse_args():
    parser = argparse.ArgumentParser(
        description='Pandas test script')

    parser.add_argument('--noheaders', action='store_true', default=False,
                        required=False,
                        help='Do not use header rows')

    parser.add_argument('--noprint', action='store_true', default=False,
                        help='Print the dataframe')

    return parser.parse_args()

if __name__ == '__main__':
    runstrat()

```
########################################
docu-plotting-plotting.txt - lunghezza: 22332
########################################
Plotting

Although 
backtesting
 is meant to be an automated process based on
mathematical calculations, it is often the case that one wants to actually
visualize what’s going on. Be it with an existing algorithm which has undergone
a backtesting run or looking at what really indicators (built-in or custom)
deliver with the data.

And because everything has a human being behind it, charting the data feeds,
indicators, operations, evolution of cash and portfolio value can help the
humans to better appreciate what’s going on, discard/modify/create ideas and
whatever the human looking at the chart may do with the visual information.

That’s why 
backtrader
, using the facilities provided by 
matplotlib
,
provides built-in charting facilities.

How to plot

Any backtesting run can be plotted with the invocation of a single method:

```
cerebro.plot()

```

Of course this is usually the last command issued like in this simple code
which uses one of the sample data from the 
backtrader
 sources.

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import backtrader as bt

class St(bt.Strategy):
    def __init__(self):
        self.sma = bt.indicators.SimpleMovingAverage(self.data)

data = bt.feeds.BacktraderCSVData(dataname='../../datas/2005-2006-day-001.txt')

cerebro = bt.Cerebro()
cerebro.adddata(data)
cerebro.addstrategy(St)
cerebro.run()
cerebro.plot()

```

And this yields the following chart.

The chart includes 3 
Observers
 which in this case and given the lack of any
trading are mostly pointless

A 
CashValue
 observer which as the name implies keeps track of the

Cash
 and total portolio 
Value
 (including cash) during the life of
    the backtesting run

A 
Trade
 Observer which shows, at the end of a trade, the actual 
Profit
    and Loss

A trade is defined as opening a position and taking the position back to

0
 (directly or crossing over from long to short or short to long)

A 
BuySell
 observer which plots (on top of the prices) where 
buy
 and

sell
 operations have taken place

These 
3 Observers
 are automatically added by 
cerebro
, and are controlled
with the 
stdstats
 parameter (default: 
True
). Do the following to
disable them if you wish:

```
cerebro = bt.Cerebro(stdstats=False)

```

or later when 
running
 as in:

```
cerebro = bt.Cerebro()
...
cerebro.run(stdstats=False)

```

Plotted Elements

Although the 
Observers
 have already been mentioned above in the
introduction, they are not the only elements to get plotted. These 3 things get
plotted:

Data Feeds
 added to Cerebro with 
adddata
, 
replaydata
 and

resampledata

Indicators
 declared at strategy level (or added to cerebro with

addindicator
 which is purely meant for experimentation purposes and has
    the indicator added to a dummy strategy)

Observers
 added to cerebro with 
addobserver

The Observers are 
lines
 objects which run in sync with the 
strategy
 and
have access to the entire ecosystem, to be able to track things like

Cash
 and 
Value

Plotting Options

Indicators
 and 
Observers
 have several options that control how they have to
be plotted on the chart. There are 3 big groups:

Options affecting the plotting behavior of the entire object

Options affecting the plotting behavior of individual lines

Options affecting the SYSTEM wide plotting options

Object-wide plotting options

These are controlled by this data set in 
Indicators
 and 
Observers
:

```
plotinfo = dict(plot=True,
                subplot=True,
                plotname='',
                plotskip=False,
                plotabove=False,
                plotlinelabels=False,
                plotlinevalues=True,
                plotvaluetags=True,
                plotymargin=0.0,
                plotyhlines=[],
                plotyticks=[],
                plothlines=[],
                plotforce=False,
                plotmaster=None,
                plotylimited=True,
           )

```

Although 
plotinfo
 is shown as a 
dict
 during class definition, the
metaclass machinery of 
backtrader
 turns that into an object which is
inherited and can undergo even multiple inheritance. Than means:

If a subclass changes for example a value like 
subplot=True
 to

subplot=False
, subclasses further down the hierarchy will have the
    latter as the default value for 
subplot

There are 2 methods of giving value to these parameters. Let’s look at a

SimpleMovingAverage
 instantiation for the 1
st
 method:

```
sma = bt.indicators.SimpleMovingAverage(self.data, period=15, plotname='mysma')

```

As can be inferred from the example, any 
**kwargs
 not consumed by the

SimpleMovingAverage
 constructor will be parsed (if possible) as

plotinfo
 values. The 
SimpleMovingAverage
 has a single parameter defined
which is 
period
. And this means that 
plotname
 will be matched against
the parameter of the same name in 
plotinfo
.

The 2
nd
 method:

```
sma = bt.indicators.SimpleMovingAverage(self.data, period=15)
sma.plotinfo.plotname = 'mysma'

```

The 
plotinfo
 object instantiated along the 
SimpleMovingAverage
 can be
accessed and the parameters inside can also be accessed with the standard

Python
 dot notation. Easy and possibly clearer than the syntax abve.

The meaning of the options

plot
: whether the object has to be plotted

subplot
: whether to plot along the data or in an independent
    subchart. 
Moving Averages
 are an example of plotting over the
    data. 
Stochastic
 and 
RSI
 are examples of things plotted in a subchart
    on a different scale.

plotname
: name to use on the chart instead of the 
class
 name. As in
    the example above 
mysma
 instead of 
SimpleMovingAverage

plotskip
 (
deprecated
): and old alias of 
plot

plotabove
: whether to plot above the data. Else plot below. This has
    only effect if 
subplot=True

plotlinelabels
: whether to plot the names of the individudal lines
    along the data in the legend on the chart when 
subplot=False

Example: The 
Bollinger Bands
 have 3 lines but the indicator is plotted on
top of the data. It seems sensible to have the legend only display a single
name like 
BollingerBands
 rather than having the name of the 3
individual lines displayed (
mid
, 
top
, 
bot
)

A use case for this is the 
BuySell
 observer for which it makes sense to
display the name of the 2 lines and its markers: 
Buy
 and 
Sell
 to
make it clear for the end user what is what.

plotlinevalues
: controls whether the legend for the lines in indicators
    and observers has the last plotted value. Can be controlled on a per-line
    basis with 
_plotvalue
 for each line

plotvaluetags
: controls whether a value tag with the last value is
    plotted on the right hand side of the line. Can be controlled on a per-line
    basis with 
_plotvaluetag
 for each line

plotymargin
: margin to add to the top and bottom of individual
    subcharts on the graph

It is a percentage but 1 based. For example: 0.05 -> 5%

plothlines
: an 
iterable
 containing values (within the scale) at
    which 
horizontal
 lines have to be plotted.

This for example helps for the classical indicators with 
overbought
,

oversold
 areas like the 
RSI
 which usually has lines plotted at 
70

and 
30

plotyticks
: an 
iterable
 containing values (within the scale) at
    which value ticks have to specifically be placed on the scale

For example to force the scale to have a 
50
 to identify the mid point
of the scale. Although this seems obvious, the indicators use an
auto-scaling mechanism and the 
50
 may not be obviously be in the centre
if an indicator with a 
0-100
 scale moves between 30-95 on a regular basis.

plotyhlines
: an 
iterable
 containing values (within the scale) at
    which 
horizontal
 lines have to be plotted.

This can take over both 
plothlines
 and 
plotyticks
.

If none of the above are defined, then where to place 
horizontal
 lines
and 
ticks
 will be entirely controlled by this value

If any of the above are defined they have precedence over the values
present in this option

plotforce
: sometimes and thus the complex process of matching data
    feeds to indicators and bla, bla, bla … a custom indicator may fail to
    plot. This is a last resort mechanism to try to enforce plotting.

Use it if all else fails

plotmaster
: an 
Indicator
/
Observer
 has a master which is the 
data

    on which is working. In some cases plotting it with a different master may
    be wished needed.

A use case is the 
PivotPoint
 indicator which is calculated on

Monthly
 data but is meant for 
Daily
 data. It only makes sense to
plot it on the 
daily
 data which is where the indicator makes sense.

plotylimited
: currently only applies to data feeds. If 
True

    (default), other lines on the data plot don’t change the scale. Example:
    Bollinger Bands (top and bottom) may be far away from the actual absolute
    minimum/maximum of the data feed. With 
\
plotlimited=True
, those bands
    remain out of the chart, because the data controls the scaling. If set to
False`, the bands affects the y-scale and become visible on the chart

A use case is the 
PivotPoint
 indicator which is calculated on

Monthly
 data but is meant for 
Daily
 data. It only makes sense to
plot it on the 
daily
 data which is where the indicator makes sense.

Line specific plotting options

Indicators
/
Observers
 have 
lines
 and how this 
lines
 are plotted can be
influenced with the 
plotlines
 object. Most of options specified in

plotlines
 are meant to be directly passed over to 
matplotlib
 when
plotting. The documentation relies therefore on examples of things that have
been done.

IMPORTANT
: The options are specified on a per-line basis.

Some of the options are controlled directly by 
backtrader
. These all start
with an underscore (
_
):

_plotskip
 (
boolean
) which indicates that plotting of a specific line
    has to be skipped if set to 
True

_plotvalue
 (
boolean
) to control if the legend of this line will
    contain the last plotted value (default is 
True
)

_plotvaluetag
 (
boolean
) to control if a righ hand side tag with the
    last value is plotted (default is 
True
)

_name
 (
string
) which changes the plot name of a specific line

_skipnan
 (
bool
, default: False): to skip 
NaN
 values when plotting
    and allowing for example to draw a line between 2 distant points generated
    by an indicator, which has all intermediate values as 
NaN
 (default
    value for new created data points)

_samecolor
 (
boolean
) this forces the next line to have the same color
    as the previous one avoiding the 
matplotlib
 default mechanism of
    cycling trough a color map for each new plotted element

_method
 (
string
) which chooses the plotting method 
matplotlib

    will use for the element. If this is not specified, then the most basic

plot
 method will be chosen.

Example from 
MACDHisto
. Here the 
histo
 line is plotted as a 
bar

which is the industry de-facto standard. The following definition can be
found in the definition of 
MACDHisto
:

```
lines = ('histo',)
plotlines = dict(histo=dict(_method='bar', alpha=0.50, width=1.0))

```

alpha
 and 
width
 are options for 
matplotlib

_fill_gt
 / 
_fill_lt

Allow filling between the given line and:

Another line

A numeric value

The arguments is an iterable of 2 elements in which:

The 1
st
 argument is a 
string
 (name of reference line) or a numeric
    value

The filling will be done in between the own values and the values of
the line or the numeric value

The 2
nd
 argument is either:

A string with a colour name (
matplotlib
 compatible) or hex
  specification (see 
matloplit
 examples)

or

An iterable where the 1
st
 element is the string/hex value for the
  colour and the second element is a numeric value specifying the alpha
  transparency (default: 
0.20
 controlled with 
fillalpha
 in a
  plotting scheme)

Examples:

```
# Fill for myline when above other_line with colour red
plotlines = dict(
    myline=dict(_fill_gt('other_line', 'red'))
)

# Fill for myline when above 50 with colour red
plotlines = dict(
    myline=dict(_fill_gt(50, 'red))
)

# Fill for myline when above other_line with colour red and 50%
# transparency (1.0 means "no transparency")

plotlines = dict(
    myline=dict(_fill_gt('other_line', ('red', 0.50)))
)

```

Passing options to a not yet known line

Ue the name 
_X
 where 
X
 stands for a digit in a zero-based index. This means
    that the options are for line 
X

A use case from 
OscillatorMixIn
:

```
plotlines = dict(_0=dict(_name='osc'))

```

As the name implies, this is a 
mixin
 class intended to be used in multiple
inheritance schemes (specifically on the right hand side). The 
mixin
 has no
knowledge of the actual name of the 1
st
 line (index is zero-based) from the
other indicator that will be part of  the multiple inheritance mix.

And that’s why the options are specified to be for: 
_0
. After the
subclassing has taken place the 1
st
 line of the resulting class will have the
name 
osc
 in plot.

Some plotlines examples

The 
BuySell
 observer has the following:

```
plotlines = dict(
    buy=dict(marker='^', markersize=8.0, color='lime', fillstyle='full'),
    sell=dict(marker='v', markersize=8.0, color='red', fillstyle='full')
)

```

The 
buy
 and 
sell
 lines have options which are passed directly to

matplotlib
 to define 
marker
, 
markersize
, 
color
 and 
fillstyle
. All
these options are defined in 
matplotlib

The 
Trades
 observer has the following:

```
...
lines = ('pnlplus', 'pnlminus')
...

plotlines = dict(
    pnlplus=dict(_name='Positive',
                 marker='o', color='blue',
                 markersize=8.0, fillstyle='full'),
    pnlminus=dict(_name='Negative',
                  marker='o', color='red',
                  markersize=8.0, fillstyle='full')
)

```

Here the names of the lines have been redefined from for example 
pnlplus
 to

Positive
 by using 
_name
. The rest of the options are for 
matplotlib

The 
DrawDown
 observer:

```
lines = ('drawdown', 'maxdrawdown',)

...

plotlines = dict(maxdrawdown=dict(_plotskip='True',))

```

This one defines two lines to let the end users access not only the value of
the current 
drawdown
 but also its maximum value (
maxdrawdown
). But the
latter is not plotted due to 
_plotskip=True

The 
BollingerBands
 indicator:

```
plotlines = dict(
    mid=dict(ls='--'),
    top=dict(_samecolor=True),
    bot=dict(_samecolor=True),
)

```

Here the 
mid
 line will have a 
dashed
 style and the 
top
 and 
bot

lines will have the same color as the 
mid
 line.

The 
Stochastic
 (defined in 
_StochasticBase
 and inherited):

```
lines = ('percK', 'percD',)
...
plotlines = dict(percD=dict(_name='%D', ls='--'),
                 percK=dict(_name='%K'))

```

The slower line 
percD
 is plotted with a 
dashed
 style. And the names of
the lines are changed to include fancy 
%
 signs (
%K
 and 
%D
) which
cannot be used in name definitions in 
Python

Methods controlling plotting

When dealing with 
Indicators
 and 
Observers
 the following methods are
supported to further control plotting:

_plotlabel(self)

Which should return a list of things to conform the labels which will be
placed in between parentheses after the name of the 
Indicators
 or

Observer

An example from the 
RSI
 indicator:

```
def _plotlabel(self):
    plabels = [self.p.period]
    plabels += [self.p.movav] * self.p.notdefault('movav')
    return plabels

```

As can be seen this method returns:

An 
int
 which indicates the period configured for the 
RSI
 and if
    the default moving average has been changed, the specific class

In the background both will be converted to a string. In the case of
the 
class
 an effort will be made to just print the name of the class
rather than the complete 
module.name
 combination.

_plotinit(self)

Which is called at the beginning of plotting to do whatever specific
initialization the indicator may need. Again, an example from 
RSI
:

```
def _plotinit(self):
    self.plotinfo.plotyhlines = [self.p.upperband, self.p.lowerband]

```

Here the code assigns a value to 
plotyhlines
 to have horizontal lines
(the 
hlines
 part) plotted at specific 
y
 values.

The values of the parameters 
upperband
 and 
lowerband
 are used for
this, which cannot be known in advance, because the parameters can be
changed by the end user

System-wide plotting options

First the 
signature
 of 
plot
 within cerebro:

```
def plot(self, plotter=None, numfigs=1, iplot=True, **kwargs):

```

Which means:

plotter
: an object/class containing as attributes the options
    controlling the system wide plotting

If 
None
 is passed a default 
PlotScheme
 object (see below) will be
instantiated

numfigs
: in how many independent charts a plot has to be broken

Sometimes a chart contains too many bars and will not be easily readable if
packed in a single figure. This breaks it down in as many pieces as
requested

iplot
: automatically plot inline if running inside a Jupyter Notebook

**kwargs
: the args will be used to change the values of the attributes
    of 
plotter
 or the default 
PlotScheme
 object created if no

plotter
 is passed.

PlotScheme

This object contains all the options that contol system-wide plotting. The
options are documented in the code:

```
class PlotScheme(object):
    def __init__(self):
        # to have a tight packing on the chart wether only the x axis or also
        # the y axis have (see matplotlib)
        self.ytight = False

        # y-margin (top/bottom) for the subcharts. This will not overrule the
        # option plotinfo.plotymargin
        self.yadjust = 0.0
        # Each new line is in z-order below the previous one. change it False
        # to have lines paint above the previous line
        self.zdown = True
        # Rotation of the date labes on the x axis
        self.tickrotation = 15

        # How many "subparts" takes a major chart (datas) in the overall chart
        # This is proportional to the total number of subcharts
        self.rowsmajor = 5

        # How many "subparts" takes a minor chart (indicators/observers) in the
        # overall chart. This is proportional to the total number of subcharts
        # Together with rowsmajor, this defines a proportion ratio betwen data
        # charts and indicators/observers charts
        self.rowsminor = 1

        # Distance in between subcharts
        self.plotdist = 0.0

        # Have a grid in the background of all charts
        self.grid = True

        # Default plotstyle for the OHLC bars which (line -> line on close)
        # Other options: 'bar' and 'candle'
        self.style = 'line'

        # Default color for the 'line on close' plot
        self.loc = 'black'
        # Default color for a bullish bar/candle (0.75 -> intensity of gray)
        self.barup = '0.75'
        # Default color for a bearish bar/candle
        self.bardown = 'red'
        # Level of transparency to apply to bars/cancles (NOT USED)
        self.bartrans = 1.0

        # Wether the candlesticks have to be filled or be transparent
        self.barupfill = True
        self.bardownfill = True

        # Wether the candlesticks have to be filled or be transparent
        self.fillalpha = 0.20

        # Wether to plot volume or not. Note: if the data in question has no
        # volume values, volume plotting will be skipped even if this is True
        self.volume = True

        # Wether to overlay the volume on the data or use a separate subchart
        self.voloverlay = True
        # Scaling of the volume to the data when plotting as overlay
        self.volscaling = 0.33
        # Pushing overlay volume up for better visibiliy. Experimentation
        # needed if the volume and data overlap too much
        self.volpushup = 0.00

        # Default colour for the volume of a bullish day
        self.volup = '#aaaaaa'  # 0.66 of gray
        # Default colour for the volume of a bearish day
        self.voldown = '#cc6073'  # (204, 96, 115)
        # Transparency to apply to the volume when overlaying
        self.voltrans = 0.50

        # Transparency for text labels (NOT USED CURRENTLY)
        self.subtxttrans = 0.66
        # Default font text size for labels on the chart
        self.subtxtsize = 9

        # Transparency for the legend (NOT USED CURRENTLY)
        self.legendtrans = 0.25
        # Wether indicators have a leged displaey in their charts
        self.legendind = True
        # Location of the legend for indicators (see matplotlib)
        self.legendindloc = 'upper left'

        # Plot the last value of a line after the Object name
        self.linevalues = True

        # Plot a tag at the end of each line with the last value
        self.valuetags = True

        # Default color for horizontal lines (see plotinfo.plothlines)
        self.hlinescolor = '0.66'  # shade of gray
        # Default style for horizontal lines
        self.hlinesstyle = '--'
        # Default width for horizontal lines
        self.hlineswidth = 1.0

        # Default color scheme: Tableau 10
        self.lcolors = tableau10

        # strftime Format string for the display of ticks on the x axis
        self.fmt_x_ticks = None

        # strftime Format string for the display of data points values
        self.fmt_x_data = None

```

Colors in PlotScheme

The 
PlotScheme
 class defines a method which can be overriden in subclasses
which returns the next color to be used:

```
def color(self, idx)

```

Where 
idx
 is the current index to the line being plotted on a individual
subchart. The 
MACD
 for example plots 3 lines and hence the 
idx
 variable
will only have the following values: 
0
, 
1
 and 
2
. The next chart
(maybe another indicator) will star the count again at 
0
.

The default color scheme used in 
backtrader
 uses (as seen above) is the

Tableau 10 Color Palette
 with the index modified to be:

```
tab10_index = [3, 0, 2, 1, 2, 4, 5, 6, 7, 8, 9]

```

By overriding the 
color
 method or passing a 
lcolors
 variable to

plot
 (or in a subclass of 
PlotScheme
) the colouring can be completely
changed.

The source code contains also the defintions for the 
Tableau 10 Light
 and
the 
Tableau 20
 color palettes.
########################################
docu-position.txt - lunghezza: 928
########################################
Position

Position on an asset is usually checked from within a Strategy with:

position
 (a property) or 
getposition(data=None, broker=None)

Which will return the position on 
datas[0]
 of the strategy in the
default 
broker
 provided by cerebro

A position is simply the indication of:

An asset is being held with 
size

The average price is 
price

It serves as a status and can for example be used in deciding if an order has to
be issued or not (example: long positions are only entered if no position is
open)

Reference: Position

class backtrader.position.Position(size=0, price=0.0)

Keeps and updates the size and price of a position. The object has no
relationship to any asset. It only keeps size and price.

Member Attributes:

```
* size (int): current size of the position

* price (float): current price of the position

```

The Position instances can be tested using len(position) to see if size
is not null
########################################
docu-quickstart-quickstart.txt - lunghezza: 63589
########################################
Quickstart

Note

The data files used in the quickstart guide are updated from time to time,
which means that the 
adjusted close
 changes and with it the 
close
 (and
the other components). That means that the actual output may be different
to what was put in the documentation at the time of writing.

Using the platform

Let’s run through a series of examples (from almost an empty one to a fully
fledged strategy) but not without before roughly explaining 2 basic concepts
when working with 
backtrader

Lines

Data Feeds, Indicators and Strategies have 
lines
.

A line is a succession of points that when joined together form this
 line. When talking about the markets, a Data Feed has usually the following
 set of points per day:

Open, High, Low, Close, Volume, OpenInterest

The series of “Open”s along time is a Line. And therefore a Data Feed has
 usually 6 lines.

If we also consider “DateTime” (which is the actual reference for a single
 point), we could count 7 lines.

Index 0 Approach

When accessing the values in a line, the current value is accessed with
 index: 
0

And the “last” output value is accessed with 
-1
. This in line with Python
 conventions for iterables (and a line can be iterated and is therefore an
 iterable) where index 
-1
 is used to access the “last” item of the
 iterable/array.

In our case is the last 
output
 value what’s getting accessed.

As such and being index 
0
 right after 
-1
, it is used to access the
 current moment in line.

With that in mind and if we imagine a Strategy featuring a Simple Moving
average created during initialization:

```
self.sma = SimpleMovingAverage(.....)

```

The easiest and simplest way to access the current value of this moving average:

```
av = self.sma[0]

```

There is no need to know how many bars/minutes/days/months have been processed,
because “0” uniquely identifies the current instant.

Following pythonic tradition, the “last” output value is accessed using 
-1
:

```
previous_value = self.sma[-1]

```

Of course earlier output values can be accessed with -2, -3, …

From 0 to 100: the samples

Basic Setup

Let’s get running.

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import backtrader as bt

if __name__ == '__main__':
    cerebro = bt.Cerebro()

    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    cerebro.run()

    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

```

After the execution the output is:

```
Starting Portfolio Value: 10000.00
Final Portfolio Value: 10000.00

```

In this example:

backtrader was imported

The Cerebro engine was instantiated

The resulting 
cerebro
 instance was told to 
run
 (loop over data)

And the resulting outcome was printed out

Although it doesn’t seem much, let’s point out something explicitly shown:

The Cerebro engine has created a 
broker
 instance in the background

The instance already has some cash to start with

This behind the scenes broker instantiation is a constant trait in the platform
to simplify the life of the user. If no broker is set by the user, a default one
is put in place.

And 10K monetary units is a usual value with some brokers to begin with.

Setting the Cash

In the world of finance, for sure only “losers” start with 10k. Let’s change the
cash and run the example again.

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import backtrader as bt

if __name__ == '__main__':
    cerebro = bt.Cerebro()
    cerebro.broker.setcash(100000.0)

    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    cerebro.run()

    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

```

After the execution the output is:

```
Starting Portfolio Value: 1000000.00
Final Portfolio Value: 1000000.00

```

Mission accomplished. Let’s move to tempestuous waters.

Adding a Data Feed

Having cash is fun, but the purpose behind all this is to let an automated
strategy multiply the cash without moving a finger by operating on an asset
which we see as a 
Data Feed

Ergo … No 
Data Feed
 -> 
No Fun
. Let’s add one to the ever growing
example.

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

if __name__ == '__main__':
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Datas are in a subfolder of the samples. Need to find where the script is
    # because it could have been called from anywhere
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')

    # Create a Data Feed
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values after this date
        todate=datetime.datetime(2000, 12, 31),
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(100000.0)

    # Print out the starting conditions
    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

```

After the execution the output is:

```
Starting Portfolio Value: 1000000.00
Final Portfolio Value: 1000000.00

```

The amount of boilerplate has grown slightly, because we added:

Finding out where our example script is to be able to locate the sample

Data Feed
 file

Having 
datetime
 objects to filter on which data from the 
Data Feed
 we
    will be operating

Aside from that, the 
Data Feed
 is created and added to 
cerebro
.

The output has not changed and it would be a miracle if it had.

Note

Yahoo Online sends the CSV data in date descending order, which is not
the standard convention. The 
reversed=True
 prameter takes into
account that the CSV data in the file has already been 
reversed

and has the standard expected date ascending order.

Our First Strategy

The cash is in the 
broker
 and the 
Data Feed
 is there. It seems like risky
business is just around the corner.

Let’s put a Strategy into the equation and print the “Close” price of each day
(bar).

DataSeries
 (the underlying class in 
Data Feeds
) objects have aliases to
access the well known OHLC (Open High Low Close) daily values. This should ease
up the creation of our printing logic.

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey
class TestStrategy(bt.Strategy):

    def log(self, txt, dt=None):
        ''' Logging function for this strategy'''
        dt = dt or self.datas[0].datetime.date(0)
        print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the "close" line in the data[0] dataseries
        self.dataclose = self.datas[0].close

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log('Close, %.2f' % self.dataclose[0])

if __name__ == '__main__':
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)

    # Datas are in a subfolder of the samples. Need to find where the script is
    # because it could have been called from anywhere
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')

    # Create a Data Feed
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values before this date
        todate=datetime.datetime(2000, 12, 31),
        # Do not pass values after this date
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(100000.0)

    # Print out the starting conditions
    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

```

After the execution the output is:

```
Starting Portfolio Value: 100000.00
2000-01-03T00:00:00, Close, 27.85
2000-01-04T00:00:00, Close, 25.39
2000-01-05T00:00:00, Close, 24.05
...
...
...
2000-12-26T00:00:00, Close, 29.17
2000-12-27T00:00:00, Close, 28.94
2000-12-28T00:00:00, Close, 29.29
2000-12-29T00:00:00, Close, 27.41
Final Portfolio Value: 100000.00

```

Someone said the stockmarket was risky business, but it doesn’t seem so.

Let’s explain some of the magic:

Upon 
init
 being called the strategy already has a list of datas that are
    present in the platform

This is a standard Python 
list
 and datas can be accessed in the order they
were inserted.

The first data in the list self.datas[0] is the default data for trading
operations and to keep all strategy elements synchronized (
it’s the system
clock
)

self.dataclose = self.datas[0].close keeps a reference to the 
close
    line
. Only one level of indirection is later needed to access the close
    values.

The strategy next method will be called on each bar of the system clock
    (self.datas[0]). This is true until other things come into play like

indicators
, which need some bars to start producing an output. More on
    that later.

Adding some Logic to the Strategy

Let’s try some crazy idea we had by looking at some charts

If the price has been falling 3 sessions in a row … BUY BUY BUY!!!

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey
class TestStrategy(bt.Strategy):

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.datas[0].datetime.date(0)
        print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the "close" line in the data[0] dataseries
        self.dataclose = self.datas[0].close

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log('Close, %.2f' % self.dataclose[0])

        if self.dataclose[0] < self.dataclose[-1]:
            # current close less than previous close

            if self.dataclose[-1] < self.dataclose[-2]:
                # previous close less than the previous close

                # BUY, BUY, BUY!!! (with all possible default parameters)
                self.log('BUY CREATE, %.2f' % self.dataclose[0])
                self.buy()

if __name__ == '__main__':
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)

    # Datas are in a subfolder of the samples. Need to find where the script is
    # because it could have been called from anywhere
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')

    # Create a Data Feed
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values before this date
        todate=datetime.datetime(2000, 12, 31),
        # Do not pass values after this date
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(100000.0)

    # Print out the starting conditions
    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

```

After the execution the output is:

```
Starting Portfolio Value: 100000.00
2000-01-03, Close, 27.85
2000-01-04, Close, 25.39
2000-01-05, Close, 24.05
2000-01-05, BUY CREATE, 24.05
2000-01-06, Close, 22.63
2000-01-06, BUY CREATE, 22.63
2000-01-07, Close, 24.37
...
...
...
2000-12-20, BUY CREATE, 26.88
2000-12-21, Close, 27.82
2000-12-22, Close, 30.06
2000-12-26, Close, 29.17
2000-12-27, Close, 28.94
2000-12-27, BUY CREATE, 28.94
2000-12-28, Close, 29.29
2000-12-29, Close, 27.41
Final Portfolio Value: 99725.08

```

Several “BUY” creation orders were issued, our porftolio value was
decremented. A couple of important things are clearly missing.

The order was created but it is unknown if it was executed, when and at what
    price.

The next example will build upon that by listening to notifications of order
status.

The curious reader may ask how many shares are being bought, what asset is being
bought and how are orders being executed. Where possible (and in this case it is)
the platform fills in the gaps:

self.datas[0] (the main data aka system clock) is the target asset if no
    other one is specified

The stake is provided behind the scenes by a 
position sizer
 which uses a
    fixed stake, being the default “1”. It will be modified in a later example

The order is executed “At Market”. The broker (shown in previous examples)
    executes this using the opening price of the next bar, because that’s the
    1
st
 tick after the current under examination bar.

The order is executed so far without any commission (more on that later)

Do not only buy … but SELL

After knowing how to enter the market (long), an “exit concept” is needed and
also understanding whether the strategy is in the market.

Luckily a Strategy object offers access to a 
position
 attribute for the
    default 
data feed

Methods 
buy
 and 
sell
 return the 
created
 (not yet executed) order

Changes in orders’ status will be notified to the strategy via a 
notify

    method

The 
“exit concept”
 will be an easy one:

Exit after 5 bars (on the 6
th
 bar) have elapsed for good or for worse

Please notice that there is no “time” or “timeframe” implied: number of
bars. The bars can represent 1 minute, 1 hour, 1 day, 1 week or any other
time period.

Although we know the data source is a daily one, the strategy makes no
assumption about that.

Additionally and to simplify:

Do only allow a Buy order if not yet in the market

Note

The 
next
 method gets no “bar index” passed and therefore it seems
obscure how to understand when 5 bars may have elapsed, but this has
been modeled in pythonic way: call 
len
 on an object and it will tell
you the length of its 
lines
. Just write down (save in a variable) at
which length in an operation took place and see if the current length
is 5 bars away.

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey
class TestStrategy(bt.Strategy):

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.datas[0].datetime.date(0)
        print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the "close" line in the data[0] dataseries
        self.dataclose = self.datas[0].close

        # To keep track of pending orders
        self.order = None

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log('BUY EXECUTED, %.2f' % order.executed.price)
            elif order.issell():
                self.log('SELL EXECUTED, %.2f' % order.executed.price)

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('Order Canceled/Margin/Rejected')

        # Write down: no pending order
        self.order = None

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log('Close, %.2f' % self.dataclose[0])

        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return

        # Check if we are in the market
        if not self.position:

            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] < self.dataclose[-1]:
                    # current close less than previous close

                    if self.dataclose[-1] < self.dataclose[-2]:
                        # previous close less than the previous close

                        # BUY, BUY, BUY!!! (with default parameters)
                        self.log('BUY CREATE, %.2f' % self.dataclose[0])

                        # Keep track of the created order to avoid a 2nd order
                        self.order = self.buy()

        else:

            # Already in the market ... we might sell
            if len(self) >= (self.bar_executed + 5):
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log('SELL CREATE, %.2f' % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

if __name__ == '__main__':
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)

    # Datas are in a subfolder of the samples. Need to find where the script is
    # because it could have been called from anywhere
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')

    # Create a Data Feed
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values before this date
        todate=datetime.datetime(2000, 12, 31),
        # Do not pass values after this date
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(100000.0)

    # Print out the starting conditions
    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

```

After the execution the output is:

```
Starting Portfolio Value: 100000.00
2000-01-03T00:00:00, Close, 27.85
2000-01-04T00:00:00, Close, 25.39
2000-01-05T00:00:00, Close, 24.05
2000-01-05T00:00:00, BUY CREATE, 24.05
2000-01-06T00:00:00, BUY EXECUTED, 23.61
2000-01-06T00:00:00, Close, 22.63
2000-01-07T00:00:00, Close, 24.37
2000-01-10T00:00:00, Close, 27.29
2000-01-11T00:00:00, Close, 26.49
2000-01-12T00:00:00, Close, 24.90
2000-01-13T00:00:00, Close, 24.77
2000-01-13T00:00:00, SELL CREATE, 24.77
2000-01-14T00:00:00, SELL EXECUTED, 25.70
2000-01-14T00:00:00, Close, 25.18
...
...
...
2000-12-15T00:00:00, SELL CREATE, 26.93
2000-12-18T00:00:00, SELL EXECUTED, 28.29
2000-12-18T00:00:00, Close, 30.18
2000-12-19T00:00:00, Close, 28.88
2000-12-20T00:00:00, Close, 26.88
2000-12-20T00:00:00, BUY CREATE, 26.88
2000-12-21T00:00:00, BUY EXECUTED, 26.23
2000-12-21T00:00:00, Close, 27.82
2000-12-22T00:00:00, Close, 30.06
2000-12-26T00:00:00, Close, 29.17
2000-12-27T00:00:00, Close, 28.94
2000-12-28T00:00:00, Close, 29.29
2000-12-29T00:00:00, Close, 27.41
2000-12-29T00:00:00, SELL CREATE, 27.41
Final Portfolio Value: 100018.53

```

Blistering Barnacles!!! The system made money … something must be wrong

The broker says: Show me the money!

And the money is called “commission”.

Let’s add a reasonable 
0.1%
 commision rate per operation (both for buying and
selling … yes the broker is avid …)

A single line will suffice for it:

```
# 0.1% ... divide by 100 to remove the %
cerebro.broker.setcommission(commission=0.001)

```

Being experienced with the platform we want to see the profit or loss after a
buy/sell cycle, with and without commission.

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey
class TestStrategy(bt.Strategy):

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.datas[0].datetime.date(0)
        print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the "close" line in the data[0] dataseries
        self.dataclose = self.datas[0].close

        # To keep track of pending orders and buy price/commission
        self.order = None
        self.buyprice = None
        self.buycomm = None

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    'BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:  # Sell
                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('Order Canceled/Margin/Rejected')

        self.order = None

    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log('OPERATION PROFIT, GROSS %.2f, NET %.2f' %
                 (trade.pnl, trade.pnlcomm))

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log('Close, %.2f' % self.dataclose[0])

        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return

        # Check if we are in the market
        if not self.position:

            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] < self.dataclose[-1]:
                    # current close less than previous close

                    if self.dataclose[-1] < self.dataclose[-2]:
                        # previous close less than the previous close

                        # BUY, BUY, BUY!!! (with default parameters)
                        self.log('BUY CREATE, %.2f' % self.dataclose[0])

                        # Keep track of the created order to avoid a 2nd order
                        self.order = self.buy()

        else:

            # Already in the market ... we might sell
            if len(self) >= (self.bar_executed + 5):
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log('SELL CREATE, %.2f' % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

if __name__ == '__main__':
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)

    # Datas are in a subfolder of the samples. Need to find where the script is
    # because it could have been called from anywhere
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')

    # Create a Data Feed
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values before this date
        todate=datetime.datetime(2000, 12, 31),
        # Do not pass values after this date
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(100000.0)

    # Set the commission - 0.1% ... divide by 100 to remove the %
    cerebro.broker.setcommission(commission=0.001)

    # Print out the starting conditions
    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

```

After the execution the output is:

```
Starting Portfolio Value: 100000.00
2000-01-03T00:00:00, Close, 27.85
2000-01-04T00:00:00, Close, 25.39
2000-01-05T00:00:00, Close, 24.05
2000-01-05T00:00:00, BUY CREATE, 24.05
2000-01-06T00:00:00, BUY EXECUTED, Price: 23.61, Cost: 23.61, Commission 0.02
2000-01-06T00:00:00, Close, 22.63
2000-01-07T00:00:00, Close, 24.37
2000-01-10T00:00:00, Close, 27.29
2000-01-11T00:00:00, Close, 26.49
2000-01-12T00:00:00, Close, 24.90
2000-01-13T00:00:00, Close, 24.77
2000-01-13T00:00:00, SELL CREATE, 24.77
2000-01-14T00:00:00, SELL EXECUTED, Price: 25.70, Cost: 25.70, Commission 0.03
2000-01-14T00:00:00, OPERATION PROFIT, GROSS 2.09, NET 2.04
2000-01-14T00:00:00, Close, 25.18
...
...
...
2000-12-15T00:00:00, SELL CREATE, 26.93
2000-12-18T00:00:00, SELL EXECUTED, Price: 28.29, Cost: 28.29, Commission 0.03
2000-12-18T00:00:00, OPERATION PROFIT, GROSS -0.06, NET -0.12
2000-12-18T00:00:00, Close, 30.18
2000-12-19T00:00:00, Close, 28.88
2000-12-20T00:00:00, Close, 26.88
2000-12-20T00:00:00, BUY CREATE, 26.88
2000-12-21T00:00:00, BUY EXECUTED, Price: 26.23, Cost: 26.23, Commission 0.03
2000-12-21T00:00:00, Close, 27.82
2000-12-22T00:00:00, Close, 30.06
2000-12-26T00:00:00, Close, 29.17
2000-12-27T00:00:00, Close, 28.94
2000-12-28T00:00:00, Close, 29.29
2000-12-29T00:00:00, Close, 27.41
2000-12-29T00:00:00, SELL CREATE, 27.41
Final Portfolio Value: 100016.98

```

God Save the Queen!!! The system still made money.

Before moving on, let’s notice something by filtering the “OPERATION PROFIT”
lines:

```
2000-01-14T00:00:00, OPERATION PROFIT, GROSS 2.09, NET 2.04
2000-02-07T00:00:00, OPERATION PROFIT, GROSS 3.68, NET 3.63
2000-02-28T00:00:00, OPERATION PROFIT, GROSS 4.48, NET 4.42
2000-03-13T00:00:00, OPERATION PROFIT, GROSS 3.48, NET 3.41
2000-03-22T00:00:00, OPERATION PROFIT, GROSS -0.41, NET -0.49
2000-04-07T00:00:00, OPERATION PROFIT, GROSS 2.45, NET 2.37
2000-04-20T00:00:00, OPERATION PROFIT, GROSS -1.95, NET -2.02
2000-05-02T00:00:00, OPERATION PROFIT, GROSS 5.46, NET 5.39
2000-05-11T00:00:00, OPERATION PROFIT, GROSS -3.74, NET -3.81
2000-05-30T00:00:00, OPERATION PROFIT, GROSS -1.46, NET -1.53
2000-07-05T00:00:00, OPERATION PROFIT, GROSS -1.62, NET -1.69
2000-07-14T00:00:00, OPERATION PROFIT, GROSS 2.08, NET 2.01
2000-07-28T00:00:00, OPERATION PROFIT, GROSS 0.14, NET 0.07
2000-08-08T00:00:00, OPERATION PROFIT, GROSS 4.36, NET 4.29
2000-08-21T00:00:00, OPERATION PROFIT, GROSS 1.03, NET 0.95
2000-09-15T00:00:00, OPERATION PROFIT, GROSS -4.26, NET -4.34
2000-09-27T00:00:00, OPERATION PROFIT, GROSS 1.29, NET 1.22
2000-10-13T00:00:00, OPERATION PROFIT, GROSS -2.98, NET -3.04
2000-10-26T00:00:00, OPERATION PROFIT, GROSS 3.01, NET 2.95
2000-11-06T00:00:00, OPERATION PROFIT, GROSS -3.59, NET -3.65
2000-11-16T00:00:00, OPERATION PROFIT, GROSS 1.28, NET 1.23
2000-12-01T00:00:00, OPERATION PROFIT, GROSS 2.59, NET 2.54
2000-12-18T00:00:00, OPERATION PROFIT, GROSS -0.06, NET -0.12

```

Adding up the “NET” profits the final figure is:

```
15.83

```

But the system said the following at the end:

```
2000-12-29T00:00:00, SELL CREATE, 27.41
Final Portfolio Value: 100016.98

```

And obviously 
15.83
 is not 
16.98
. There is no error whatsoever. The “NET”
profit of 
15.83
 is already cash in the bag.

Unfortunately (or fortunately to better understand the platform) there is an
open position on the last day of the 
Data Feed
. Even if a SELL operation has
been sent … IT HAS NOT YET BEEN EXECUTED.

The “Final Portfolio Value” calculated by the broker takes into account the
“Close” price on 2000-12-29. The actual execution price would have been set on
the next trading day which happened to be 2001-01-02. Extending the 
Data Feed
”
to take into account this day the output is:

```
2001-01-02T00:00:00, SELL EXECUTED, Price: 27.87, Cost: 27.87, Commission 0.03
2001-01-02T00:00:00, OPERATION PROFIT, GROSS 1.64, NET 1.59
2001-01-02T00:00:00, Close, 24.87
2001-01-02T00:00:00, BUY CREATE, 24.87
Final Portfolio Value: 100017.41

```

Now adding the previous NET profit to the completed operation’s net profit:

```
15.83 + 1.59 = 17.42

```

Which (discarding rounding errors in the “print” statements) is the extra
Portfolio above the initial 100000 monetary units the strategy started with.

Customizing the Strategy: Parameters

It would a bit unpractical to hardcode some of the values in the strategy and
have no chance to change them easily. 
Parameters
 come in handy to help.

Definition of parameters is easy and looks like:

```
params = (('myparam', 27), ('exitbars', 5),)

```

Being this a standard Python tuple with some tuples inside it, the following may
look more appealling to some:

```
params = (
    ('myparam', 27),
    ('exitbars', 5),
)

```

With either formatting parametrization of the strategy is allowed when adding
the strategy to the Cerebro engine:

```
# Add a strategy
cerebro.addstrategy(TestStrategy, myparam=20, exitbars=7)

```

Note

The 
setsizing
 method below is deprecated. This content is kept
here for anyone looking at old samples of the sources. The sources
have been update to use:

```
cerebro.addsizer(bt.sizers.FixedSize, stake=10)``

```

Please read the section about 
sizers

Using the parameters in the strategy is easy, as they are stored in a “params”
attribute. If we for example want to set the stake fix, we can pass the stake
parameter to the 
position sizer
 like this durint 
init
:

```
# Set the sizer stake from the params
self.sizer.setsizing(self.params.stake)

```

We could have also called 
buy
 and 
sell
 with a 
stake
 parameter and

self.params.stake
 as the value.

The logic to exit gets modified:

```
# Already in the market ... we might sell
if len(self) >= (self.bar_executed + self.params.exitbars):

```

With all this in mind the example evolves to look like:

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey
class TestStrategy(bt.Strategy):
    params = (
        ('exitbars', 5),
    )

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.datas[0].datetime.date(0)
        print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the "close" line in the data[0] dataseries
        self.dataclose = self.datas[0].close

        # To keep track of pending orders and buy price/commission
        self.order = None
        self.buyprice = None
        self.buycomm = None

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    'BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:  # Sell
                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('Order Canceled/Margin/Rejected')

        self.order = None

    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log('OPERATION PROFIT, GROSS %.2f, NET %.2f' %
                 (trade.pnl, trade.pnlcomm))

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log('Close, %.2f' % self.dataclose[0])

        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return

        # Check if we are in the market
        if not self.position:

            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] < self.dataclose[-1]:
                    # current close less than previous close

                    if self.dataclose[-1] < self.dataclose[-2]:
                        # previous close less than the previous close

                        # BUY, BUY, BUY!!! (with default parameters)
                        self.log('BUY CREATE, %.2f' % self.dataclose[0])

                        # Keep track of the created order to avoid a 2nd order
                        self.order = self.buy()

        else:

            # Already in the market ... we might sell
            if len(self) >= (self.bar_executed + self.params.exitbars):
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log('SELL CREATE, %.2f' % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

if __name__ == '__main__':
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)

    # Datas are in a subfolder of the samples. Need to find where the script is
    # because it could have been called from anywhere
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')

    # Create a Data Feed
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values before this date
        todate=datetime.datetime(2000, 12, 31),
        # Do not pass values after this date
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(100000.0)

    # Add a FixedSize sizer according to the stake
    cerebro.addsizer(bt.sizers.FixedSize, stake=10)

    # Set the commission - 0.1% ... divide by 100 to remove the %
    cerebro.broker.setcommission(commission=0.001)

    # Print out the starting conditions
    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

```

After the execution the output is:

```
Starting Portfolio Value: 100000.00
2000-01-03T00:00:00, Close, 27.85
2000-01-04T00:00:00, Close, 25.39
2000-01-05T00:00:00, Close, 24.05
2000-01-05T00:00:00, BUY CREATE, 24.05
2000-01-06T00:00:00, BUY EXECUTED, Size 10, Price: 23.61, Cost: 236.10, Commission 0.24
2000-01-06T00:00:00, Close, 22.63
...
...
...
2000-12-20T00:00:00, BUY CREATE, 26.88
2000-12-21T00:00:00, BUY EXECUTED, Size 10, Price: 26.23, Cost: 262.30, Commission 0.26
2000-12-21T00:00:00, Close, 27.82
2000-12-22T00:00:00, Close, 30.06
2000-12-26T00:00:00, Close, 29.17
2000-12-27T00:00:00, Close, 28.94
2000-12-28T00:00:00, Close, 29.29
2000-12-29T00:00:00, Close, 27.41
2000-12-29T00:00:00, SELL CREATE, 27.41
Final Portfolio Value: 100169.80

```

In order to see the difference, the print outputs have also been extended to
show the execution size.

Having multiplied the stake by 10, the obvious has happened: the profit and loss
has been multiplied by 10. Instead of 
16.98
, the surplus is now 
169.80

Adding an indicator

Having heard of 
indicators
, the next thing anyone would add to the strategy is
one of them. For sure they must be much better than a simple 
“3 lower closes”

strategy.

Inspired in one of the examples from PyAlgoTrade a strategy using a Simple
Moving Average.

Buy “AtMarket” if the close is greater than the Average

If in the market, sell if the close is smaller than the Average

Only 1 active operation is allowed in the market

Most of the existing code can be kept in place. Let’s add the average during

init
 and keep a reference to it:

```
self.sma = bt.indicators.MovingAverageSimple(self.datas[0], period=self.params.maperiod)

```

And of course the logic to enter and exit the market will rely on the Average
values. Look in the code for the logic.

Note

The starting cash will be 1000 monetary units to be in line with the
PyAlgoTrade example and no commission will be applied

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey
class TestStrategy(bt.Strategy):
    params = (
        ('maperiod', 15),
    )

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.datas[0].datetime.date(0)
        print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the "close" line in the data[0] dataseries
        self.dataclose = self.datas[0].close

        # To keep track of pending orders and buy price/commission
        self.order = None
        self.buyprice = None
        self.buycomm = None

        # Add a MovingAverageSimple indicator
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.maperiod)

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    'BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:  # Sell
                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('Order Canceled/Margin/Rejected')

        self.order = None

    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log('OPERATION PROFIT, GROSS %.2f, NET %.2f' %
                 (trade.pnl, trade.pnlcomm))

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log('Close, %.2f' % self.dataclose[0])

        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return

        # Check if we are in the market
        if not self.position:

            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] > self.sma[0]:

                # BUY, BUY, BUY!!! (with all possible default parameters)
                self.log('BUY CREATE, %.2f' % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.buy()

        else:

            if self.dataclose[0] < self.sma[0]:
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log('SELL CREATE, %.2f' % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

if __name__ == '__main__':
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)

    # Datas are in a subfolder of the samples. Need to find where the script is
    # because it could have been called from anywhere
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')

    # Create a Data Feed
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values before this date
        todate=datetime.datetime(2000, 12, 31),
        # Do not pass values after this date
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(1000.0)

    # Add a FixedSize sizer according to the stake
    cerebro.addsizer(bt.sizers.FixedSize, stake=10)

    # Set the commission
    cerebro.broker.setcommission(commission=0.0)

    # Print out the starting conditions
    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

```

Now, before skipping to the next section 
LOOK CAREFULLY
 to the first date
which is shown in the log:

It’ no longer 
2000-01-03
, the first trading day in the year 2K.

It’s 2000-01-24 … 
Who has stolen my cheese?

The missing days are not missing. The platform has adapted to the new
circumstances:

An indicator (SimpleMovingAverage) has been added to the Strategy.

This indicator needs X bars to produce an output: in the example: 15

2000-01-24 is the day in which the 15
th
 bar occurs

The 
backtrader
 platform assumes that the Strategy has the indicator in place
for a good reason, 
to use it in the decision making process
. And it makes no
sense to try to make decisions if the indicator is not yet ready and producing
values.

next
 will be 1
st
 called when all indicators have already reached the
    minimum needed period to produce a value

In the example there is a single indicator, but the strategy could have any
    number of them.

After the execution the output is:

```
Starting Portfolio Value: 1000.00
2000-01-24T00:00:00, Close, 25.55
2000-01-25T00:00:00, Close, 26.61
2000-01-25T00:00:00, BUY CREATE, 26.61
2000-01-26T00:00:00, BUY EXECUTED, Size 10, Price: 26.76, Cost: 267.60, Commission 0.00
2000-01-26T00:00:00, Close, 25.96
2000-01-27T00:00:00, Close, 24.43
2000-01-27T00:00:00, SELL CREATE, 24.43
2000-01-28T00:00:00, SELL EXECUTED, Size 10, Price: 24.28, Cost: 242.80, Commission 0.00
2000-01-28T00:00:00, OPERATION PROFIT, GROSS -24.80, NET -24.80
2000-01-28T00:00:00, Close, 22.34
2000-01-31T00:00:00, Close, 23.55
2000-02-01T00:00:00, Close, 25.46
2000-02-02T00:00:00, Close, 25.61
2000-02-02T00:00:00, BUY CREATE, 25.61
2000-02-03T00:00:00, BUY EXECUTED, Size 10, Price: 26.11, Cost: 261.10, Commission 0.00
...
...
...
2000-12-20T00:00:00, SELL CREATE, 26.88
2000-12-21T00:00:00, SELL EXECUTED, Size 10, Price: 26.23, Cost: 262.30, Commission 0.00
2000-12-21T00:00:00, OPERATION PROFIT, GROSS -20.60, NET -20.60
2000-12-21T00:00:00, Close, 27.82
2000-12-21T00:00:00, BUY CREATE, 27.82
2000-12-22T00:00:00, BUY EXECUTED, Size 10, Price: 28.65, Cost: 286.50, Commission 0.00
2000-12-22T00:00:00, Close, 30.06
2000-12-26T00:00:00, Close, 29.17
2000-12-27T00:00:00, Close, 28.94
2000-12-28T00:00:00, Close, 29.29
2000-12-29T00:00:00, Close, 27.41
2000-12-29T00:00:00, SELL CREATE, 27.41
Final Portfolio Value: 973.90

```

In the name of the King!!! A winning system turned into a losing one … and
that with no commission. It may well be that 
simply
 adding an 
indicator
 is
not the universal panacea.

Note

The same logic and data with PyAlgoTrade yields a slightly different
result (slightly off). Looking at the entire printout reveals that
some operations are not exactly the same. Being the culprit again the
usual suspect: 
rounding
.

PyAlgoTrade does not round the datafeed values when applying the
divided “adjusted close” to the data feed values.

The Yahoo Data Feed provided by 
backtrader
 rounds the values down
to 2 decimals after applying the adjusted close. Upon printing the
values everything seems the same, but it’s obvious that sometimes
that 5
th
 place decimal plays a role.

Rounding down to 2 decimals seems more realistic, because Market
Exchanges do only allow a number of decimals per asset (being that 2
decimals usually for stocks)

Note

The Yahoo Data Feed (starting with version 
1.8.11.99
 allows to
specify if rounding has to happen and how many decimals)

Visual Inspection: Plotting

A printout or log of the actual whereabouts of the system at each bar-instant is
good but humans tend to be 
visual
 and therefore it seems right to offer a view
of the same whereabouts as chart.

Note

To plot you need to have 
matplotlib
 installed

Once again defaults for plotting are there to assist the platform user. Plotting
is incredibly a 1 line operation:

```
cerebro.plot()

```

Being the location for sure after cerebro.run() has been called.

In order to display the automatic plotting capabilities and a couple of easy
customizations, the following will be done:

A 2
nd
 MovingAverage (Exponential) will be added. The defaults will plot it
    (just like the 1
st
) with the data.

A 3
rd
 MovingAverage (Weighted) will be added. Customized to plot in an own
    plot (even if not sensible)

A Stochastic (Slow) will be added. No change to the defaults.

A MACD will be added. No change to the defaults.

A RSI will be added. No change to the defaults.

A MovingAverage (Simple) will be applied to the RSI. No change to the
    defaults (it will be plotted with the RSI)

An AverageTrueRange will be added. Changed defaults to avoid it being
    plotted.

The entire set of additions to the 
init
 method of the Strategy:

```
# Indicators for the plotting show
bt.indicators.ExponentialMovingAverage(self.datas[0], period=25)
bt.indicators.WeightedMovingAverage(self.datas[0], period=25).subplot = True
bt.indicators.StochasticSlow(self.datas[0])
bt.indicators.MACDHisto(self.datas[0])
rsi = bt.indicators.RSI(self.datas[0])
bt.indicators.SmoothedMovingAverage(rsi, period=10)
bt.indicators.ATR(self.datas[0]).plot = False

```

Note

Even if 
indicators
 are not explicitly added to a member variable of
the strategy (like self.sma = MovingAverageSimple…), they will
autoregister with the strategy and will influence the minimum period
for 
next
 and will be part of the plotting.

In the example only 
RSI
 is added to a temporary variable 
rsi
 with
the only intention to create a MovingAverageSmoothed on it.

The example now:

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey
class TestStrategy(bt.Strategy):
    params = (
        ('maperiod', 15),
    )

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.datas[0].datetime.date(0)
        print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the "close" line in the data[0] dataseries
        self.dataclose = self.datas[0].close

        # To keep track of pending orders and buy price/commission
        self.order = None
        self.buyprice = None
        self.buycomm = None

        # Add a MovingAverageSimple indicator
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.maperiod)

        # Indicators for the plotting show
        bt.indicators.ExponentialMovingAverage(self.datas[0], period=25)
        bt.indicators.WeightedMovingAverage(self.datas[0], period=25,
                                            subplot=True)
        bt.indicators.StochasticSlow(self.datas[0])
        bt.indicators.MACDHisto(self.datas[0])
        rsi = bt.indicators.RSI(self.datas[0])
        bt.indicators.SmoothedMovingAverage(rsi, period=10)
        bt.indicators.ATR(self.datas[0], plot=False)

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    'BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:  # Sell
                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('Order Canceled/Margin/Rejected')

        # Write down: no pending order
        self.order = None

    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log('OPERATION PROFIT, GROSS %.2f, NET %.2f' %
                 (trade.pnl, trade.pnlcomm))

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log('Close, %.2f' % self.dataclose[0])

        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return

        # Check if we are in the market
        if not self.position:

            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] > self.sma[0]:

                # BUY, BUY, BUY!!! (with all possible default parameters)
                self.log('BUY CREATE, %.2f' % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.buy()

        else:

            if self.dataclose[0] < self.sma[0]:
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log('SELL CREATE, %.2f' % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

if __name__ == '__main__':
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)

    # Datas are in a subfolder of the samples. Need to find where the script is
    # because it could have been called from anywhere
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')

    # Create a Data Feed
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values before this date
        todate=datetime.datetime(2000, 12, 31),
        # Do not pass values after this date
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(1000.0)

    # Add a FixedSize sizer according to the stake
    cerebro.addsizer(bt.sizers.FixedSize, stake=10)

    # Set the commission
    cerebro.broker.setcommission(commission=0.0)

    # Print out the starting conditions
    print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())

    # Plot the result
    cerebro.plot()

```

After the execution the output is:

```
Starting Portfolio Value: 1000.00
2000-02-18T00:00:00, Close, 27.61
2000-02-22T00:00:00, Close, 27.97
2000-02-22T00:00:00, BUY CREATE, 27.97
2000-02-23T00:00:00, BUY EXECUTED, Size 10, Price: 28.38, Cost: 283.80, Commission 0.00
2000-02-23T00:00:00, Close, 29.73
...
...
...
2000-12-21T00:00:00, BUY CREATE, 27.82
2000-12-22T00:00:00, BUY EXECUTED, Size 10, Price: 28.65, Cost: 286.50, Commission 0.00
2000-12-22T00:00:00, Close, 30.06
2000-12-26T00:00:00, Close, 29.17
2000-12-27T00:00:00, Close, 28.94
2000-12-28T00:00:00, Close, 29.29
2000-12-29T00:00:00, Close, 27.41
2000-12-29T00:00:00, SELL CREATE, 27.41
Final Portfolio Value: 981.00

```

The final result has changed even if the logic hasn’t
. This is true but the
logic has not been applied to the same number of bars.

Note

As explained before, the platform will first call next when all
indicators are ready to produce a value. In this plotting example
(very clear in the chart) the MACD is the last indicator to be fully
ready (all 3 lines producing an output). The 1
st
 BUY order is no
longer scheduled during Jan 2000 but close to the end of Feb 2000.

The chart:

Let’s Optimize

Many trading books say each market and each traded stock (or commodity or ..)
have different rythms. That there is no such thing as a one size fits all.

Before the plotting sample, when the strategy started using an indicator the
period default value was 15 bars. It’s a strategy parameter and this can be used
in an optimization to change the value of the parameter and see which one better
fits the market.

Note

There is plenty of literature about Optimization and associated pros
and cons. But the advice will always point in the same direction: do
not overoptimize. If a trading idea is not sound, optimizing may end
producing a positive result which is only valid for the backtested
dataset.

The sample is modified to optimize the period of the Simple Moving Average. For
the sake of clarity any output with regards to Buy/Sell orders has been removed

The example now:

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])

# Import the backtrader platform
import backtrader as bt

# Create a Stratey
class TestStrategy(bt.Strategy):
    params = (
        ('maperiod', 15),
        ('printlog', False),
    )

    def log(self, txt, dt=None, doprint=False):
        ''' Logging function fot this strategy'''
        if self.params.printlog or doprint:
            dt = dt or self.datas[0].datetime.date(0)
            print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the "close" line in the data[0] dataseries
        self.dataclose = self.datas[0].close

        # To keep track of pending orders and buy price/commission
        self.order = None
        self.buyprice = None
        self.buycomm = None

        # Add a MovingAverageSimple indicator
        self.sma = bt.indicators.SimpleMovingAverage(
            self.datas[0], period=self.params.maperiod)

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            return

        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    'BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

                self.buyprice = order.executed.price
                self.buycomm = order.executed.comm
            else:  # Sell
                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('Order Canceled/Margin/Rejected')

        # Write down: no pending order
        self.order = None

    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        self.log('OPERATION PROFIT, GROSS %.2f, NET %.2f' %
                 (trade.pnl, trade.pnlcomm))

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log('Close, %.2f' % self.dataclose[0])

        # Check if an order is pending ... if yes, we cannot send a 2nd one
        if self.order:
            return

        # Check if we are in the market
        if not self.position:

            # Not yet ... we MIGHT BUY if ...
            if self.dataclose[0] > self.sma[0]:

                # BUY, BUY, BUY!!! (with all possible default parameters)
                self.log('BUY CREATE, %.2f' % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.buy()

        else:

            if self.dataclose[0] < self.sma[0]:
                # SELL, SELL, SELL!!! (with all possible default parameters)
                self.log('SELL CREATE, %.2f' % self.dataclose[0])

                # Keep track of the created order to avoid a 2nd order
                self.order = self.sell()

    def stop(self):
        self.log('(MA Period %2d) Ending Value %.2f' %
                 (self.params.maperiod, self.broker.getvalue()), doprint=True)

if __name__ == '__main__':
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    strats = cerebro.optstrategy(
        TestStrategy,
        maperiod=range(10, 31))

    # Datas are in a subfolder of the samples. Need to find where the script is
    # because it could have been called from anywhere
    modpath = os.path.dirname(os.path.abspath(sys.argv[0]))
    datapath = os.path.join(modpath, '../../datas/orcl-1995-2014.txt')

    # Create a Data Feed
    data = bt.feeds.YahooFinanceCSVData(
        dataname=datapath,
        # Do not pass values before this date
        fromdate=datetime.datetime(2000, 1, 1),
        # Do not pass values before this date
        todate=datetime.datetime(2000, 12, 31),
        # Do not pass values after this date
        reverse=False)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(1000.0)

    # Add a FixedSize sizer according to the stake
    cerebro.addsizer(bt.sizers.FixedSize, stake=10)

    # Set the commission
    cerebro.broker.setcommission(commission=0.0)

    # Run over everything
    cerebro.run(maxcpus=1)

```

Instead of calling 
addstrategy
 to add a stratey class to Cerebro, the call is
made to 
optstrategy
. And instead of passing a value a range of values is
passed.

One of the “Strategy” hooks is added, the 
stop
 method, which will be called
when the data has been exhausted and backtesting is over. It’s used to print the
final net value of the portfolio in the broker (it was done in Cerebro
previously)

The system will execute the strategy for each value of the range. The following
will be output:

```
2000-12-29, (MA Period 10) Ending Value 880.30
2000-12-29, (MA Period 11) Ending Value 880.00
2000-12-29, (MA Period 12) Ending Value 830.30
2000-12-29, (MA Period 13) Ending Value 893.90
2000-12-29, (MA Period 14) Ending Value 896.90
2000-12-29, (MA Period 15) Ending Value 973.90
2000-12-29, (MA Period 16) Ending Value 959.40
2000-12-29, (MA Period 17) Ending Value 949.80
2000-12-29, (MA Period 18) Ending Value 1011.90
2000-12-29, (MA Period 19) Ending Value 1041.90
2000-12-29, (MA Period 20) Ending Value 1078.00
2000-12-29, (MA Period 21) Ending Value 1058.80
2000-12-29, (MA Period 22) Ending Value 1061.50
2000-12-29, (MA Period 23) Ending Value 1023.00
2000-12-29, (MA Period 24) Ending Value 1020.10
2000-12-29, (MA Period 25) Ending Value 1013.30
2000-12-29, (MA Period 26) Ending Value 998.30
2000-12-29, (MA Period 27) Ending Value 982.20
2000-12-29, (MA Period 28) Ending Value 975.70
2000-12-29, (MA Period 29) Ending Value 983.30
2000-12-29, (MA Period 30) Ending Value 979.80

```

Results:

For periods below 18 the strategy (commissionless) loses money.

For periods between 18 and 26 (both included) the strategy makes money.

Above 26 money is lost again.

And the winning period for this strategy and the given data set is:

20 bars, which wins 78.00 units over 1000 $/€ (a 7.8%)

Note

The extra indicators from the plotting example have been removed and
the start of operations is only influenced by the Simple Moving
Average which is being optimized. Hence the slightly different results
for period 15

Conclusion

The incremental samples have shown how to go from a barebones script to a fully
working trading system which even plots the results and can be optimized.

A lot more can be done to try to improve the chances of winning:

Self defined Indicators

Creating an indicator is easy (and even plotting them is easy)

Sizers

Money Management is for many the key to success

Order Types (limit, stop, stoplimit)

Some others

To ensure all the above items can be fully utilized the documentation provides
an insight into them (and other topics)

Look in the table of contents and keep on reading … and developing.

Best of luck
########################################
docu-signal_strategy-signal_strategy.txt - lunghezza: 12987
########################################
Strategy with Signals

Operating 
backtrader
 is also possible without having to write a

Strategy
. Although this is the preferred way, due to the object hierarchy
which makes up the machinery, using 
Signals
 is also possible.

Quick summary:

Instead of writing a 
Strategy
 class, instantiating 
Indicators
, writing
    the 
buy/sell
 logic …

The end user add 
Signals
 (indicators anyhow) and the rest is done in the
    background

Quick example:

```
import backtrader as bt

data = bt.feeds.OneOfTheFeeds(dataname='mydataname')
cerebro.adddata(data)

cerebro.add_signal(bt.SIGNAL_LONGSHORT, MySignal)
cerebro.run()

```

Et voilá!.

Of course the 
Signal
 itself is missing. Let’s define a very dumb 
Signal

which yields:

Long
 indication if the 
close
 price is above a 
Simple Moving
    Average

Short
 indication if the 
close
 price is below a 
Simple Moving
    Average

The definition:

```
class MySignal(bt.Indicator):
    lines = ('signal',)
    params = (('period', 30),)

    def __init__(self):
        self.lines.signal = self.data - bt.indicators.SMA(period=self.p.period)

```

And now it is really done. When 
run
 is executed 
Cerebro
 will take care of
instantiating a special 
Strategy
 instance which knows what to do with the

Signals
.

Initial 
FAQ

How is the volume of 
buy
/
sell
 operations determined?

A 
cerebro
 instance adds automatically a 
FixedSize
 sizer to
strategies. The end user can change the sizer to alter the policy with

cerebro.addsizer

How are orders executed?

The execution type is 
Market
 and the validity is 
Good Until Canceled

Signals
 technicalities

From a technical and theoretical point of view can be as described:

A callable that returns another 
object
 when called (only once)

This is in most cases the instantiation of a class, but must not be

Supports the 
__getitem__
 interface. The only requested 
key
/
index

    will be 
0

From a practical point of view and looking at the example above a 
Signal
 is:

A 
lines
 object from the 
backtrader
 ecosystem, mostly an 
Indicator

This helps when using other 
Indicators
 like when in the example the 
Simple
Moving Average
 is used.

Signals
 indications

The 
signals
 delivers indications when queried with 
signal[0]
 and the
meaning is:

> 0
 -> 
long indication

< 0
 -> 
short indication

== 0
 -> 
No indication

The example does simple arithmetic with 
self.data - SMA
 and:

Issues a 
long indication
 when the 
data
 is above the 
SMA

Issues a 
short indication
 when the 
data
 is below the 
SMA

Note

When no specific price field is indicated for the 
data
, the

close
 price is the reference price is.

Signals
 Types

The 
constants
 indicated below as seen in the example above, are directly
available from the main 
backtrader
 module as in:

```
import backtrader as bt

bt.SIGNAL_LONG

```

There are 5 types of 
Signals
, broken in 2 groups.

Main Group
:

LONGSHORT
: both 
long
 and 
short
 indications from this signal
    are taken

LONG
:

long
 indications are taken to go long

short
 indications are taken to 
close
 the long position. But:

If a 
LONGEXIT
 (see below) signal is in the system it will be
    used to exit the long

If a 
SHORT
 signal is available and no 
LONGEXIT
 is available
    , it will be used to close a 
long
 before opening a 
short

SHORT
:

short
 indications are taken to go short

long
 indications are taken to 
close
 the short position. But:

If a 
SHORTEXIT
 (see below) signal is in the system it will be
    used to exit the short

If a 
LONG
 signal is available and no 
SHORTEXIT
 is available
    , it will be used to close a 
short
 before opening a 
long

Exit Group
:

This 2 signals are meant to override others and provide criteria for
  exitins a 
long
 / 
short
 position

LONGEXIT
: 
short
 indications are taken to exit 
long

    positions

SHORTEXIT
: 
long
 indications are taken to exit 
short

    positions

Accumulation and Order Concurrency

The sample 
Signal
 shown above will issue 
long
 and 
short
 indications on a
constant basis, because it simply substracts the 
SMA
 value from the

close
 price and this will always be either 
> 0
 and 
< 0
 ( 
0
 is
mathematically possible, but unlikely to really happen)

This would lead to a continuous generation of 
orders
 that would produce 2
situations:

Accumulation
: even if already in the market, the 
signals
 would
    produce new orders which would increase the possition in the market

Concurrency
: new orders would be generated without waiting for the
    execution of other orders

To avoid this the default behavior is:

To Not Accumulate

To Not allow Concurrency

Should any of these two behaviors be wished, this can be controlled via

cerebro
 with:

cerebro.signal_accumulate(True)
 (or 
False
 to re-disable it)

cerebro.signal_concurrency(True)
 (or 
False
 to re-disable it)

The sample

The 
backtrader
 sources contain a sample to test the functionality.

Main signal to be used.

```
class SMACloseSignal(bt.Indicator):
    lines = ('signal',)
    params = (('period', 30),)

    def __init__(self):
        self.lines.signal = self.data - bt.indicators.SMA(period=self.p.period)

```

And the 
Exit Signal
 in case the option is specified.

```
class SMAExitSignal(bt.Indicator):
    lines = ('signal',)
    params = (('p1', 5), ('p2', 30),)

    def __init__(self):
        sma1 = bt.indicators.SMA(period=self.p.p1)
        sma2 = bt.indicators.SMA(period=self.p.p2)
        self.lines.signal = sma1 - sma2

```

First run: long and short

```
$ ./signals-strategy.py --plot --signal longshort

```

The output

To notice:

The 
Signal
 is plotted. This is normal given it is simply an indicator and
    the plotting rules for it apply

The strategy is really 
long
 and 
short
. This can be seen because the

cash
 level never goes back to be the 
value
 level

Side note: even for a dumb idea … (and without commission) the strategy
    hasn’t lost money …

Second run: long only

```
$ ./signals-strategy.py --plot --signal longonly

```

The output

To notice:

Here the cash level goes back to be the 
value
 level after each 
sell
,
    which means the strategy is out of the market

Side note: Again no money has been lost …

Third run: short only

```
$ ./signals-strategy.py --plot --signal shortonly

```

The output

To notice:

The 1
st
 operation is a 
sell
 as expected and takes place later than the
    1
st
 operation in the 2 examples above. Not until the 
close
 is below
    the 
SMA
 and the simple substraction yields a minus

Here the cash level goes back to be the 
value
 level after each 
buy
,
    which means the strategy is out of the market

Side note: Finally the system loses money

Fourth run: long + longexit

```
$ ./signals-strategy.py --plot --signal longonly --exitsignal longexit

```

The output

To notice:

Many of the trades are the same, but some are interrupted earlier because
    the fast moving average in the 
exit
 signal crosses the slow moving average
    to the downside

The system shows its 
longonly
 property with the cash becoming the value
    at the end of each trade

Side note: Again money is made … even with some modified trades

Usage

```
$ ./signals-strategy.py --help
usage: signals-strategy.py [-h] [--data DATA] [--fromdate FROMDATE]
                           [--todate TODATE] [--cash CASH]
                           [--smaperiod SMAPERIOD] [--exitperiod EXITPERIOD]
                           [--signal {longshort,longonly,shortonly}]
                           [--exitsignal {longexit,shortexit}]
                           [--plot [kwargs]]

Sample for Signal concepts

optional arguments:
  -h, --help            show this help message and exit
  --data DATA           Specific data to be read in (default:
                        ../../datas/2005-2006-day-001.txt)
  --fromdate FROMDATE   Starting date in YYYY-MM-DD format (default: None)
  --todate TODATE       Ending date in YYYY-MM-DD format (default: None)
  --cash CASH           Cash to start with (default: 50000)
  --smaperiod SMAPERIOD
                        Period for the moving average (default: 30)
  --exitperiod EXITPERIOD
                        Period for the exit control SMA (default: 5)
  --signal {longshort,longonly,shortonly}
                        Signal type to use for the main signal (default:
                        longshort)
  --exitsignal {longexit,shortexit}
                        Signal type to use for the exit signal (default: None)
  --plot [kwargs], -p [kwargs]
                        Plot the read data applying any kwargs passed For
                        example: --plot style="candle" (to plot candles)
                        (default: None)

```

The code

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import collections
import datetime

import backtrader as bt

MAINSIGNALS = collections.OrderedDict(
    (('longshort', bt.SIGNAL_LONGSHORT),
     ('longonly', bt.SIGNAL_LONG),
     ('shortonly', bt.SIGNAL_SHORT),)
)

EXITSIGNALS = {
    'longexit': bt.SIGNAL_LONGEXIT,
    'shortexit': bt.SIGNAL_LONGEXIT,
}

class SMACloseSignal(bt.Indicator):
    lines = ('signal',)
    params = (('period', 30),)

    def __init__(self):
        self.lines.signal = self.data - bt.indicators.SMA(period=self.p.period)

class SMAExitSignal(bt.Indicator):
    lines = ('signal',)
    params = (('p1', 5), ('p2', 30),)

    def __init__(self):
        sma1 = bt.indicators.SMA(period=self.p.p1)
        sma2 = bt.indicators.SMA(period=self.p.p2)
        self.lines.signal = sma1 - sma2

def runstrat(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()
    cerebro.broker.set_cash(args.cash)

    dkwargs = dict()
    if args.fromdate is not None:
        fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')
        dkwargs['fromdate'] = fromdate

    if args.todate is not None:
        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')
        dkwargs['todate'] = todate

    # if dataset is None, args.data has been given
    data = bt.feeds.BacktraderCSVData(dataname=args.data, **dkwargs)
    cerebro.adddata(data)

    cerebro.add_signal(MAINSIGNALS[args.signal],
                       SMACloseSignal, period=args.smaperiod)

    if args.exitsignal is not None:
        cerebro.add_signal(EXITSIGNALS[args.exitsignal],
                           SMAExitSignal,
                           p1=args.exitperiod,
                           p2=args.smaperiod)

    cerebro.run()
    if args.plot:
        pkwargs = dict(style='bar')
        if args.plot is not True:  # evals to True but is not True
            npkwargs = eval('dict(' + args.plot + ')')  # args were passed
            pkwargs.update(npkwargs)

        cerebro.plot(**pkwargs)

def parse_args(pargs=None):

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Sample for Signal concepts')

    parser.add_argument('--data', required=False,
                        default='../../datas/2005-2006-day-001.txt',
                        help='Specific data to be read in')

    parser.add_argument('--fromdate', required=False, default=None,
                        help='Starting date in YYYY-MM-DD format')

    parser.add_argument('--todate', required=False, default=None,
                        help='Ending date in YYYY-MM-DD format')

    parser.add_argument('--cash', required=False, action='store',
                        type=float, default=50000,
                        help=('Cash to start with'))

    parser.add_argument('--smaperiod', required=False, action='store',
                        type=int, default=30,
                        help=('Period for the moving average'))

    parser.add_argument('--exitperiod', required=False, action='store',
                        type=int, default=5,
                        help=('Period for the exit control SMA'))

    parser.add_argument('--signal', required=False, action='store',
                        default=MAINSIGNALS.keys()[0], choices=MAINSIGNALS,
                        help=('Signal type to use for the main signal'))

    parser.add_argument('--exitsignal', required=False, action='store',
                        default=None, choices=EXITSIGNALS,
                        help=('Signal type to use for the exit signal'))

    # Plot options
    parser.add_argument('--plot', '-p', nargs='?', required=False,
                        metavar='kwargs', const=True,
                        help=('Plot the read data applying any kwargs passed\n'
                              '\n'
                              'For example:\n'
                              '\n'
                              '  --plot style="candle" (to plot candles)\n'))

    if pargs is not None:
        return parser.parse_args(pargs)

    return parser.parse_args()

if __name__ == '__main__':
    runstrat()

```
########################################
docu-sizers-reference.txt - lunghezza: 1291
########################################
Sizers Reference

FixedSize

class backtrader.sizers.FixedSize()

This sizer simply returns a fixed size for any operation.
Size can be controlled by number of tranches that a system
wishes to use to scale into trades by specifying the 
tranches

parameter.

Params:

```
* `stake` (default: `1`)

* `tranches` (default: `1`)

```

FixedReverser

class backtrader.sizers.FixedReverser()

This sizer returns the needes fixed size to reverse an open position or
the fixed size to open one

To open a position: return the param 
stake

To reverse a position: return 2 * 
stake

Params:

```
* `stake` (default: `1`)

```

PercentSizer

class backtrader.sizers.PercentSizer()

This sizer return percents of available cash

Params:

```
* `percents` (default: `20`)

```

AllInSizer

class backtrader.sizers.AllInSizer()

This sizer return all available cash of broker

Params:

```
* `percents` (default: `100`)

```

PercentSizerInt

class backtrader.sizers.PercentSizerInt()

This sizer return percents of available cash in form of size truncated
to an int

Params:

```
* `percents` (default: `20`)

```

AllInSizerInt

class backtrader.sizers.AllInSizerInt()

This sizer return all available cash of broker with the
size truncated to an int

Params:

```
  * `percents` (default: `100`)

```
########################################
docu-sizers-sizers.txt - lunghezza: 9327
########################################
Sizers

Smart Staking

A 
Strategy
 offers methods to trade, namely: 
buy
, 
sell
 and

close
. Let’s see the signature of 
buy
:

```
def buy(self, data=None,
        size=None, price=None, plimit=None,
        exectype=None, valid=None, tradeid=0, **kwargs):

```

Notice that 
size
 has a default value of 
None
 if the caller does not
specify it. This is where 
Sizers
 play an important role:

size=None
 requests that the 
Strategy
 asks its 
Sizer
 for the actual
    stake

This obviously implies that 
Strategies
 have a 
Sizer
: Yes, indeed!. The
background machinery adds a default sizer to a 
Strategy
 if the user has not
added one. The default 
Sizer
 added to a 
strategy
 is 
SizerFix
. The
initial lines of the definition:

```
class SizerFix(SizerBase):
    params = (('stake', 1),)

```

It is easy to guess that this 
Sizer
 simply 
buys/sells
 using a 
stake
 of

1
 units (be it shares, contracts, …)

Using 
Sizers

From 
Cerebro

Sizers
 can be added via 
Cerebro
 with 2 different methods:

addsizer(sizercls, *args, **kwargs)

Adds a 
Sizer
 that will be applied to any strategy added to

cerebro
. This is, so to to say, the default 
Sizer
. Example:

```
cerebro = bt.Cerebro()
cerebro.addsizer(bt.sizers.SizerFix, stake=20)  # default sizer for strategies

```

addsizer_byidx(idx, sizercls, *args, **kwargs)

The 
Sizer
 will only be added to the 
Strategy
 referenced by 
idx

This 
idx
 can be gotten as return value from 
addstrategy
. As in:

```
cerebro = bt.Cerebro()
cerebro.addsizer(bt.sizers.SizerFix, stake=20)  # default sizer for strategies

idx = cerebro.addstrategy(MyStrategy, myparam=myvalue)
cerebro.addsizer_byidx(idx, bt.sizers.SizerFix, stake=5)

cerebro.addstrategy(MyOtherStrategy)

```

In this example:

A default 
Sizer
 has been added to the system. This one applies to all
    strategies which don’t have a specific 
Sizer
 assigned

For 
MyStrategy
 and after collecting its insertion 
idx
, a specific
    sizer (changing the 
stake
 param) is added

A 2
nd
 strategy, 
MyOtherStrategy
, is added to the system. No specific

Sizer
 is added for it

This means that:

MyStrategy
 will finally have an internal specific 
Sizer

MyOtherStrategy
 will get the default sizer

Note

default
 doesn’t mean that that the strategies share a single

Sizer
 instance. Each 
strategy
 receives a different instance
of the 
default
 sizer

To share a single instance, the sizer to be shared should be a
singleton class. How to define one is outside of the scope of

backtrader

From 
Strategy

The 
Strategy
 class offers an API: 
setsizer
 and 
getsizer
 (and a

property

sizer
) to manage the 
Sizer
. The signatures:

def setsizer(self, sizer)
: it takes an already instantiated 
Sizer

def getsizer(self)
: returns the current 
Sizer
 instance

sizer
 it is the property which can be directly 
get/set

In this scenario the 
Sizer
 can be for example:

Passed to the strategy as a parameter

Be set during 
__init__
 using the property 
sizer
 or 
setsizer
 as
    in:

```
class MyStrategy(bt.Strategy):
    params = (('sizer', None),)

    def __init__(self):
        if self.p.sizer is not None:
            self.sizer = self.p.sizer

```

This would for example allow to create a 
Sizer
 at the same level as the

cerebro
 calls are happening and pass it as a parameter to all strategies
that go in the system, which effectevily allows sharing a 
Sizer

Sizer
 Development

Doing it is easy:

Subclass from 
backtrader.Sizer

This gives you access to 
self.strategy
 and 
self.broker
 although it
 shouldn’t be needed in most cases. Things that can be accessed with the

broker

data’s position with 
self.strategy.getposition(data)

complete portfolio value through 
self.broker.getvalue()

Notice this could of course also be done with

self.strategy.broker.getvalue()

Some of the other things are already below as arguments

Override the method 
_getsizing(self, comminfo, cash, data, isbuy)

comminfo
: The CommissionInfo instance that contains information
   about the commission for the data and allows calculation of position
   value, operation cost, commision for the operation

cash
: current available cash in the 
broker

data
: target of the operation

isbuy
: will be 
True
 for 
buy
 operations and 
False
 for

sell
 operations

This method returns the desired 
size
 for the 
buy/sell
 operation

The returned sign is not relevant, ie: if the operation is a 
sell

 operation (
isbuy
 will be 
False
) the method may return 
5
 or

-5
. Only the absolute value will be used by the 
sell
 operation.

Sizer
 has already gone to the 
broker
 and requested the

commission information
 for the given 
data
, the actual 
cash
 level and
 provides a direct reference to the 
data
 which is the target of the
 operation

Let’s go for the definition of the 
FixedSize
 sizer:

```
import backtrader as bt

class FixedSize(bt.Sizer):
    params = (('stake', 1),)

    def _getsizing(self, comminfo, cash, data, isbuy):
        return self.params.stake

```

This is pretty simple in that the 
Sizer
 makes no calculations and the
parameters are just there.

But the mechanism should allow the construction of complex 
sizing
 (aka

positioning
) systems to manage the stakes when entering/exiting the market.

Another example: 
A position rerverser
:

```
class FixedRerverser(bt.FixedSize):

    def _getsizing(self, comminfo, cash, data, isbuy):
        position = self.broker.getposition(data)
        size = self.p.stake * (1 + (position.size != 0))
        return size

```

This one builds on the existing 
FixedSize
 to inherit the 
params
 and
overrides 
_getsizing
 to:

Get the 
position
 of the 
data
 via the attribute 
broker

Use 
position.size
 to decide if to double the fixed stake

Return the calculated value

This would remove the burden from the 
Strategy
 to decide if a position has to
be reversed or opened, the 
Sizer
 is in control and can at any time be
replaced without affecting the logic.

Practical 
Sizer
 Applicability

Wihtout considering complex sizing algorithms, two different sizers can be
used to 
turn a strategy from Long-Only to Long-Short
. Simply by changing the

Sizer
 in the 
cerebro
 execution, the strategy will change behavior. A very
simple 
close
 crosses 
SMA
 algorithm:

```
class CloseSMA(bt.Strategy):
    params = (('period', 15),)

    def __init__(self):
        sma = bt.indicators.SMA(self.data, period=self.p.period)
        self.crossover = bt.indicators.CrossOver(self.data, sma)

    def next(self):
        if self.crossover > 0:
            self.buy()

        elif self.crossover < 0:
            self.sell()

```

Notice how the strategy doesn’t consider the current 
position
 (by looking at

self.position
) to decide whether a 
buy
 or 
sell
 has to actually be
done. Only the 
signal
 from the 
CrossOver
 is considered. The 
Sizers
 will
be in charge of everything.

This sizer will take care of only returning a 
non-zero
 size when selling if a
position is already open:

```
class LongOnly(bt.Sizer):
    params = (('stake', 1),)

    def _getsizing(self, comminfo, cash, data, isbuy):
      if isbuy:
          return self.p.stake

      # Sell situation
      position = self.broker.getposition(data)
      if not position.size:
          return 0  # do not sell if nothing is open

      return self.p.stake

```

Putting it all together (and assuming 
backtrader
 has already been imported
and a 
data
 has been added to the system):

```
...
cerebro.addstrategy(CloseSMA)
cerebro.addsizer(LongOnly)
...
cerebro.run()
...

```

The chart (from the sample included in the sources to test this).

The 
Long-Short
 version simply changes the 
Sizer
 to be the 
FixedReverser

shown above:

```
...
cerebro.addstrategy(CloseSMA)
cerebro.addsizer(FixedReverser)
...
cerebro.run()
...

```

The output chart.

Notice the differences:

The number of 
trades
 has duplicated

The cash level never goes back to be the 
value
 because the strategy is

always
 in the market

Both approaches are anyhow negative, but this is only an example.

bt.Sizer
 Reference

class backtrader.Sizer()

This is the base class for 
Sizers
. Any 
sizer
 should subclass this
and override the 
_getsizing
 method

Member Attribs:

strategy
: will be set by the strategy in which the sizer is working

Gives access to the entire api of the strategy, for example if the
actual data position would be needed in 
_getsizing
:

```
position = self.strategy.getposition(data)

```

broker
: will be set by the strategy in which the sizer is working

Gives access to information some complex sizers may need like portfolio
value, ..

_getsizing(comminfo, cash, data, isbuy)

This method has to be overriden by subclasses of Sizer to provide
the sizing functionality

Params:

```
* `comminfo`: The CommissionInfo instance that contains
  information about the commission for the data and allows
  calculation of position value, operation cost, commision for the
  operation

* `cash`: current available cash in the *broker*

* `data`: target of the operation

* `isbuy`: will be `True` for *buy* operations and `False`
  for *sell* operations

```

The method has to return the actual size (an int) to be executed. If

0
 is returned nothing will be executed.

The absolute value of the returned value will be used
########################################
docu-slippage-slippage.txt - lunghezza: 8277
########################################
Slippage

backtesting cannot guarantee real market conditions. No matter how good the
market simulation is, under real market conditions slippage can happen. That
means:

The requested price may not be matched.

The integrated backtesting broker supports slippage. The following parameters
can be passed to the broker

slip_perc
 (default: 
0.0
) Percentage in absolute termns (and
    positive) that should be used to slip prices up/down for buy/sell
    orders

Note:

0.01
 is 
1%

0.001
 is 
0.1%

slip_fixed
 (default: 
0.0
) Percentage in units (and positive)
    that should be used to slip prices up/down for buy/sell orders

Note: if 
slip_perc
 is non zero, it takes precendence over this.

slip_open
 (default: 
False
) whether to slip prices for order
    execution which would specifically used the 
opening
 price of the
    next bar. An example would be 
Market
 order which is executed with
    the next available tick, i.e: the opening price of the bar.

This also applies to some of the other executions, because the logic
tries to detect if the 
opening
 price would match the requested
price/execution type when moving to a new bar.

slip_match
 (default: 
True
)

If 
True
 the broker will offer a match by capping slippage at

high/low
 prices in case they would be exceeded.

If 
False
 the broker will not match the order with the current
prices and will try execution during the next iteration

slip_limit
 (default: 
True
)

Limit
 orders, given the exact match price requested, will be
matched even if 
slip_match
 is 
False
.

This option controls that behavior.

If 
True
, then 
Limit
 orders will be matched by capping prices
to the 
limit
 / 
high/low
 prices

If 
False
 and slippage exceeds the cap, then there will be no
match

slip_out
 (default: 
False
)

Provide 
slippage
 even if the price falls outside the 
high
 -

low
 range.

How it works

In order to decide when to apply 
slippage
 the order execution type is taken
into account:

Close
 - 
No slippage
 is applied

This order is matched against the 
close
 price and this price is the
last one of the day. Slippage cannot happen because the order can only
happen with the last tick of the session and this is a unique price with no
tolerance.

Market
 - 
Slippage
 is applied

Please check the 
slip_open
 exception. Because 
Market
 orders will be
matched against the 
opening
 price of the next bar.

Limit
 - 
Slippage
 is applied following this logic

If the matching price would be the 
opening
 price, then 
slippage
 is
  applied according to the parameter 
slip_open
. If applied, the price
  will never be worse than the requested 
limit
 price

If the matching price is not the 
limit
 price, 
slippage
 is applied
  capping at 
high/low
. In this case 
slip_mlimit
 applies to decide
  if a match will be happening in case the caps are exceeded

If the matching price is the 
limit
 price, then no slippage is applied

Stop
 - once the order is 
triggered
 the same logic as for 
Market

    orders apply

StopLimit
 - once the order is 
triggered
 the same logic as for

Limit
 orders apply

This approach tries to offer the most realistic possible approach within the
limits of the simulation and available data

Configuring slippage

A 
broker
 is already instantiated by a 
cerebro
 engine for each run with the
default parameters. There are two ways to alter the behavior:

Use methods to configure 
slippage

BackBroker.set_slippage_perc(perc, slip_open=True, slip_limit=True, slip_match=True, slip_out=False)

Configure slippage to be percentage based

BackBroker.set_slippage_fixed(fixed, slip_open=True, slip_limit=True, slip_match=True, slip_out=False)

Configure slippage to be fixed points based

Replace the broker as in:

```
import backtrader as bt

cerebro = bt.Cerebro()
cerebro.broker = bt.brokers.BackBroker(slip_perc=0.005)  # 0.5%

```

Practical examples

The sources contain a sample which uses the order execution type 
Market
 and
a 
long/short
 approach using 
signals
. This should allow to understand the
logic.

A run with no slippage and an initial plot for reference later:

```
$ ./slippage.py --plot
01 2005-03-22 23:59:59 SELL Size: -1 / Price: 3040.55
02 2005-04-11 23:59:59 BUY  Size: +1 / Price: 3088.47
03 2005-04-11 23:59:59 BUY  Size: +1 / Price: 3088.47
04 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38
05 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38
06 2005-05-19 23:59:59 BUY  Size: +1 / Price: 3034.88
...
35 2006-12-19 23:59:59 BUY  Size: +1 / Price: 4121.01

```

And the same run using 
slippage
 with a 
1.5%
 configured:

```
$ ./slippage.py --slip_perc 0.015
01 2005-03-22 23:59:59 SELL Size: -1 / Price: 3040.55
02 2005-04-11 23:59:59 BUY  Size: +1 / Price: 3088.47
03 2005-04-11 23:59:59 BUY  Size: +1 / Price: 3088.47
04 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38
05 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38
06 2005-05-19 23:59:59 BUY  Size: +1 / Price: 3034.88
...
35 2006-12-19 23:59:59 BUY  Size: +1 / Price: 4121.01

```

There is 
NO CHANGE
. This is the expected behavior for the scenario.

Execution Type: 
Market

And 
slip_open
 has not been set to 
True

The 
Market
 orders are matched against the 
opening
 price of the next
bar and we are not allowing the 
open
 price to be moved.

A run setting 
slip_open
 to 
True
:

```
$ ./slippage.py --slip_perc 0.015 --slip_open
01 2005-03-22 23:59:59 SELL Size: -1 / Price: 3021.66
02 2005-04-11 23:59:59 BUY  Size: +1 / Price: 3088.47
03 2005-04-11 23:59:59 BUY  Size: +1 / Price: 3088.47
04 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38
05 2005-04-19 23:59:59 SELL Size: -1 / Price: 2948.38
06 2005-05-19 23:59:59 BUY  Size: +1 / Price: 3055.14
...
35 2006-12-19 23:59:59 BUY  Size: +1 / Price: 4121.01

```

And one can immediately see tht the prices 
HAVE MOVED
. And the allocated
prices are worst or equal like for operation 35. 
This is not a copy and paste error

The 
open
 and the 
high
 on 20016-12-19 were the same.

The price cannot be pushed above the 
high
 because that would mean
returning a non-existent price.

Of course, 
backtrader
 allows to match outide the 
high
 - 
low
 range if
wished with 
slip_out
. A run with it activated:

```
$ ./slippage.py --slip_perc 0.015 --slip_open --slip_out
01 2005-03-22 23:59:59 SELL Size: -1 / Price: 2994.94
02 2005-04-11 23:59:59 BUY  Size: +1 / Price: 3134.80
03 2005-04-11 23:59:59 BUY  Size: +1 / Price: 3134.80
04 2005-04-19 23:59:59 SELL Size: -1 / Price: 2904.15
05 2005-04-19 23:59:59 SELL Size: -1 / Price: 2904.15
06 2005-05-19 23:59:59 BUY  Size: +1 / Price: 3080.40
...
35 2006-12-19 23:59:59 BUY  Size: +1 / Price: 4182.83

```

A matching expression for the matched prices would be: OMG! (Oh My God!). The
prices are clearly outside of the range. Suffice to look at operation 35, which
has been matched at 
4182.83
. A quick inspection of the chart in this
document shows that the asset never came close to that price.

slip_match
 has a default of 
True
 and that means that 
backtrader

offers a match, be it with capped or uncapped prices as seen above. Let’s
disable it:

```
$ ./slippage.py --slip_perc 0.015 --slip_open --no-slip_match
01 2005-04-15 23:59:59 SELL Size: -1 / Price: 3028.10
02 2005-05-18 23:59:59 BUY  Size: +1 / Price: 3029.40
03 2005-06-01 23:59:59 BUY  Size: +1 / Price: 3124.03
04 2005-10-06 23:59:59 SELL Size: -1 / Price: 3365.57
05 2005-10-06 23:59:59 SELL Size: -1 / Price: 3365.57
06 2005-12-01 23:59:59 BUY  Size: +1 / Price: 3499.95
07 2005-12-01 23:59:59 BUY  Size: +1 / Price: 3499.95
08 2006-02-28 23:59:59 SELL Size: -1 / Price: 3782.71
09 2006-02-28 23:59:59 SELL Size: -1 / Price: 3782.71
10 2006-05-23 23:59:59 BUY  Size: +1 / Price: 3594.68
11 2006-05-23 23:59:59 BUY  Size: +1 / Price: 3594.68
12 2006-11-27 23:59:59 SELL Size: -1 / Price: 3984.37
13 2006-11-27 23:59:59 SELL Size: -1 / Price: 3984.37

```

Blistering barnacles! Down to 13 from 35. The rationale:

Deactivating 
slip_match
 disallows matching operations if 
slippage
 would
  push the matching price above the 
high
 or below the 
low
 of the
  bar. It seems that with the 
1.5%
 of requested 
slippage
, around 22 of
  the operations fail to be executed.

The examples should have shown how the different 
slippage
 options work together.
########################################
docu-strategy-reference.txt - lunghezza: 2990
########################################
Strategies Reference

Reference for the built-in strategies

MA_CrossOver

Alias:

```
* SMA_CrossOver

```

This is a long-only strategy which operates on a moving average cross

Note:

```
* Although the default

```

Buy Logic:

```
* No position is open on the data

* The `fast` moving averagecrosses over the `slow` strategy to the
  upside.

```

Sell Logic:

```
* A position exists on the data

* The `fast` moving average crosses over the `slow` strategy to the
  downside

```

Order Execution Type:

```
* Market

```

Lines:

```
* datetime

```

Params:

```
* fast (10)

* slow (30)

* _movav (<class ‘backtrader.indicators.sma.SMA’>)

```

SignalStrategy

This subclass of 
Strategy
 is meant to to auto-operate using

signals
.

Signals
 are usually indicators and the expected output values:

> 0
 is a 
long
 indication

< 0
 is a 
short
 indication

There are 5 types of 
Signals
, broken in 2 groups.

Main Group
:

LONGSHORT
: both 
long
 and 
short
 indications from this signal
    are taken

LONG
:

long
 indications are taken to go long

short
 indications are taken to 
close
 the long position. But:

If a 
LONGEXIT
 (see below) signal is in the system it will be
    used to exit the long

If a 
SHORT
 signal is available and no 
LONGEXIT
 is available
    , it will be used to close a 
long
 before opening a 
short

SHORT
:

short
 indications are taken to go short

long
 indications are taken to 
close
 the short position. But:

If a 
SHORTEXIT
 (see below) signal is in the system it will be
    used to exit the short

If a 
LONG
 signal is available and no 
SHORTEXIT
 is available
    , it will be used to close a 
short
 before opening a 
long

Exit Group
:

This 2 signals are meant to override others and provide criteria for
  exitins a 
long
/
short
 position

LONGEXIT
: 
short
 indications are taken to exit 
long

    positions

SHORTEXIT
: 
long
 indications are taken to exit 
short

    positions

Order Issuing

Orders execution type is 
Market
 and validity is 
None
 (
Good until
  Canceled
)

Params:

signals
 (default: 
[]
): a list/tuple of lists/tuples that allows
    the instantiation of the signals and allocation to the right type

This parameter is expected to be managed through 
cerebro.add_signal

_accumulate
 (default: 
False
): allow to enter the market
    (long/short) even if already in the market

_concurrent
 (default: 
False
): allow orders to be issued even if
    orders are already pending execution

_data
 (default: 
None
): if multiple datas are present in the
    system which is the target for orders. This can be

None
: The first data in the system will be used

An 
int
: indicating the data that was inserted at that position

An 
str
: name given to the data when creating it (parameter

name
) or when adding it cerebro with 
cerebro.adddata(...,
  name=)

A 
data
 instance

Lines:

```
* datetime

```

Params:

```
* signals ([])

* _accumulate (False)

* _concurrent (False)

* _data (None)

```
########################################
docu-strategy.txt - lunghezza: 27784
########################################
Strategy

A 
Cerebro
 instance is the pumping heart and controlling brain of

backtrader
. A 
Strategy
 is the same for the platform user.

The 
Strategy’s
 expressed lifecycle in methods

Note

A strategy can be interrupted during 
birth
 by raising a

StrategySkipError
 exception from the module 
backtrader.errors

This will avoid going through the strategy during a backtesting. See
the section 
Exceptions

Conception: 
__init__

This is obviously invoked during instantiation: 
indicators
 will be
 created here and other needed attribute. Example:

```
def __init__(self):
    self.sma = btind.SimpleMovingAverage(period=15)

```

Birth: 
start

The world (
cerebro
) tells the strategy is time to start kicking. A
 default empty method exists.

Childhood: 
prenext

indicators
 declared during conception will have put constraints on how
 long the strategy needs to mature: this is called the 
minimum
 period
. Above 
__init__
 created a 
SimpleMovingAverage
 with a

period=15
.

As long as the system has seen less than 
15
 bars, 
prenext
 will be
 called (the default implementation is a no-op)

Adulthood: 
next

Once the system has seen 
15
 bars and the 
SimpleMovingAverage
 has a
 buffer large enough to start producing values, the strategy is mature
 enough to really execute.

There is a 
nextstart
 method which is called exactly 
once
, to mark
 the switch from 
prenext
 to 
next
. The default implementation of

nextstart
 is to simply call 
next

Reproduction: 
None

Ok, strategies do not really reproduce. But in a sense they do, because
 the system will instantiate them several times if 
optimizing
 (with
 different parameters)

Death: 
stop

The system tells the strategy the time to come to a reset and put things
 in order has come. A default empty method exists.

In most cases and for regular usage patterns this will look like:

```
class MyStrategy(bt.Strategy):

    def __init__(self):
        self.sma = btind.SimpleMovingAverage(period=15)

    def next(self):
        if self.sma > self.data.close:
            # Do something
            pass

        elif self.sma < self.data.close:
            # Do something else
            pass

```

In this snippet:

During 
__init__
 an attribute is assigned an indicator

The default empty 
start
 method is not overriden

prenext
 and 
nexstart
 are not overriden

In 
next
 the value of the indicator is compared against the closing
    price to do something

The default empty 
stop
 method is not overriden

Strategies, like a trader in the real world, will get notified when events take
place. Actually once per 
next
 cycle in the backtesting process. The
strategy will:

be notified through 
notify_order(order)
 of any status change in an
    order

be notified through 
notify_trade(trade)
 of any
    opening/updating/closing trade

be notified through 
notify_cashvalue(cash, value)
 of the current cash
    and portfolio in the broker

be notified through 
notify_fund(cash, value, fundvalue, shares)
 of the
    current cash and portfolio in the broker and tradking of fundvalue and
    shares

Events (implementation specific) via 
notify_store(msg, *args, **kwargs)

See Cerebro for an explanation on the 
store
 notifications. These
will delivered to the strategy even if they have also been delivered to a

cerebro
 instance (with an overriden 
notify_store
 method or via a

callback
)

And 
Strategies
 also like traders have the chance to operate in the market
during the 
next
 method to try to achieve profit with

the 
buy
 method to go long or reduce/close a short position

the 
sell
 method to go short or reduce/close a long position

the 
close
 method to obviously close an existing position

the 
cancel
 method to cancel a not yet executed order

How to Buy/Sell/Close

The 
Buy
 and 
Sell
 methods generate orders. When invoked they return an

Order
 (or subclass) instance that can be used as a reference. This order
has a unique 
ref
 identifier that can be used for comparison

Note

Subclasses of 
Order
 for speficic broker implementations may carry
additional 
unique identifiers
 provided by the broker.

To create the order use the following parameters:

data
 (default: 
None
)

For which data the order has to be created. If 
None
 then the
first data in the system, 
self.datas[0] or self.data0
 (aka

self.data
) will be used

size
 (default: 
None
)

Size to use (positive) of units of data to use for the order.

If 
None
 the 
sizer
 instance retrieved via 
getsizer
 will
be used to determine the size.

price
 (default: 
None
)

Price to use (live brokers may place restrictions on the actual
format if it does not comply to minimum tick size requirements)

None
 is valid for 
Market
 and 
Close
 orders (the market
determines the price)

For 
Limit
, 
Stop
 and 
StopLimit
 orders this value
determines the trigger point (in the case of 
Limit
 the trigger
is obviously at which price the order should be matched)

plimit
 (default: 
None
)

Only applicable to 
StopLimit
 orders. This is the price at which
to set the implicit 
Limit
 order, once the 
Stop
 has been
triggered (for which 
price
 has been used)

exectype
 (default: 
None
)

Possible values:

Order.Market
 or 
None
. A market order will be executed
  with the next available price. In backtesting it will be the
  opening price of the next bar

Order.Limit
. An order which can only be executed at the given

price
 or better

Order.Stop
. An order which is triggered at 
price
 and
  executed like an 
Order.Market
 order

Order.StopLimit
. An order which is triggered at 
price
 and
  executed as an implicit 
Limit
 order with price given by

pricelimit

valid
 (default: 
None
)

Possible values:

None
: this generates an order that will not expire (aka

Good til cancel
) and remain in the market until matched or
    canceled. In reality brokers tend to impose a temporal limit,
    but this is usually so far away in time to consider it as not
    expiring

datetime.datetime
 or 
datetime.date
 instance: the date
    will be used to generate an order valid until the given
    datetime (aka 
good til date
)

Order.DAY
 or 
0
 or 
timedelta()
: a day valid until
    the 
End of the Session
 (aka 
day
 order) will be generated

numeric value
: This is assumed to be a value corresponding
    to a datetime in 
matplotlib
 coding (the one used by

backtrader
) and will used to generate an order valid until
    that time (
good til date
)

tradeid
 (default: 
0
)

This is an internal value applied by 
backtrader
 to keep track
of overlapping trades on the same asset. This 
tradeid
 is sent
back to the 
strategy
 when notifying changes to the status of the
orders.

**kwargs
: additional broker implementations may support extra
    parameters. 
backtrader
 will pass the 
kwargs
 down to the
    created order objects

Example: if the 4 order execution types directly supported by

backtrader
 are not enough, in the case of for example

Interactive Brokers
 the following could be passed as 
kwargs
:

```
orderType='LIT', lmtPrice=10.0, auxPrice=9.8

```

This would override the settings created by 
backtrader
 and
generate a 
LIMIT IF TOUCHED
 order with a 
touched
 price of 9.8
and a 
limit
 price of 10.0.

Information Bits:

A Strategy has a 
length
 which is always equal to that of the main
    data (
datas[0]
) and can of course be gotten with 
len(self)

next
 can be called without changes in 
length
 if data is being
replayed or a live feed is being passed and new ticks for the same
point in time (length) are arriving

Member Attributes:

env
: the cerebro entity in which this Strategy lives

datas
: array of data feeds which have been passed to cerebro

data/data0
 is an alias for datas[0]

dataX
 is an alias for datas[X]

data feeds
 can also be accessed by name (see the reference) if one has been
assigned to it

dnames
: an alternative to reach the data feeds by name (either with

[name]
 or with 
.name
 notation)

For example if resampling a data like this:

```
...
data0 = bt.feeds.YahooFinanceData(datname='YHOO', fromdate=..., name='days')
cerebro.adddata(data0)
cerebro.resampledata(data0, timeframe=bt.TimeFrame.Weeks, name='weeks')
...

```

Later in the strategy one can create indicators on each like this:

```
...
smadays = bt.ind.SMA(self.dnames.days, period=30)  # or self.dnames['days']
smaweeks = bt.ind.SMA(self.dnames.weeks, period=10)  # or self.dnames['weeks']
...

```

broker
: reference to the broker associated to this strategy
    (received from cerebro)

stats
: list/named tuple-like sequence holding the Observers created by
    cerebro for this strategy

analyzers
: list/named tuple-like sequence holding the Analyzers created
    by cerebro for this strategy

position
: actually a property which gives the current position for

data0
.

Methods to retrieve all possitions are available (see the reference)

Member Attributes (meant for statistics/observers/analyzers):

_orderspending
: list of orders which will be notified to the
    strategy before 
next
 is called

_tradespending
: list of trades which will be notified to the
    strategy before 
next
 is called

_orders
: list of order which have been already notified. An order
    can be several times in the list with different statuses and different
    execution bits. The list is menat to keep the history.

_trades
: list of order which have been already notified. A trade
    can be several times in the list just like an order.

Note

Bear in mind that 
prenext
, 
nextstart
 and 
next
 can be called several
times for the same point in time (ticks updating prices for the daily bar,
when a daily timeframe is in use)

Reference: Strategy

class backtrader.Strategy(*args, **kwargs)

Base class to be subclassed for user defined strategies.

next()

This method will be called for all remaining data points when the
minimum period for all datas/indicators have been meet.

nextstart()

This method will be called once, exactly when the minimum period for
all datas/indicators have been meet. The default behavior is to call
next

prenext()

This method will be called before the minimum period of all
datas/indicators have been meet for the strategy to start executing

start()

Called right before the backtesting is about to be started.

stop()

Called right before the backtesting is about to be stopped

notify_order(order)

Receives an order whenever there has been a change in one

notify_trade(trade)

Receives a trade whenever there has been a change in one

notify_cashvalue(cash, value)

Receives the current fund value, value status of the strategy’s broker

notify_fund(cash, value, fundvalue, shares)

Receives the current cash, value, fundvalue and fund shares

notify_store(msg, *args, **kwargs)

Receives a notification from a store provider

buy(data=None, size=None, price=None, plimit=None, exectype=None, valid=None, tradeid=0, oco=None, trailamount=None, trailpercent=None, parent=None, transmit=True, **kwargs)

Create a buy (long) order and send it to the broker

data
 (default: 
None
)

For which data the order has to be created. If 
None
 then the
first data in the system, 
self.datas[0] or self.data0
 (aka

self.data
) will be used

size
 (default: 
None
)

Size to use (positive) of units of data to use for the order.

If 
None
 the 
sizer
 instance retrieved via 
getsizer
 will
be used to determine the size.

price
 (default: 
None
)

Price to use (live brokers may place restrictions on the actual
format if it does not comply to minimum tick size requirements)

None
 is valid for 
Market
 and 
Close
 orders (the market
determines the price)

For 
Limit
, 
Stop
 and 
StopLimit
 orders this value
determines the trigger point (in the case of 
Limit
 the trigger
is obviously at which price the order should be matched)

plimit
 (default: 
None
)

Only applicable to 
StopLimit
 orders. This is the price at which
to set the implicit 
Limit
 order, once the 
Stop
 has been
triggered (for which 
price
 has been used)

trailamount
 (default: 
None
)

If the order type is StopTrail or StopTrailLimit, this is an
absolute amount which determines the distance to the price (below
for a Sell order and above for a buy order) to keep the trailing
stop

trailpercent
 (default: 
None
)

If the order type is StopTrail or StopTrailLimit, this is a
percentage amount which determines the distance to the price (below
for a Sell order and above for a buy order) to keep the trailing
stop (if 
trailamount
 is also specified it will be used)

exectype
 (default: 
None
)

Possible values:

Order.Market
 or 
None
. A market order will be executed
  with the next available price. In backtesting it will be the
  opening price of the next bar

Order.Limit
. An order which can only be executed at the given

price
 or better

Order.Stop
. An order which is triggered at 
price
 and
  executed like an 
Order.Market
 order

Order.StopLimit
. An order which is triggered at 
price
 and
  executed as an implicit 
Limit
 order with price given by

pricelimit

Order.Close
. An order which can only be executed with the
  closing price of the session (usually during a closing auction)

Order.StopTrail
. An order which is triggered at 
price

  minus 
trailamount
 (or 
trailpercent
) and which is updated
  if the price moves away from the stop

Order.StopTrailLimit
. An order which is triggered at

price
 minus 
trailamount
 (or 
trailpercent
) and which
  is updated if the price moves away from the stop

valid
 (default: 
None
)

Possible values:

None
: this generates an order that will not expire (aka

Good till cancel
) and remain in the market until matched or
    canceled. In reality brokers tend to impose a temporal limit,
    but this is usually so far away in time to consider it as not
    expiring

datetime.datetime
 or 
datetime.date
 instance: the date
    will be used to generate an order valid until the given
    datetime (aka 
good till date
)

Order.DAY
 or 
0
 or 
timedelta()
: a day valid until
    the 
End of the Session
 (aka 
day
 order) will be generated

numeric value
: This is assumed to be a value corresponding
    to a datetime in 
matplotlib
 coding (the one used by

backtrader
) and will used to generate an order valid until
    that time (
good till date
)

tradeid
 (default: 
0
)

This is an internal value applied by 
backtrader
 to keep track
of overlapping trades on the same asset. This 
tradeid
 is sent
back to the 
strategy
 when notifying changes to the status of the
orders.

oco
 (default: 
None
)

Another 
order
 instance. This order will become part of an OCO
(Order Cancel Others) group. The execution of one of the orders,
immediately cancels all others in the same group

parent
 (default: 
None
)

Controls the relationship of a group of orders, for example a buy
which is bracketed by a high-side limit sell and a low side stop
sell. The high/low side orders remain inactive until the parent
order has been either executed (they become active) or is
canceled/expires (the children are also canceled) bracket orders
have the same size

transmit
 (default: 
True
)

Indicates if the order has to be 
transmitted
, ie: not only
placed in the broker but also issued. This is meant for example to
control bracket orders, in which one disables the transmission for
the parent and 1
st
 set of children and activates it for the last
children, which triggers the full placement of all bracket orders.

**kwargs
: additional broker implementations may support extra
    parameters. 
backtrader
 will pass the 
kwargs
 down to the
    created order objects

Example: if the 4 order execution types directly supported by

backtrader
 are not enough, in the case of for example

Interactive Brokers
 the following could be passed as 
kwargs
:

```
orderType='LIT', lmtPrice=10.0, auxPrice=9.8

```

This would override the settings created by 
backtrader
 and
generate a 
LIMIT IF TOUCHED
 order with a 
touched
 price of 9.8
and a 
limit
 price of 10.0.

Returns

the submitted order

sell(data=None, size=None, price=None, plimit=None, exectype=None, valid=None, tradeid=0, oco=None, trailamount=None, trailpercent=None, parent=None, transmit=True, **kwargs)

To create a selll (short) order and send it to the broker

See the documentation for 
buy
 for an explanation of the parameters

Returns: the submitted order

close(data=None, size=None, **kwargs)

Counters a long/short position closing it

See the documentation for 
buy
 for an explanation of the parameters

Note

size
: automatically calculated from the existing position if
    not provided (default: 
None
) by the caller

Returns: the submitted order

cancel(order)

Cancels the order in the broker

buy_bracket(data=None, size=None, price=None, plimit=None, exectype=2, valid=None, tradeid=0, trailamount=None, trailpercent=None, oargs={}, stopprice=None, stopexec=3, stopargs={}, limitprice=None, limitexec=2, limitargs={}, **kwargs)

Create a bracket order group (low side - buy order - high side). The
default behavior is as follows:

Issue a 
buy
 order with execution 
Limit

Issue a 
low side
 bracket 
sell
 order with execution 
Stop

Issue a 
high side
 bracket 
sell
 order with execution

Limit
.

See below for the different parameters

data
 (default: 
None
)

For which data the order has to be created. If 
None
 then the
first data in the system, 
self.datas[0] or self.data0
 (aka

self.data
) will be used

size
 (default: 
None
)

Size to use (positive) of units of data to use for the order.

If 
None
 the 
sizer
 instance retrieved via 
getsizer
 will
be used to determine the size.

Note

The same size is applied to all 3 orders of the bracket

price
 (default: 
None
)

Price to use (live brokers may place restrictions on the actual
format if it does not comply to minimum tick size requirements)

None
 is valid for 
Market
 and 
Close
 orders (the market
determines the price)

For 
Limit
, 
Stop
 and 
StopLimit
 orders this value
determines the trigger point (in the case of 
Limit
 the trigger
is obviously at which price the order should be matched)

plimit
 (default: 
None
)

Only applicable to 
StopLimit
 orders. This is the price at which
to set the implicit 
Limit
 order, once the 
Stop
 has been
triggered (for which 
price
 has been used)

trailamount
 (default: 
None
)

If the order type is StopTrail or StopTrailLimit, this is an
absolute amount which determines the distance to the price (below
for a Sell order and above for a buy order) to keep the trailing
stop

trailpercent
 (default: 
None
)

If the order type is StopTrail or StopTrailLimit, this is a
percentage amount which determines the distance to the price (below
for a Sell order and above for a buy order) to keep the trailing
stop (if 
trailamount
 is also specified it will be used)

exectype
 (default: 
bt.Order.Limit
)

Possible values: (see the documentation for the method 
buy

valid
 (default: 
None
)

Possible values: (see the documentation for the method 
buy

tradeid
 (default: 
0
)

Possible values: (see the documentation for the method 
buy

oargs
 (default: 
{}
)

Specific keyword arguments (in a 
dict
) to pass to the main side
order. Arguments from the default 
**kwargs
 will be applied on
top of this.

**kwargs
: additional broker implementations may support extra
    parameters. 
backtrader
 will pass the 
kwargs
 down to the
    created order objects

Possible values: (see the documentation for the method 
buy

Note

This 
kwargs
 will be applied to the 3 orders of a
bracket. See below for specific keyword arguments for the low and
high side orders

stopprice
 (default: 
None
)

Specific price for the 
low side
 stop order

stopexec
 (default: 
bt.Order.Stop
)

Specific execution type for the 
low side
 order

stopargs
 (default: 
{}
)

Specific keyword arguments (in a 
dict
) to pass to the low side
order. Arguments from the default 
**kwargs
 will be applied on
top of this.

limitprice
 (default: 
None
)

Specific price for the 
high side
 stop order

stopexec
 (default: 
bt.Order.Limit
)

Specific execution type for the 
high side
 order

limitargs
 (default: 
{}
)

Specific keyword arguments (in a 
dict
) to pass to the high side
order. Arguments from the default 
**kwargs
 will be applied on
top of this.

High/Low Side orders can be suppressed by using:

limitexec=None
 to suppress the 
high side

stopexec=None
 to suppress the 
low side

Returns

A list containing the 3 orders [order, stop side, limit side]

If high/low orders have been suppressed the return value will still
  contain 3 orders, but those suppressed will have a value of

None

sell_bracket(data=None, size=None, price=None, plimit=None, exectype=2, valid=None, tradeid=0, trailamount=None, trailpercent=None, oargs={}, stopprice=None, stopexec=3, stopargs={}, limitprice=None, limitexec=2, limitargs={}, **kwargs)

Create a bracket order group (low side - buy order - high side). The
default behavior is as follows:

Issue a 
sell
 order with execution 
Limit

Issue a 
high side
 bracket 
buy
 order with execution 
Stop

Issue a 
low side
 bracket 
buy
 order with execution 
Limit
.

See 
bracket_buy
 for the meaning of the parameters

High/Low Side orders can be suppressed by using:

stopexec=None
 to suppress the 
high side

limitexec=None
 to suppress the 
low side

Returns

A list containing the 3 orders [order, stop side, limit side]

If high/low orders have been suppressed the return value will still
  contain 3 orders, but those suppressed will have a value of

None

order_target_size(data=None, target=0, **kwargs)

Place an order to rebalance a position to have final size of 
target

The current 
position
 size is taken into account as the start point
to achieve 
target

If 
target
 > 
pos.size
 -> buy 
target - pos.size

If 
target
 < 
pos.size
 -> sell 
pos.size - target

It returns either:

The generated order

or

None
 if no order has been issued (
target == position.size
)

order_target_value(data=None, target=0.0, price=None, **kwargs)

Place an order to rebalance a position to have final value of

target

The current 
value
 is taken into account as the start point to
achieve 
target

If no 
target
 then close postion on data

If 
target
 > 
value
 then buy on data

If 
target
 < 
value
 then sell on data

It returns either:

The generated order

or

None
 if no order has been issued

order_target_percent(data=None, target=0.0, **kwargs)

Place an order to rebalance a position to have final value of

target
 percentage of current portfolio 
value

target
 is expressed in decimal: 
0.05
 -> 
5%

It uses 
order_target_value
 to execute the order.

Example

target=0.05
 and portfolio value is 
100

The 
value
 to be reached is 
0.05 * 100 = 5

5
 is passed as the 
target
 value to 
order_target_value

The current 
value
 is taken into account as the start point to
achieve 
target

The 
position.size
 is used to determine if a position is 
long
 /

short

If 
target
 > 
value

buy if 
pos.size >= 0
 (Increase a long position)

sell if 
pos.size < 0
 (Increase a short position)

If 
target
 < 
value

sell if 
pos.size >= 0
 (Decrease a long position)

buy if 
pos.size < 0
 (Decrease a short position)

It returns either:

The generated order

or

None
 if no order has been issued (
target == position.size
)

getsizer()

Returns the sizer which is in used if automatic statke calculation is
used

Also available as 
sizer

setsizer(sizer)

Replace the default (fixed stake) sizer

getsizing(data=None, isbuy=True)

Return the stake calculated by the sizer instance for the current
situation

getposition(data=None, broker=None)

Returns the current position for a given data in a given broker.

If both are None, the main data and the default broker will be used

A property 
position
 is also available

getpositionbyname(name=None, broker=None)

Returns the current position for a given name in a given broker.

If both are None, the main data and the default broker will be used

A property 
positionbyname
 is also available

getpositionsbyname(broker=None)

Returns the current by name positions directly from the broker

If the given 
broker
 is None, the default broker will be used

A property 
positionsbyname
 is also available

getdatanames()

Returns a list of the existing data names

getdatabyname(name)

Returns a given data by name using the environment (cerebro)

add_timer(when, offset=datetime.timedelta(0), repeat=datetime.timedelta(0), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None, cheat=False, *args, **kwargs)

Note

Can be called during 
__init__
 or 
start

Schedules a timer to invoke either a specified callback or the

notify_timer
 of one or more strategies.

Parameters

when
 (
-
) – can be

datetime.time
 instance (see below 
tzdata
)

bt.timer.SESSION_START
 to reference a session start

bt.timer.SESSION_END
 to reference a session end

offset
 which must be a 
datetime.timedelta
 instance

Used to offset the value 
when
. It has a meaningful use in
  combination with 
SESSION_START
 and 
SESSION_END
, to indicated
  things like a timer being called 
15 minutes
 after the session
  start.

repeat
 which must be a 
datetime.timedelta
 instance

Indicates if after a 1
st
 call, further calls will be scheduled
within the same session at the scheduled 
repeat
 delta

Once the timer goes over the end of the session it is reset to the
original value for 
when

weekdays
: a 
sorted
 iterable with integers indicating on
    which days (iso codes, Monday is 1, Sunday is 7) the timers can
    be actually invoked

If not specified, the timer will be active on all days

weekcarry
 (default: 
False
). If 
True
 and the weekday was
    not seen (ex: trading holiday), the timer will be executed on the
    next day (even if in a new week)

monthdays
: a 
sorted
 iterable with integers indicating on
    which days of the month a timer has to be executed. For example
    always on day 
15
 of the month

If not specified, the timer will be active on all days

monthcarry
 (default: 
True
). If the day was not seen
    (weekend, trading holiday), the timer will be executed on the next
    available day.

allow
 (default: 
None
). A callback which receives a
    datetime.date` instance and returns 
True
 if the date is
    allowed for timers or else returns 
False

tzdata
 which can be either 
None
 (default), a 
pytz

    instance or a 
data feed
 instance.

None
: 
when
 is interpreted at face value (which translates
to handling it as if it where UTC even if it’s not)

pytz
 instance: 
when
 will be interpreted as being specified
in the local time specified by the timezone instance.

data feed
 instance: 
when
 will be interpreted as being
specified in the local time specified by the 
tz
 parameter of
the data feed instance.

Note

If 
when
 is either 
SESSION_START
 or 
SESSION_END
 and 
tzdata

is 
None
, the 1
st

data feed
 in the system (aka 
self.data0
)
will be used as the reference to find out the session times.

cheat
 (default 
False
) if 
True
 the timer will be called
    before the broker has a chance to evaluate the orders. This opens
    the chance to issue orders based on opening price for example right
    before the session starts

*args
: any extra args will be passed to 
notify_timer

**kwargs
: any extra kwargs will be passed to 
notify_timer

Return Value:

The created timer

notify_timer(timer, when, *args, **kwargs)

Receives a timer notification where 
timer
 is the timer which was
returned by 
add_timer
, and 
when
 is the calling time. 
args

and 
kwargs
 are any additional arguments passed to 
add_timer

The actual 
when
 time can be later, but the system may have not be
able to call the timer before. This value is the timer value and no the
system time.
########################################
docu-talib-talib.txt - lunghezza: 14370
########################################
TA-Lib

Even if 
backtrader
 offers an already high number of built-in indicators and
developing an indicator is mostly a matter of defining the inputs, outputs and
writing the formula in a natural manner, some people want to use 
TA-LIB
. Some
of the reasons:

Indicator 
X
 is in the library and not in 
backtrader
 (the author would
    gladly accept a request)

TA-LIB
 behavior is well known and people trust good old things

In order to satisfy each and every taste, 
TA-LIB
 integration is offered.

Requirements

Python wrapper for TA-Lib

Any dependencies needed by it (for example 
numpy
)

The installation details are on the 
GitHub
 repository

Using 
ta-lib

As easy as using any of the indicators already built-in in

backtrader
. Example of a 
Simple Moving Average
. First the 
backtrader

one:

```
import backtrader as bt

class MyStrategy(bt.Strategy):
    params = (('period', 20),)

    def __init__(self):
        self.sma = bt.indicators.SMA(self.data, period=self.p.period)
        ...

...

```

Now the 
ta-lib
 example:

```
import backtrader as bt

class MyStrategy(bt.Strategy):
    params = (('period', 20),)

    def __init__(self):
        self.sma = bt.talib.SMA(self.data, timeperiod=self.p.period)
        ...

...

```

Et voilá! Of course the 
params
 for the 
ta-lib
 indicators are defined by the
library itself and not by 
backtrader
. In this case the 
SMA
 in 
ta-lib

takes a parameter named 
timeperiod
 to defined the size of the operating
window.

For indicators that require more than one input, for example the 
Stochastic
:

```
import backtrader as bt

class MyStrategy(bt.Strategy):
    params = (('period', 20),)

    def __init__(self):
        self.stoc = bt.talib.STOCH(self.data.high, self.data.low, self.data.close,
                                   fastk_period=14, slowk_period=3, slowd_period=3)

        ...

...

```

Notice how 
high
, 
low
 and 
close
 have been individually passed. One
could always pass 
open
 instead of 
low
 (or any other data series) and
experiment.

The 
ta-lib
 indicator documentation is automatically parsed and added to the

backtrader
 docs. You may also check the 
ta-lib
 source code/docs. Or
adittionally do:

```
print(bt.talib.SMA.__doc__)

```

Which in this case outputs:

```
SMA([input_arrays], [timeperiod=30])

Simple Moving Average (Overlap Studies)

Inputs:
    price: (any ndarray)
Parameters:
    timeperiod: 30
Outputs:
    real

```

Which offers some information:

Which 
Input
 is to be expected (
DISREGARD the ``ndarray`` comment
 because
    backtrader manages the conversions in the background)

Which 
parameters
 and which default values

Which output 
lines
 the indicator actually offers

Moving Averages and MA_Type

To select a specific 
moving average
 for indicators like 
bt.talib.STOCH
,
the standard 
ta-lib

MA_Type
 is accesible with

backtrader.talib.MA_Type
. For example:

```
import backtrader as bt
print('SMA:', bt.talib.MA_Type.SMA)
print('T3:', bt.talib.MA_Type.T3)

```

Plotting ta-lib indicators

Just as with regular usage, there is nothing special to do to plot the 
ta-lib

indicators.

Note

Indicators which output a 
CANDLE
 (all those looking for a
candlestick pattern) deliver a binary output: either 0 or 100. In
order to avoid adding a 
subplot
 to the chart, there is an
automated plotting translation to plot them over the 
data
 at the
point in time in which the pattern was recognized.

Examples and comparisons

The following are plots comparing the outputs of some 
ta-lib
 indicators
against the equivalent built-in indicators in 
backtrader
. To consider:

The 
ta-lib
 indicators get a 
TA_
 prefix on the plot. This is
    specifically done by the sample to help the user spot which is which

Moving Averages
 (if both deliver the same result) will be plotted 
ON

    top of the other existing 
Moving Average
. The two indicators cannot be
    seen separately and the test is a pass if that’s the case.

All samples include a 
CDLDOJI
 indicator as a reference

KAMA (Kaufman Moving Average)

This is the 1
st
 example because it is the only (from all indicators which the
sample directly compare) that has a difference:

The initial values of the the samples are not the same

At some point in time, the values converge and both 
KAMA
 implementations
    have the same behavior.

After having analyzed the 
ta-lib
 source code:

The implementation in 
ta-lib
 makes a non-industry standard choice for the
    1
st
 values of the 
KAMA
.

The choice can be seen in the source code quoting from the source code):

The yesterday price is used here as the previous KAMA.

backtrader
 does the usual choice which is the same as for example the one
from 
Stockcharts
:

KAMA at StockCharts

Since we need an initial value to start the calculation, the first KAMA is
just a simple moving average

Hence the difference. Furthermore:

The 
ta-lib

KAMA
 implementation doesn’t allow specifying the 
fast

    and 
slow
 periods for the adjustment of the 
scalable constant
 defined
    by 
Kaufman
.

Sample execution:

```
$ ./talibtest.py --plot --ind kama

```

Output

SMA

```
$ ./talibtest.py --plot --ind sma

```

Output

EMA

```
$ ./talibtest.py --plot --ind ema

```

Output

Stochastic

```
$ ./talibtest.py --plot --ind stoc

```

Output

RSI

```
$ ./talibtest.py --plot --ind rsi

```

Output

MACD

```
$ ./talibtest.py --plot --ind macd

```

Output

Bollinger Bands

```
$ ./talibtest.py --plot --ind bollinger

```

Output

AROON

Note that 
ta-lib
 chooses to put the 
down
 line first and the colours are
inverted when compared with the 
backtrader
 built-in indicator.

```
$ ./talibtest.py --plot --ind aroon

```

Output

Ultimate Oscillator

```
$ ./talibtest.py --plot --ind ultimate

```

Output

Trix

```
$ ./talibtest.py --plot --ind trix

```

Output

ADXR

Here 
backtrader
 offers both the 
ADX
 and 
ADXR
 lines.

```
$ ./talibtest.py --plot --ind adxr

```

Output

DEMA

```
$ ./talibtest.py --plot --ind dema

```

Output

TEMA

```
$ ./talibtest.py --plot --ind tema

```

Output

PPO

Here 
backtrader
 offers not only the 
ppo
 line, but a more traditional

macd
 approach.

```
$ ./talibtest.py --plot --ind ppo

```

Output

WilliamsR

```
$ ./talibtest.py --plot --ind williamsr

```

Output

ROC

All indicators show have exactly the same shape, but how to track 
momentum
 or

rate of change
 has several definitions

```
$ ./talibtest.py --plot --ind roc

```

Output

Sample Usage

```
$ ./talibtest.py --help
usage: talibtest.py [-h] [--data0 DATA0] [--fromdate FROMDATE]
                    [--todate TODATE]
                    [--ind {sma,ema,stoc,rsi,macd,bollinger,aroon,ultimate,trix,kama,adxr,dema,tema,ppo,williamsr,roc}]
                    [--no-doji] [--use-next] [--plot [kwargs]]

Sample for ta-lib

optional arguments:
  -h, --help            show this help message and exit
  --data0 DATA0         Data to be read in (default:
                        ../../datas/yhoo-1996-2015.txt)
  --fromdate FROMDATE   Starting date in YYYY-MM-DD format (default:
                        2005-01-01)
  --todate TODATE       Ending date in YYYY-MM-DD format (default: 2006-12-31)
  --ind {sma,ema,stoc,rsi,macd,bollinger,aroon,ultimate,trix,kama,adxr,dema,tema,ppo,williamsr,roc}
                        Which indicator pair to show together (default: sma)
  --no-doji             Remove Doji CandleStick pattern checker (default:
                        False)
  --use-next            Use next (step by step) instead of once (batch)
                        (default: False)
  --plot [kwargs], -p [kwargs]
                        Plot the read data applying any kwargs passed For
                        example (escape the quotes if needed): --plot
                        style="candle" (to plot candles) (default: None)

```

Sample Code

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime

import backtrader as bt

class TALibStrategy(bt.Strategy):
    params = (('ind', 'sma'), ('doji', True),)

    INDS = ['sma', 'ema', 'stoc', 'rsi', 'macd', 'bollinger', 'aroon',
            'ultimate', 'trix', 'kama', 'adxr', 'dema', 'ppo', 'tema',
            'roc', 'williamsr']

    def __init__(self):
        if self.p.doji:
            bt.talib.CDLDOJI(self.data.open, self.data.high,
                             self.data.low, self.data.close)

        if self.p.ind == 'sma':
            bt.talib.SMA(self.data.close, timeperiod=25, plotname='TA_SMA')
            bt.indicators.SMA(self.data, period=25)
        elif self.p.ind == 'ema':
            bt.talib.EMA(timeperiod=25, plotname='TA_SMA')
            bt.indicators.EMA(period=25)
        elif self.p.ind == 'stoc':
            bt.talib.STOCH(self.data.high, self.data.low, self.data.close,
                           fastk_period=14, slowk_period=3, slowd_period=3,
                           plotname='TA_STOCH')

            bt.indicators.Stochastic(self.data)

        elif self.p.ind == 'macd':
            bt.talib.MACD(self.data, plotname='TA_MACD')
            bt.indicators.MACD(self.data)
            bt.indicators.MACDHisto(self.data)
        elif self.p.ind == 'bollinger':
            bt.talib.BBANDS(self.data, timeperiod=25,
                            plotname='TA_BBANDS')
            bt.indicators.BollingerBands(self.data, period=25)

        elif self.p.ind == 'rsi':
            bt.talib.RSI(self.data, plotname='TA_RSI')
            bt.indicators.RSI(self.data)

        elif self.p.ind == 'aroon':
            bt.talib.AROON(self.data.high, self.data.low, plotname='TA_AROON')
            bt.indicators.AroonIndicator(self.data)

        elif self.p.ind == 'ultimate':
            bt.talib.ULTOSC(self.data.high, self.data.low, self.data.close,
                            plotname='TA_ULTOSC')
            bt.indicators.UltimateOscillator(self.data)

        elif self.p.ind == 'trix':
            bt.talib.TRIX(self.data, timeperiod=25,  plotname='TA_TRIX')
            bt.indicators.Trix(self.data, period=25)

        elif self.p.ind == 'adxr':
            bt.talib.ADXR(self.data.high, self.data.low, self.data.close,
                          plotname='TA_ADXR')
            bt.indicators.ADXR(self.data)

        elif self.p.ind == 'kama':
            bt.talib.KAMA(self.data, timeperiod=25, plotname='TA_KAMA')
            bt.indicators.KAMA(self.data, period=25)

        elif self.p.ind == 'dema':
            bt.talib.DEMA(self.data, timeperiod=25, plotname='TA_DEMA')
            bt.indicators.DEMA(self.data, period=25)

        elif self.p.ind == 'ppo':
            bt.talib.PPO(self.data, plotname='TA_PPO')
            bt.indicators.PPO(self.data, _movav=bt.indicators.SMA)

        elif self.p.ind == 'tema':
            bt.talib.TEMA(self.data, timeperiod=25, plotname='TA_TEMA')
            bt.indicators.TEMA(self.data, period=25)

        elif self.p.ind == 'roc':
            bt.talib.ROC(self.data, timeperiod=12, plotname='TA_ROC')
            bt.talib.ROCP(self.data, timeperiod=12, plotname='TA_ROCP')
            bt.talib.ROCR(self.data, timeperiod=12, plotname='TA_ROCR')
            bt.talib.ROCR100(self.data, timeperiod=12, plotname='TA_ROCR100')
            bt.indicators.ROC(self.data, period=12)
            bt.indicators.Momentum(self.data, period=12)
            bt.indicators.MomentumOscillator(self.data, period=12)

        elif self.p.ind == 'williamsr':
            bt.talib.WILLR(self.data.high, self.data.low, self.data.close,
                           plotname='TA_WILLR')
            bt.indicators.WilliamsR(self.data)

def runstrat(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()

    dkwargs = dict()
    if args.fromdate:
        fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')
        dkwargs['fromdate'] = fromdate

    if args.todate:
        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')
        dkwargs['todate'] = todate

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0, **dkwargs)
    cerebro.adddata(data0)

    cerebro.addstrategy(TALibStrategy, ind=args.ind, doji=not args.no_doji)

    cerebro.run(runcone=not args.use_next, stdstats=False)
    if args.plot:
        pkwargs = dict(style='candle')
        if args.plot is not True:  # evals to True but is not True
            npkwargs = eval('dict(' + args.plot + ')')  # args were passed
            pkwargs.update(npkwargs)

        cerebro.plot(**pkwargs)

def parse_args(pargs=None):

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Sample for sizer')

    parser.add_argument('--data0', required=False,
                        default='../../datas/yhoo-1996-2015.txt',
                        help='Data to be read in')

    parser.add_argument('--fromdate', required=False,
                        default='2005-01-01',
                        help='Starting date in YYYY-MM-DD format')

    parser.add_argument('--todate', required=False,
                        default='2006-12-31',
                        help='Ending date in YYYY-MM-DD format')

    parser.add_argument('--ind', required=False, action='store',
                        default=TALibStrategy.INDS[0],
                        choices=TALibStrategy.INDS,
                        help=('Which indicator pair to show together'))

    parser.add_argument('--no-doji', required=False, action='store_true',
                        help=('Remove Doji CandleStick pattern checker'))

    parser.add_argument('--use-next', required=False, action='store_true',
                        help=('Use next (step by step) '
                              'instead of once (batch)'))

    # Plot options
    parser.add_argument('--plot', '-p', nargs='?', required=False,
                        metavar='kwargs', const=True,
                        help=('Plot the read data applying any kwargs passed\n'
                              '\n'
                              'For example (escape the quotes if needed):\n'
                              '\n'
                              '  --plot style="candle" (to plot candles)\n'))

    if pargs is not None:
        return parser.parse_args(pargs)

    return parser.parse_args()

if __name__ == '__main__':
    runstrat()

```
########################################
docu-talibindautoref.txt - lunghezza: 95453
########################################
Indicators - ta-lib - Reference

TA-Lib Indicator Reference

ACOS

ACOS([input_arrays])

Vector Trigonometric ACos (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

AD

AD([input_arrays])

Chaikin A/D Line (Volume Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’, ‘volume’]

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ADD

ADD([input_arrays])

Vector Arithmetic Add (Math Operators)

Inputs:

```
price0: (any ndarray) price1: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ADOSC

ADOSC([input_arrays], [fastperiod=3], [slowperiod=10])

Chaikin A/D Oscillator (Volume Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’, ‘volume’]

```

Parameters:

```
fastperiod: 3 slowperiod: 10

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* fastperiod (3)

* slowperiod (10)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ADX

ADX([input_arrays], [timeperiod=14])

Average Directional Movement Index (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ADXR

ADXR([input_arrays], [timeperiod=14])

Average Directional Movement Index Rating (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

APO

APO([input_arrays], [fastperiod=12], [slowperiod=26], [matype=0])

Absolute Price Oscillator (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
fastperiod: 12 slowperiod: 26 matype: 0 (Simple Moving Average)

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* fastperiod (12)

* slowperiod (26)

* matype (0)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

AROON

AROON([input_arrays], [timeperiod=14])

Aroon (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
aroondown aroonup

```

Lines:

```
* aroondown

* aroonup

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* aroondown: - ls (–)

* aroonup: - ls (-)

```

AROONOSC

AROONOSC([input_arrays], [timeperiod=14])

Aroon Oscillator (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ASIN

ASIN([input_arrays])

Vector Trigonometric ASin (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ATAN

ATAN([input_arrays])

Vector Trigonometric ATan (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ATR

ATR([input_arrays], [timeperiod=14])

Average True Range (Volatility Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

AVGPRICE

AVGPRICE([input_arrays])

Average Price (Price Transform)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

BBANDS

BBANDS([input_arrays], [timeperiod=5], [nbdevup=2], [nbdevdn=2],
[matype=0])

Bollinger Bands (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 5 nbdevup: 2 nbdevdn: 2 matype: 0 (Simple Moving
Average)

```

Outputs:

```
upperband middleband lowerband

```

Lines:

```
* upperband

* middleband

* lowerband

```

Params:

```
* timeperiod (5)

* nbdevup (2)

* nbdevdn (2)

* matype (0)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* middleband: - _samecolor (True) - ls (-)

* upperband:

* lowerband: - _samecolor (True)

```

BETA

BETA([input_arrays], [timeperiod=5])

Beta (Statistic Functions)

Inputs:

```
price0: (any ndarray) price1: (any ndarray)

```

Parameters:

```
timeperiod: 5

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (5)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

BOP

BOP([input_arrays])

Balance Of Power (Momentum Indicators)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

CCI

CCI([input_arrays], [timeperiod=14])

Commodity Channel Index (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

CDL2###CROWS

CDL2CROWS([input_arrays])

Two Crows (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDL2CROWS)

```

CDL3###BLACKCROWS

CDL3BLACKCROWS([input_arrays])

Three Black Crows (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDL3BLACKCROWS)

```

CDL3###INSIDE

CDL3INSIDE([input_arrays])

Three Inside Up/Down (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDL3INSIDE)

```

CDL3###LINESTRIKE

CDL3LINESTRIKE([input_arrays])

Three-Line Strike  (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDL3LINESTRIKE)

```

CDL3###OUTSIDE

CDL3OUTSIDE([input_arrays])

Three Outside Up/Down (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDL3OUTSIDE)

```

CDL3###STARSINSOUTH

CDL3STARSINSOUTH([input_arrays])

Three Stars In The South (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDL3STARSINSOUTH)

```

CDL3###WHITESOLDIERS

CDL3WHITESOLDIERS([input_arrays])

Three Advancing White Soldiers (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDL3WHITESOLDIERS)

```

CDLABANDONEDBABY

CDLABANDONEDBABY([input_arrays], [penetration=0.3])

Abandoned Baby (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Parameters:

```
penetration: 0.3

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

Params:

```
* penetration (0.3)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLABANDONEDBABY)

```

CDLADVANCEBLOCK

CDLADVANCEBLOCK([input_arrays])

Advance Block (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLADVANCEBLOCK)

```

CDLBELTHOLD

CDLBELTHOLD([input_arrays])

Belt-hold (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLBELTHOLD)

```

CDLBREAKAWAY

CDLBREAKAWAY([input_arrays])

Breakaway (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLBREAKAWAY)

```

CDLCLOSINGMARUBOZU

CDLCLOSINGMARUBOZU([input_arrays])

Closing Marubozu (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLCLOSINGMARUBOZU)

```

CDLCONCEALBABYSWALL

CDLCONCEALBABYSWALL([input_arrays])

Concealing Baby Swallow (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLCONCEALBABYSWALL)

```

CDLCOUNTERATTACK

CDLCOUNTERATTACK([input_arrays])

Counterattack (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLCOUNTERATTACK)

```

CDLDARKCLOUDCOVER

CDLDARKCLOUDCOVER([input_arrays], [penetration=0.5])

Dark Cloud Cover (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Parameters:

```
penetration: 0.5

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

Params:

```
* penetration (0.5)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLDARKCLOUDCOVER)

```

CDLDOJI

CDLDOJI([input_arrays])

Doji (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLDOJI)

```

CDLDOJISTAR

CDLDOJISTAR([input_arrays])

Doji Star (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLDOJISTAR)

```

CDLDRAGONFLYDOJI

CDLDRAGONFLYDOJI([input_arrays])

Dragonfly Doji (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLDRAGONFLYDOJI)

```

CDLENGULFING

CDLENGULFING([input_arrays])

Engulfing Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLENGULFING)

```

CDLEVENINGDOJISTAR

CDLEVENINGDOJISTAR([input_arrays], [penetration=0.3])

Evening Doji Star (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Parameters:

```
penetration: 0.3

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

Params:

```
* penetration (0.3)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLEVENINGDOJISTAR)

```

CDLEVENINGSTAR

CDLEVENINGSTAR([input_arrays], [penetration=0.3])

Evening Star (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Parameters:

```
penetration: 0.3

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

Params:

```
* penetration (0.3)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLEVENINGSTAR)

```

CDLGAPSIDESIDEWHITE

CDLGAPSIDESIDEWHITE([input_arrays])

Up/Down-gap side-by-side white lines (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLGAPSIDESIDEWHITE)

```

CDLGRAVESTONEDOJI

CDLGRAVESTONEDOJI([input_arrays])

Gravestone Doji (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLGRAVESTONEDOJI)

```

CDLHAMMER

CDLHAMMER([input_arrays])

Hammer (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLHAMMER)

```

CDLHANGINGMAN

CDLHANGINGMAN([input_arrays])

Hanging Man (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLHANGINGMAN)

```

CDLHARAMI

CDLHARAMI([input_arrays])

Harami Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLHARAMI)

```

CDLHARAMICROSS

CDLHARAMICROSS([input_arrays])

Harami Cross Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLHARAMICROSS)

```

CDLHIGHWAVE

CDLHIGHWAVE([input_arrays])

High-Wave Candle (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLHIGHWAVE)

```

CDLHIKKAKE

CDLHIKKAKE([input_arrays])

Hikkake Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLHIKKAKE)

```

CDLHIKKAKEMOD

CDLHIKKAKEMOD([input_arrays])

Modified Hikkake Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLHIKKAKEMOD)

```

CDLHOMINGPIGEON

CDLHOMINGPIGEON([input_arrays])

Homing Pigeon (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLHOMINGPIGEON)

```

CDLIDENTICAL3###CROWS

CDLIDENTICAL3CROWS([input_arrays])

Identical Three Crows (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLIDENTICAL3CROWS)

```

CDLINNECK

CDLINNECK([input_arrays])

In-Neck Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLINNECK)

```

CDLINVERTEDHAMMER

CDLINVERTEDHAMMER([input_arrays])

Inverted Hammer (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLINVERTEDHAMMER)

```

CDLKICKING

CDLKICKING([input_arrays])

Kicking (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLKICKING)

```

CDLKICKINGBYLENGTH

CDLKICKINGBYLENGTH([input_arrays])

Kicking - bull/bear determined by the longer marubozu (Pattern
Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLKICKINGBYLENGTH)

```

CDLLADDERBOTTOM

CDLLADDERBOTTOM([input_arrays])

Ladder Bottom (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLLADDERBOTTOM)

```

CDLLONGLEGGEDDOJI

CDLLONGLEGGEDDOJI([input_arrays])

Long Legged Doji (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLLONGLEGGEDDOJI)

```

CDLLONGLINE

CDLLONGLINE([input_arrays])

Long Line Candle (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLLONGLINE)

```

CDLMARUBOZU

CDLMARUBOZU([input_arrays])

Marubozu (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLMARUBOZU)

```

CDLMATCHINGLOW

CDLMATCHINGLOW([input_arrays])

Matching Low (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLMATCHINGLOW)

```

CDLMATHOLD

CDLMATHOLD([input_arrays], [penetration=0.5])

Mat Hold (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Parameters:

```
penetration: 0.5

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

Params:

```
* penetration (0.5)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLMATHOLD)

```

CDLMORNINGDOJISTAR

CDLMORNINGDOJISTAR([input_arrays], [penetration=0.3])

Morning Doji Star (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Parameters:

```
penetration: 0.3

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

Params:

```
* penetration (0.3)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLMORNINGDOJISTAR)

```

CDLMORNINGSTAR

CDLMORNINGSTAR([input_arrays], [penetration=0.3])

Morning Star (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Parameters:

```
penetration: 0.3

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

Params:

```
* penetration (0.3)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLMORNINGSTAR)

```

CDLONNECK

CDLONNECK([input_arrays])

On-Neck Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLONNECK)

```

CDLPIERCING

CDLPIERCING([input_arrays])

Piercing Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLPIERCING)

```

CDLRICKSHAWMAN

CDLRICKSHAWMAN([input_arrays])

Rickshaw Man (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLRICKSHAWMAN)

```

CDLRISEFALL3###METHODS

CDLRISEFALL3METHODS([input_arrays])

Rising/Falling Three Methods (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLRISEFALL3METHODS)

```

CDLSEPARATINGLINES

CDLSEPARATINGLINES([input_arrays])

Separating Lines (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLSEPARATINGLINES)

```

CDLSHOOTINGSTAR

CDLSHOOTINGSTAR([input_arrays])

Shooting Star (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLSHOOTINGSTAR)

```

CDLSHORTLINE

CDLSHORTLINE([input_arrays])

Short Line Candle (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLSHORTLINE)

```

CDLSPINNINGTOP

CDLSPINNINGTOP([input_arrays])

Spinning Top (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLSPINNINGTOP)

```

CDLSTALLEDPATTERN

CDLSTALLEDPATTERN([input_arrays])

Stalled Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLSTALLEDPATTERN)

```

CDLSTICKSANDWICH

CDLSTICKSANDWICH([input_arrays])

Stick Sandwich (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLSTICKSANDWICH)

```

CDLTAKURI

CDLTAKURI([input_arrays])

Takuri (Dragonfly Doji with very long lower shadow) (Pattern
Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLTAKURI)

```

CDLTASUKIGAP

CDLTASUKIGAP([input_arrays])

Tasuki Gap (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLTASUKIGAP)

```

CDLTHRUSTING

CDLTHRUSTING([input_arrays])

Thrusting Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLTHRUSTING)

```

CDLTRISTAR

CDLTRISTAR([input_arrays])

Tristar Pattern (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLTRISTAR)

```

CDLUNIQUE3###RIVER

CDLUNIQUE3RIVER([input_arrays])

Unique 3 River (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLUNIQUE3RIVER)

```

CDLUPSIDEGAP2###CROWS

CDLUPSIDEGAP2CROWS([input_arrays])

Upside Gap Two Crows (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLUPSIDEGAP2CROWS)

```

CDLXSIDEGAP3###METHODS

CDLXSIDEGAP3METHODS([input_arrays])

Upside/Downside Gap Three Methods (Pattern Recognition)

Inputs:

```
prices: [‘open’, ‘high’, ‘low’, ‘close’]

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

* _candleplot

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (True)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - _plotskip (True)

* _candleplot: - marker (d) - fillstyle (full) - markersize (7.0) -
  ls () - _name (CDLXSIDEGAP3METHODS)

```

CEIL

CEIL([input_arrays])

Vector Ceil (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

CMO

CMO([input_arrays], [timeperiod=14])

Chande Momentum Oscillator (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

CORREL

CORREL([input_arrays], [timeperiod=30])

Pearson’s Correlation Coefficient ® (Statistic Functions)

Inputs:

```
price0: (any ndarray) price1: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

COS

COS([input_arrays])

Vector Trigonometric Cos (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

COSH

COSH([input_arrays])

Vector Trigonometric Cosh (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

DEMA

DEMA([input_arrays], [timeperiod=30])

Double Exponential Moving Average (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

DIV

DIV([input_arrays])

Vector Arithmetic Div (Math Operators)

Inputs:

```
price0: (any ndarray) price1: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

DX

DX([input_arrays], [timeperiod=14])

Directional Movement Index (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

EMA

EMA([input_arrays], [timeperiod=30])

Exponential Moving Average (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

EXP

EXP([input_arrays])

Vector Arithmetic Exp (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

FLOOR

FLOOR([input_arrays])

Vector Floor (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

HT_###DCPERIOD

HT_DCPERIOD([input_arrays])

Hilbert Transform - Dominant Cycle Period (Cycle Indicators)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

HT_###DCPHASE

HT_DCPHASE([input_arrays])

Hilbert Transform - Dominant Cycle Phase (Cycle Indicators)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

HT_###PHASOR

HT_PHASOR([input_arrays])

Hilbert Transform - Phasor Components (Cycle Indicators)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
inphase quadrature

```

Lines:

```
* inphase

* quadrature

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* inphase: - ls (-)

* quadrature: - ls (–)

```

HT_###SINE

HT_SINE([input_arrays])

Hilbert Transform - SineWave (Cycle Indicators)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
sine leadsine

```

Lines:

```
* sine

* leadsine

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* leadsine: - ls (–)

* sine: - ls (-)

```

HT_###TRENDLINE

HT_TRENDLINE([input_arrays])

Hilbert Transform - Instantaneous Trendline (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

HT_###TRENDMODE

HT_TRENDMODE([input_arrays])

Hilbert Transform - Trend vs Cycle Mode (Cycle Indicators)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - ls (-)

```

KAMA

KAMA([input_arrays], [timeperiod=30])

Kaufman Adaptive Moving Average (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

LINEARREG

LINEARREG([input_arrays], [timeperiod=14])

Linear Regression (Statistic Functions)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

LINEARREG_###ANGLE

LINEARREG_ANGLE([input_arrays], [timeperiod=14])

Linear Regression Angle (Statistic Functions)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

LINEARREG_###INTERCEPT

LINEARREG_INTERCEPT([input_arrays], [timeperiod=14])

Linear Regression Intercept (Statistic Functions)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

LINEARREG_###SLOPE

LINEARREG_SLOPE([input_arrays], [timeperiod=14])

Linear Regression Slope (Statistic Functions)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

LN

LN([input_arrays])

Vector Log Natural (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

LOG10

LOG10([input_arrays])

Vector Log10 (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MA

MA([input_arrays], [timeperiod=30], [matype=0])

Moving average (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30 matype: 0 (Simple Moving Average)

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

* matype (0)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MACD

MACD([input_arrays], [fastperiod=12], [slowperiod=26],
[signalperiod=9])

Moving Average Convergence/Divergence (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
fastperiod: 12 slowperiod: 26 signalperiod: 9

```

Outputs:

```
macd macdsignal macdhist

```

Lines:

```
* macd

* macdsignal

* macdhist

```

Params:

```
* fastperiod (12)

* slowperiod (26)

* signalperiod (9)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* macdsignal: - ls (–)

* macd: - ls (-)

* macdhist: - _method (bar)

```

MACDEXT

MACDEXT([input_arrays], [fastperiod=12], [fastmatype=0],
[slowperiod=26], [slowmatype=0], [signalperiod=9], [signalmatype=0])

MACD with controllable MA type (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
fastperiod: 12 fastmatype: 0 slowperiod: 26 slowmatype: 0
signalperiod: 9 signalmatype: 0

```

Outputs:

```
macd macdsignal macdhist

```

Lines:

```
* macd

* macdsignal

* macdhist

```

Params:

```
* fastperiod (12)

* fastmatype (0)

* slowperiod (26)

* slowmatype (0)

* signalperiod (9)

* signalmatype (0)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* macdsignal: - ls (–)

* macd: - ls (-)

* macdhist: - _method (bar)

```

MACDFIX

MACDFIX([input_arrays], [signalperiod=9])

Moving Average Convergence/Divergence Fix 12/26 (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
signalperiod: 9

```

Outputs:

```
macd macdsignal macdhist

```

Lines:

```
* macd

* macdsignal

* macdhist

```

Params:

```
* signalperiod (9)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* macdsignal: - ls (–)

* macd: - ls (-)

* macdhist: - _method (bar)

```

MAMA

MAMA([input_arrays], [fastlimit=0.5], [slowlimit=0.05])

MESA Adaptive Moving Average (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
fastlimit: 0.5 slowlimit: 0.05

```

Outputs:

```
mama fama

```

Lines:

```
* mama

* fama

```

Params:

```
* fastlimit (0.5)

* slowlimit (0.05)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* mama: - ls (-)

* fama: - ls (–)

```

MAVP

MAVP([input_arrays], [minperiod=2], [maxperiod=30], [matype=0])

Moving average with variable period (Overlap Studies)

Inputs:

```
price: (any ndarray) periods: (any ndarray)

```

Parameters:

```
minperiod: 2 maxperiod: 30 matype: 0 (Simple Moving Average)

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* minperiod (2)

* maxperiod (30)

* matype (0)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MAX

MAX([input_arrays], [timeperiod=30])

Highest value over a specified period (Math Operators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MAXINDEX

MAXINDEX([input_arrays], [timeperiod=30])

Index of highest value over a specified period (Math Operators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - ls (-)

```

MEDPRICE

MEDPRICE([input_arrays])

Median Price (Price Transform)

Inputs:

```
prices: [‘high’, ‘low’]

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MFI

MFI([input_arrays], [timeperiod=14])

Money Flow Index (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’, ‘volume’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MIDPOINT

MIDPOINT([input_arrays], [timeperiod=14])

MidPoint over period (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MIDPRICE

MIDPRICE([input_arrays], [timeperiod=14])

Midpoint Price over period (Overlap Studies)

Inputs:

```
prices: [‘high’, ‘low’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MIN

MIN([input_arrays], [timeperiod=30])

Lowest value over a specified period (Math Operators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MININDEX

MININDEX([input_arrays], [timeperiod=30])

Index of lowest value over a specified period (Math Operators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
integer (values are -100, 0 or 100)

```

Lines:

```
* integer

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* integer: - ls (-)

```

MINMAX

MINMAX([input_arrays], [timeperiod=30])

Lowest and highest values over a specified period (Math Operators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
min max

```

Lines:

```
* min

* max

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* max: - ls (-)

* min: - ls (-)

```

MINMAXINDEX

MINMAXINDEX([input_arrays], [timeperiod=30])

Indexes of lowest and highest values over a specified period (Math
Operators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
minidx maxidx

```

Lines:

```
* minidx

* maxidx

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* maxidx: - ls (-)

* minidx: - ls (-)

```

MINUS_###DI

MINUS_DI([input_arrays], [timeperiod=14])

Minus Directional Indicator (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MINUS_###DM

MINUS_DM([input_arrays], [timeperiod=14])

Minus Directional Movement (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MOM

MOM([input_arrays], [timeperiod=10])

Momentum (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 10

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (10)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

MULT

MULT([input_arrays])

Vector Arithmetic Mult (Math Operators)

Inputs:

```
price0: (any ndarray) price1: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

NATR

NATR([input_arrays], [timeperiod=14])

Normalized Average True Range (Volatility Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

OBV

OBV([input_arrays])

On Balance Volume (Volume Indicators)

Inputs:

```
price: (any ndarray) prices: [‘volume’]

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

PLUS_###DI

PLUS_DI([input_arrays], [timeperiod=14])

Plus Directional Indicator (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

PLUS_###DM

PLUS_DM([input_arrays], [timeperiod=14])

Plus Directional Movement (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

PPO

PPO([input_arrays], [fastperiod=12], [slowperiod=26], [matype=0])

Percentage Price Oscillator (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
fastperiod: 12 slowperiod: 26 matype: 0 (Simple Moving Average)

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* fastperiod (12)

* slowperiod (26)

* matype (0)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ROC

ROC([input_arrays], [timeperiod=10])

Rate of change : ((price/prevPrice)-1)*100 (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 10

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (10)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ROCP

ROCP([input_arrays], [timeperiod=10])

Rate of change Percentage: (price-prevPrice)/prevPrice (Momentum
Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 10

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (10)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ROCR

ROCR([input_arrays], [timeperiod=10])

Rate of change ratio: (price/prevPrice) (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 10

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (10)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ROCR100

ROCR100([input_arrays], [timeperiod=10])

Rate of change ratio 100 scale: (price/prevPrice)*100 (Momentum
Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 10

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (10)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

RSI

RSI([input_arrays], [timeperiod=14])

Relative Strength Index (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

SAR

SAR([input_arrays], [acceleration=0.02], [maximum=0.2])

Parabolic SAR (Overlap Studies)

Inputs:

```
prices: [‘high’, ‘low’]

```

Parameters:

```
acceleration: 0.02 maximum: 0.2

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* acceleration (0.02)

* maximum (0.2)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

SAREXT

SAREXT([input_arrays], [startvalue=0], [offsetonreverse=0],
[accelerationinitlong=0.02], [accelerationlong=0.02],
[accelerationmaxlong=0.2], [accelerationinitshort=0.02],
[accelerationshort=0.02], [accelerationmaxshort=0.2])

Parabolic SAR - Extended (Overlap Studies)

Inputs:

```
prices: [‘high’, ‘low’]

```

Parameters:

```
startvalue: 0 offsetonreverse: 0 accelerationinitlong: 0.02
accelerationlong: 0.02 accelerationmaxlong: 0.2
accelerationinitshort: 0.02 accelerationshort: 0.02
accelerationmaxshort: 0.2

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* startvalue (0)

* offsetonreverse (0)

* accelerationinitlong (0.02)

* accelerationlong (0.02)

* accelerationmaxlong (0.2)

* accelerationinitshort (0.02)

* accelerationshort (0.02)

* accelerationmaxshort (0.2)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

SIN

SIN([input_arrays])

Vector Trigonometric Sin (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

SINH

SINH([input_arrays])

Vector Trigonometric Sinh (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

SMA

SMA([input_arrays], [timeperiod=30])

Simple Moving Average (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

SQRT

SQRT([input_arrays])

Vector Square Root (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

STDDEV

STDDEV([input_arrays], [timeperiod=5], [nbdev=1])

Standard Deviation (Statistic Functions)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 5 nbdev: 1

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (5)

* nbdev (1)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

STOCH

STOCH([input_arrays], [fastk_period=5], [slowk_period=3],
[slowk_matype=0], [slowd_period=3], [slowd_matype=0])

Stochastic (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
fastk_period: 5 slowk_period: 3 slowk_matype: 0 slowd_period: 3
slowd_matype: 0

```

Outputs:

```
slowk slowd

```

Lines:

```
* slowk

* slowd

```

Params:

```
* fastk_period (5)

* slowk_period (3)

* slowk_matype (0)

* slowd_period (3)

* slowd_matype (0)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* slowk: - ls (–)

* slowd: - ls (–)

```

STOCHF

STOCHF([input_arrays], [fastk_period=5], [fastd_period=3],
[fastd_matype=0])

Stochastic Fast (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
fastk_period: 5 fastd_period: 3 fastd_matype: 0

```

Outputs:

```
fastk fastd

```

Lines:

```
* fastk

* fastd

```

Params:

```
* fastk_period (5)

* fastd_period (3)

* fastd_matype (0)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* fastk: - ls (-)

* fastd: - ls (-)

```

STOCHRSI

STOCHRSI([input_arrays], [timeperiod=14], [fastk_period=5],
[fastd_period=3], [fastd_matype=0])

Stochastic Relative Strength Index (Momentum Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 14 fastk_period: 5 fastd_period: 3 fastd_matype: 0

```

Outputs:

```
fastk fastd

```

Lines:

```
* fastk

* fastd

```

Params:

```
* timeperiod (14)

* fastk_period (5)

* fastd_period (3)

* fastd_matype (0)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* fastk: - ls (-)

* fastd: - ls (-)

```

SUB

SUB([input_arrays])

Vector Arithmetic Substraction (Math Operators)

Inputs:

```
price0: (any ndarray) price1: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

SUM

SUM([input_arrays], [timeperiod=30])

Summation (Math Operators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

T3

T3([input_arrays], [timeperiod=5], [vfactor=0.7])

Triple Exponential Moving Average (T3) (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 5 vfactor: 0.7

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (5)

* vfactor (0.7)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

TAN

TAN([input_arrays])

Vector Trigonometric Tan (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

TANH

TANH([input_arrays])

Vector Trigonometric Tanh (Math Transform)

Inputs:

```
price: (any ndarray)

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

TEMA

TEMA([input_arrays], [timeperiod=30])

Triple Exponential Moving Average (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

TRANGE

TRANGE([input_arrays])

True Range (Volatility Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

TRIMA

TRIMA([input_arrays], [timeperiod=30])

Triangular Moving Average (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

TRIX

TRIX([input_arrays], [timeperiod=30])

1-day Rate-Of-Change (ROC) of a Triple Smooth EMA (Momentum
Indicators)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

TSF

TSF([input_arrays], [timeperiod=14])

Time Series Forecast (Statistic Functions)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

TYPPRICE

TYPPRICE([input_arrays])

Typical Price (Price Transform)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

ULTOSC

ULTOSC([input_arrays], [timeperiod1=7], [timeperiod2=14],
[timeperiod3=28])

Ultimate Oscillator (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod1: 7 timeperiod2: 14 timeperiod3: 28

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod1 (7)

* timeperiod2 (14)

* timeperiod3 (28)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

VAR

VAR([input_arrays], [timeperiod=5], [nbdev=1])

Variance (Statistic Functions)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 5 nbdev: 1

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (5)

* nbdev (1)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

WCLPRICE

WCLPRICE([input_arrays])

Weighted Close Price (Price Transform)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Outputs:

```
real

```

Lines:

```
* real

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

WILLR

WILLR([input_arrays], [timeperiod=14])

Williams’ %R (Momentum Indicators)

Inputs:

```
prices: [‘high’, ‘low’, ‘close’]

```

Parameters:

```
timeperiod: 14

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (14)

```

PlotInfo:

```
* subplot (True)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```

WMA

WMA([input_arrays], [timeperiod=30])

Weighted Moving Average (Overlap Studies)

Inputs:

```
price: (any ndarray)

```

Parameters:

```
timeperiod: 30

```

Outputs:

```
real

```

Lines:

```
* real

```

Params:

```
* timeperiod (30)

```

PlotInfo:

```
* subplot (False)

* plot (True)

* plotskip (False)

* plotname ()

* plotforce (False)

* plotyhlines ([])

* plothlines ([])

* plotabove (False)

* plotymargin (0.0)

* plotlinelabels (False)

* plotmaster (None)

* plotyticks ([])

```

PlotLines:

```
* real: - ls (-)

```
########################################
docu-timemgmt.txt - lunghezza: 5788
########################################
DateTime Management

Up until release 
1.5.0
, 
backtrader
 used a direct approach to time
management in that whatever datetime was calculated by 
data sources
 was
simply used at face value.

And the same for any user input like in the case of the 
parameter

fromdate
 (or 
sessionstart
) which can be given to any 
data source

The approach was fine given the direct control over frozen data sources for
backtesting. It was easy to assume that the input datetimes had already been
taken care of before they entered the system.

But with 1.5.0, 
live

data sources
 are supported and this forces to take
into account 
datetime management
.  Such management would not be needed if
the following were always 
true
:

A trader in New York trades the ES-Mini. The time zone for both in

US/Eastern
 (or one of the aliases)

A trader in Berlin trades the DAX future. In this case for both the 
CET

    (or 
Europe/Berling
) timezone applies

The direct input-output datetime approach from above would work, becase the
trader, in Berlin for example, could always do something like this:

```
class Strategy(bt.Strategy):

    def next(self):

        # The DAX future opens at 08:00 CET
        if self.data.datetime.time() < datetime.time(8, 30):
            # don't operate until the market has been running 30 minutes
            return  #

```

The problem with the direct approach surfaces when the same trader in Berlin
decides to trade the 
ES-Mini
. Because the change to from 
DST
 happens at
different point in time in the year and this causes the time difference to be
out of sync a couple of weeks during the year. The following wouldn’t always
work:

```
class Strategy(bt.Strategy):

    def next(self):

        # The SPX opens at 09:30 US/Eastern all year long
        # This is most of the year 15:30 CET
        # But it is sometimes 16:30 CET or 14:30 CET if a DST switch on-off
        # has happened in the USA and not in Europe

        # That's why the code below is unreliable

        if self.data.datetime.time() < datetime.time(16, 0):
            # don't operate until the market has been running 30 minutes
            return  #

```

Operation with timezones

To solve the aforementioned situations and still remain compatible with the
direct input-output time approach, 
backtrader
 offers the end user the
following

Datetime Input

As a default the platform will not touch the 
datetime
 provided by a data source

The end-user can override this input by:

Providing a 
tzinput
 parameter to the data source. This must be an
    object compatible with the 
datetime.tzinfo
 interface. Most likely
    the user will provide a 
pytz.timezone
 instance

With this decision the time used internally by 
backtrader
 is considered
to be in 
UTC-like
 format, ie:

If the data source has already stored it in 
UTC
 format

After a conversion through 
tzinput

It’s not really 
UTC
 but it’s the reference for the user, hence

UTC-like

Datetime output

If the data feed can automatically determine the timezone for the output,
    this will be the default

This makes sense in the case of live-feeds and especially in use cases like
the one in which a trader in Berlin (
CET
 timezone), trades products
with 
US/Eastern
 timezone.

Because the trader gets always the right time and in the example above the

opening
 time remains constant at 
09:30 US/Eastern
, rather than

15:30 CET
 most of the year, but sometimes 
16:30 CET
 and sometimes

14:30 CET
.

If it cannot be determined, then the output will be whatever was determined
    during input (the 
UTC-like
) time

The end user can override and determine the actual timezone for the output

Providing a 
tz
 parameter to the data source. This must be an object
    compatible with the 
datetime.tzinfo
 interface. Most likely the user
    will provide a 
pytz.timezone
 instance

Note

Input fromt the user like for example the parameters 
fromdate
 or

sessionstart
 are expected to be in sync with the actual 
tz
, be it
automatically calculated by the 
data source
, supplied by the user or left
as default (
None
, which means direct input-output of 
datetime
)

With all that in mind let’s recall the Berlin trader, trading in

US/Eastern
:

```
import pytz

import bt

data = bt.feeds.MyFeed('ES-Mini', tz=pytz.timezone('US/Eastern'))

class Strategy(bt.Strategy):

    def next(self):

        # This will work all year round.
        # The data source will return in the frame of the 'US/Eastern' time
        # zone and the user is quoting '10:00' as reference time
        # Because in the 'US/Eastern' timezone the SPX index always starts
        # trading at 09:30, this will always work

        if self.data.datetime.time() < datetime.time(10, 0):
            # don't operate until the market has been running 30 minutes
            return  #

```

In the case of a 
data source
 which can automatically determine the output
timezone:

```
import bt

data = bt.feeds.MyFeedAutoTZ('ES-Mini')

class Strategy(bt.Strategy):

    def next(self):

        # This will work all year round.
        # The data source will return in the frame of the 'US/Eastern' time
        # zone and the user is quoting '10:00' as reference time
        # Because in the 'US/Eastern' timezone the SPX index always starts
        # trading at 09:30, this will always work

        if self.data.datetime.time() < datetime.time(10, 0):
            # don't operate until the market has been running 30 minutes
            return  #

```

Even less work than above.

Obviously 
MyFeed
 and 
MyFeedAuto
 in the example above are just dummy
names.

Note

At the time of writing the only data source included in the distribution
which can automatically determine the timezone is the one connecting to

Interactive Brokers
########################################
docu-timers-timers.txt - lunghezza: 30829
########################################
Timers

Release 
1.9.44.116
 added 
timers
 to the arsenal of tools available in

backtrader
. This functionality allows to get a call back to the

notify_timer
 (available in 
Cerebro
 and 
Strategy
) at given points in
time, with a fine grained end-user control.

Note

Some corrections have been made in 
1.9.46.116

Options

Timer based in absolute time input or with regards to session start/end
    times

Timezone specification for the time specification, be it directly or via

pytz
 compatible objects or via data feed
    session end times

Starting offset with regards to the specified time

Repetitions intervals

Weekdays filter (with carry over option)

Monthdays filter (with carry over option)

Custom callback filter

Usage pattern

Both in 
Cerebro
 and 
Strategy
 subclasses the timer callback will be
received in the following method.

```
def notify_timer(self, timer, when, *args, **kwargs):
    '''Receives a timer notification where ``timer`` is the timer which was
    returned by ``add_timer``, and ``when`` is the calling time. ``args``
    and ``kwargs`` are any additional arguments passed to ``add_timer``

    The actual ``when`` time can be later, but the system may have not be
    able to call the timer before. This value is the timer value and not the
    system time.
    '''

```

Adding timers - Via Strategy

Done with the method

```
def add_timer(self, when,
              offset=datetime.timedelta(), repeat=datetime.timedelta(),
              weekdays=[], weekcarry=False,
              monthdays=[], monthcarry=True,
              allow=None,
              tzdata=None, cheat=False,
              *args, **kwargs):
    '''

```

It returns the created 
Timer
 instance.

See below for an explanation of the parameters.

Adding timers - Via Cerebro

Done with the same method and just the addition of the parameter 
strats
. If
set to 
True
 the timer will not only be notified to the 
cerebro
, it will
also be notified to all strategies running in the system.

```
def add_timer(self, when,
              offset=datetime.timedelta(), repeat=datetime.timedelta(),
              weekdays=[], weekcarry=False,
              monthdays=[], monthcarry=True,
              allow=None,
              tzdata=None, cheat=False, strats=False,
              *args, **kwargs):
    '''

```

It returns the created 
Timer
 instance.

When are timers called

If 
cheat=False

This is the default. In this case a timer will be called:

After the data feeds have loaded the new values for the current bar

After the broker has evaluated orders and recalculated the portfolio value

Before indicators have been recalculated (because this is triggered by the
    strategies)

Before any 
next
 method of any strategy is called

If 
cheat=True

In this case a timer will be called:

After the data feeds have loaded the new values for the current bar

Before
 the broker has evaluated orders and recalculated the portfolio
    value

And consequently before indicators have been recalculated and 
next

    method of any strategy is called

Which allows for example the following scenario with daily bars:

Before the new bar is evaluated by the broker the timer is called

The indicators have the value from the previous day at the close and can be
    used to generate an entry/exit signal (or a flag may have been set during
    the last evaluation of 
next
)

Because the new prices are available, the stake can be calculated using the
    opening price. This assumes that one is for example getting a good
    indication about the 
open
 from watching the opening auction.

Running with daily bars

The sample 
scheduled.py
 defaults to running with the standard daily bars
available in the 
backtrader
 distribution. The parameters to the strategy

```
class St(bt.Strategy):
    params = dict(
        when=bt.timer.SESSION_START,
        timer=True,
        cheat=False,
        offset=datetime.timedelta(),
        repeat=datetime.timedelta(),
        weekdays=[],
    )

```

And the data has the following session times:

start: 09:00

end: 17:30

Running with just a time

```
$ ./scheduled.py --strat when='datetime.time(15,30)'

strategy notify_timer with tid 0, when 2005-01-03 15:30:00 cheat False
1, 2005-01-03 17:30:00, Week 1, Day 1, O 2952.29, H 2989.61, L 2946.8, C 2970.02
strategy notify_timer with tid 0, when 2005-01-04 15:30:00 cheat False
2, 2005-01-04 17:30:00, Week 1, Day 2, O 2969.78, H 2979.88, L 2961.14, C 2971.12
strategy notify_timer with tid 0, when 2005-01-05 15:30:00 cheat False
3, 2005-01-05 17:30:00, Week 1, Day 3, O 2969.0, H 2969.0, L 2942.69, C 2947.19
strategy notify_timer with tid 0, when 2005-01-06 15:30:00 cheat False
...

```

As specified the timer is ticking at 
15:30
. No surprises there. Let’s add
an offset of 30 minutes.

```
$ ./scheduled.py --strat when='datetime.time(15,30)',offset='datetime.timedelta(minutes=30)'

strategy notify_timer with tid 0, when 2005-01-03 16:00:00 cheat False
1, 2005-01-03 17:30:00, Week 1, Day 1, O 2952.29, H 2989.61, L 2946.8, C 2970.02
strategy notify_timer with tid 0, when 2005-01-04 16:00:00 cheat False
2, 2005-01-04 17:30:00, Week 1, Day 2, O 2969.78, H 2979.88, L 2961.14, C 2971.12
strategy notify_timer with tid 0, when 2005-01-05 16:00:00 cheat False
...

```

And the time has changed from 
15:30
 to 
16:00
 for the timer. No
surprises. Let’s do the same but referencing the start of the session.

```
$ ./scheduled.py --strat when='bt.timer.SESSION_START',offset='datetime.timedelta(minutes=30)'

strategy notify_timer with tid 0, when 2005-01-03 09:30:00 cheat False
1, 2005-01-03 17:30:00, Week 1, Day 1, O 2952.29, H 2989.61, L 2946.8, C 2970.02
strategy notify_timer with tid 0, when 2005-01-04 09:30:00 cheat False
2, 2005-01-04 17:30:00, Week 1, Day 2, O 2969.78, H 2979.88, L 2961.14, C 2971.12
...

```

Et voilá! The time at which the callback is called is 
09:30
. And the
session start, see above, is 
09:00
. This gives the ability to simply say
that one wants to execute an action 
30 minutes
 after the start of the
session.

Let’s add a repetition:

```
$ ./scheduled.py --strat when='bt.timer.SESSION_START',offset='datetime.timedelta(minutes=30)',repeat='datetime.timedelta(minutes=30)'

strategy notify_timer with tid 0, when 2005-01-03 09:30:00 cheat False
1, 2005-01-03 17:30:00, Week 1, Day 1, O 2952.29, H 2989.61, L 2946.8, C 2970.02
strategy notify_timer with tid 0, when 2005-01-04 09:30:00 cheat False
2, 2005-01-04 17:30:00, Week 1, Day 2, O 2969.78, H 2979.88, L 2961.14, C 2971.12
strategy notify_timer with tid 0, when 2005-01-05 09:30:00 cheat False
...

```

There is no repetition
. The reason being that the resolution of the prices
is daily. The timer is called for the 1
st
 time at 
09:30
 like in the
previous example. But when the system get the next batch of prices, they are
happening on the next day. And the timer can only, obviously, be called once. A
lower resolution is needed.

But before moving on to a lower resolution, let’s cheat by having the timer
called before the end of the session.

```
$ ./scheduled.py --strat when='bt.timer.SESSION_START',cheat=True

strategy notify_timer with tid 1, when 2005-01-03 09:00:00 cheat True
-- 2005-01-03 Create buy order
strategy notify_timer with tid 0, when 2005-01-03 09:00:00 cheat False
1, 2005-01-03 17:30:00, Week 1, Day 1, O 2952.29, H 2989.61, L 2946.8, C 2970.02
strategy notify_timer with tid 1, when 2005-01-04 09:00:00 cheat True
strategy notify_timer with tid 0, when 2005-01-04 09:00:00 cheat False
-- 2005-01-04 Buy Exec @ 2969.78
2, 2005-01-04 17:30:00, Week 1, Day 2, O 2969.78, H 2979.88, L 2961.14, C 2971.12
strategy notify_timer with tid 1, when 2005-01-05 09:00:00 cheat True
strategy notify_timer with tid 0, when 2005-01-05 09:00:00 cheat False
...

```

The strategy adds a 2
nd
 timer with 
cheat=True
. This is added 2
nd
 and will
therefore received the 2
nd

tid
 (
timer id
) which is 
1
 (see in the
above examples that the assigned 
tid
 was 
0
)

And 
1
 is called before 
0
, because that timer is 
cheating
 and is being
called before many events in the system happen (see above for the explanation)

Due to the 
daily
 resolution of the prices it doesn’t make much of a
difference except that:

The strategy also issues an order right before the open … and it is being
    matched with the opening price the next day

This, even if cheating by acting before the open, is still the normal
behavior, because 
cheating-on-open
 has also not been activated in the
broker.

The same but with 
coo=True
 for the broker

```
$ ./scheduled.py --strat when='bt.timer.SESSION_START',cheat=True --broker coo=True

strategy notify_timer with tid 1, when 2005-01-03 09:00:00 cheat True
-- 2005-01-03 Create buy order
strategy notify_timer with tid 0, when 2005-01-03 09:00:00 cheat False
-- 2005-01-03 Buy Exec @ 2952.29
1, 2005-01-03 17:30:00, Week 1, Day 1, O 2952.29, H 2989.61, L 2946.8, C 2970.02
strategy notify_timer with tid 1, when 2005-01-04 09:00:00 cheat True
strategy notify_timer with tid 0, when 2005-01-04 09:00:00 cheat False
2, 2005-01-04 17:30:00, Week 1, Day 2, O 2969.78, H 2979.88, L 2961.14, C 2971.12
strategy notify_timer with tid 1, when 2005-01-05 09:00:00 cheat True
strategy notify_timer with tid 0, when 2005-01-05 09:00:00 cheat False
...

```

And something has changed.

The order is issued on 
2005-01-03
 in the cheating timer

The order is executed on 
2005-01-03
 with the opening price

Effectively like if one had acted on the opening auction price seconds
before the real opening of the market.

Running with 5-minute bars

The sample 
scheduled-min.py
 defaults to running with the standard 5-minute
bars available in the 
backtrader
 distribution. The parameters to the strategy
are extended to include 
monthdays
 and the 
carry
 options

```
class St(bt.Strategy):
    params = dict(
        when=bt.timer.SESSION_START,
        timer=True,
        cheat=False,
        offset=datetime.timedelta(),
        repeat=datetime.timedelta(),
        weekdays=[],
        weekcarry=False,
        monthdays=[],
        monthcarry=True,
    )

```

The data has the same session times:

start: 09:00

end: 17:30

Let’s do some experiments. First a single timer.

```
$ ./scheduled-min.py --strat when='datetime.time(15, 30)'

1, 2006-01-02 09:05:00, Week 1, Day 1, O 3578.73, H 3587.88, L 3578.73, C 3582.99
2, 2006-01-02 09:10:00, Week 1, Day 1, O 3583.01, H 3588.4, L 3583.01, C 3588.03
...
77, 2006-01-02 15:25:00, Week 1, Day 1, O 3599.07, H 3599.68, L 3598.47, C 3599.68
strategy notify_timer with tid 0, when 2006-01-02 15:30:00 cheat False
78, 2006-01-02 15:30:00, Week 1, Day 1, O 3599.64, H 3599.73, L 3599.0, C 3599.67
...
179, 2006-01-03 15:25:00, Week 1, Day 2, O 3634.72, H 3635.0, L 3634.06, C 3634.87
strategy notify_timer with tid 0, when 2006-01-03 15:30:00 cheat False
180, 2006-01-03 15:30:00, Week 1, Day 2, O 3634.81, H 3634.89, L 3634.04, C 3634.23
...

```

The timer kicks in as requested at 
15:30
. The log shows how it does that
during the 1
st
 two days.

Adding a 
repeat
 of 
15 minutes
 to the mix

```
$ ./scheduled-min.py --strat when='datetime.time(15, 30)',repeat='datetime.timedelta(minutes=15)'

...
74, 2006-01-02 15:10:00, Week 1, Day 1, O 3596.12, H 3596.63, L 3595.92, C 3596.63
75, 2006-01-02 15:15:00, Week 1, Day 1, O 3596.36, H 3596.65, L 3596.19, C 3596.65
76, 2006-01-02 15:20:00, Week 1, Day 1, O 3596.53, H 3599.13, L 3596.12, C 3598.9
77, 2006-01-02 15:25:00, Week 1, Day 1, O 3599.07, H 3599.68, L 3598.47, C 3599.68
strategy notify_timer with tid 0, when 2006-01-02 15:30:00 cheat False
78, 2006-01-02 15:30:00, Week 1, Day 1, O 3599.64, H 3599.73, L 3599.0, C 3599.67
79, 2006-01-02 15:35:00, Week 1, Day 1, O 3599.61, H 3600.29, L 3599.52, C 3599.92
80, 2006-01-02 15:40:00, Week 1, Day 1, O 3599.96, H 3602.06, L 3599.76, C 3602.05
strategy notify_timer with tid 0, when 2006-01-02 15:45:00 cheat False
81, 2006-01-02 15:45:00, Week 1, Day 1, O 3601.97, H 3602.07, L 3601.45, C 3601.83
82, 2006-01-02 15:50:00, Week 1, Day 1, O 3601.74, H 3602.8, L 3601.63, C 3602.8
83, 2006-01-02 15:55:00, Week 1, Day 1, O 3602.53, H 3602.74, L 3602.33, C 3602.61
strategy notify_timer with tid 0, when 2006-01-02 16:00:00 cheat False
84, 2006-01-02 16:00:00, Week 1, Day 1, O 3602.58, H 3602.75, L 3601.81, C 3602.14
85, 2006-01-02 16:05:00, Week 1, Day 1, O 3602.16, H 3602.16, L 3600.86, C 3600.96
86, 2006-01-02 16:10:00, Week 1, Day 1, O 3601.2, H 3601.49, L 3600.94, C 3601.27
...
strategy notify_timer with tid 0, when 2006-01-02 17:15:00 cheat False
99, 2006-01-02 17:15:00, Week 1, Day 1, O 3603.96, H 3603.96, L 3602.89, C 3603.79
100, 2006-01-02 17:20:00, Week 1, Day 1, O 3603.94, H 3605.95, L 3603.87, C 3603.91
101, 2006-01-02 17:25:00, Week 1, Day 1, O 3604.0, H 3604.76, L 3603.85, C 3604.64
strategy notify_timer with tid 0, when 2006-01-02 17:30:00 cheat False
102, 2006-01-02 17:30:00, Week 1, Day 1, O 3604.06, H 3604.41, L 3603.95, C 3604.33
103, 2006-01-03 09:05:00, Week 1, Day 2, O 3604.08, H 3609.6, L 3604.08, C 3609.6
104, 2006-01-03 09:10:00, Week 1, Day 2, O 3610.34, H 3617.31, L 3610.34, C 3617.31
105, 2006-01-03 09:15:00, Week 1, Day 2, O 3617.61, H 3617.87, L 3616.03, C 3617.51
106, 2006-01-03 09:20:00, Week 1, Day 2, O 3617.24, H 3618.86, L 3616.09, C 3618.42
...
179, 2006-01-03 15:25:00, Week 1, Day 2, O 3634.72, H 3635.0, L 3634.06, C 3634.87
strategy notify_timer with tid 0, when 2006-01-03 15:30:00 cheat False
180, 2006-01-03 15:30:00, Week 1, Day 2, O 3634.81, H 3634.89, L 3634.04, C 3634.23
...

```

As expected the 1
st
 call is triggered at 
15:30
 and then starts repeating
every 15 minutes until the end of the session at 
17:30
. When the new session
kicks in, the timer has been reset to 
15:30
 again.

And now with cheating before the session start

```
$ ./scheduled-min.py --strat when='bt.timer.SESSION_START',cheat=True

strategy notify_timer with tid 1, when 2006-01-02 09:00:00 cheat True
-- 2006-01-02 09:05:00 Create buy order
strategy notify_timer with tid 0, when 2006-01-02 09:00:00 cheat False
1, 2006-01-02 09:05:00, Week 1, Day 1, O 3578.73, H 3587.88, L 3578.73, C 3582.99
-- 2006-01-02 09:10:00 Buy Exec @ 3583.01
2, 2006-01-02 09:10:00, Week 1, Day 1, O 3583.01, H 3588.4, L 3583.01, C 3588.03
...

```

Order creation is t 
09:05:00
 and execution at 
09:10:00
 because the
broker is not in 
cheat-on-open
 mode. Let’s set it …

```
$ ./scheduled-min.py --strat when='bt.timer.SESSION_START',cheat=True --broker coo=True

strategy notify_timer with tid 1, when 2006-01-02 09:00:00 cheat True
-- 2006-01-02 09:05:00 Create buy order
strategy notify_timer with tid 0, when 2006-01-02 09:00:00 cheat False
-- 2006-01-02 09:05:00 Buy Exec @ 3578.73
1, 2006-01-02 09:05:00, Week 1, Day 1, O 3578.73, H 3587.88, L 3578.73, C 3582.99
2, 2006-01-02 09:10:00, Week 1, Day 1, O 3583.01, H 3588.4, L 3583.01, C 3588.03
...

```

And the issuing time and execution time are 
09:05:00
 with the execution
price being the opening price at 
09:05:00
.

Additional scenarios

Timers allow specifying on which days they have to be executed by passing a
list of days (integers following the iso spec, where Mon=1 and Sun=7) as in

weekdays=[5]
 which would ask for the timer to only be valid on Fridays

In case a Friday is a non-trading day and the timer should kick-in on the
next trading day, one can add 
weekcarry=True

Similar to it, one can decide to act on the 15
th
 day of each month with:

monthdays=[15]

In case the 15
th
 happens to be non-trading day and the timer should kick-in
on the next trading day, one can add 
monthcarry=True

There isn’t an implementation for things like:  
the 3
rd
 Friday of March, June,
September and December
 (futures/options expirations), but there is a
possibility to implement rules by passing:

allow=callable
 where the callable accepts  
datetime.date

    instance. Notice this is not a 
datetime.datetime
 instance, because the

allow
 callable is only meant to decide if a given day is suitable for
    timers or not.

To implement something like the rule laid out above:

```
class FutOpExp(object):
    def __init__(self):
        self.fridays = 0
        self.curmonth = -1

    def __call__(self, d):
        _, _, isowkday = d.isocalendar()

        if d.month != self.curmonth:
            self.curmonth = d.month
            self.fridays = 0

        # Mon=1 ... Sun=7
        if isowkday == 5 and self.curmonth in [3, 6, 9, 12]:
            self.fridays += 1

            if self.friday == 3:  # 3rd Friday
                return True  # timer allowed

        return False  # timer disallowed

```

And one would pass 
allow=FutOpeExp()
 to the creation of the timer

This would allow a timer to kick in on the 3
rd
 Friday of those months and
may be close positions before the futures expire.

Parameters to 
add_timer

```
* `when`: can be

  * `datetime.time` instance (see below `tzdata`)

  * `bt.timer.SESSION_START` to reference a session start

  * `bt.timer.SESSION_END` to reference a session end

```

offset
 which must be a 
datetime.timedelta
 instance

Used to offset the value 
when
. It has a meaningful use in
combination with 
SESSION_START
 and 
SESSION_END
, to indicated
things like a timer being called 
15 minutes
 after the session
start.

repeat
 which must be a 
datetime.timedelta
 instance

Indicates if after a 1
st
 call, further calls will be scheduled
  within the same session at the scheduled 
repeat
 delta

Once the timer goes over the end of the session it is reset to the
  original value for 
when

weekdays
: a 
sorted
 iterable with integers indicating on
  which days (iso codes, Monday is 1, Sunday is 7) the timers can
  be actually invoked

If not specified, the timer will be active on all days

weekcarry
 (default: 
False
). If 
True
 and the weekday was
  not seen (ex: trading holiday), the timer will be executed on the
  next day (even if in a new week)

monthdays
: a 
sorted
 iterable with integers indicating on
  which days of the month a timer has to be executed. For example
  always on day 
15
 of the month

If not specified, the timer will be active on all days

monthcarry
 (default: 
True
). If the day was not seen
  (weekend, trading holiday), the timer will be executed on the next
  available day.

allow
 (default: 
None
). A callback which receives a
  datetime.date` instance and returns 
True
 if the date is
  allowed for timers or else returns 
False

tzdata
 which can be either 
None
 (default), a 
pytz

  instance or a 
data feed
 instance.

None
: 
when
 is interpreted at face value (which translates
  to handling it as if it where UTC even if it’s not)

pytz
 instance: 
when
 will be interpreted as being specified
  in the local time specified by the timezone instance.

data feed
 instance: 
when
 will be interpreted as being
  specified in the local time specified by the 
tz
 parameter of
  the data feed instance.

!!! note

```
  If `when` is either `SESSION_START` or `SESSION_END` and `tzdata` is
  `None`, the 1st *data feed* in the system (aka `self.data0`) will be
  used as the reference to find out the session times.

```

strats
 (default: 
False
) call also the 
notify_timer
 of
  strategies

cheat
 (default 
False
) if 
True
 the timer will be called
  before the broker has a chance to evaluate the orders. This opens
  the chance to issue orders based on opening price for example right
  before the session starts

*args
: any extra args will be passed to 
notify_timer

**kwargs
: any extra kwargs will be passed to 
notify_timer

Sample usage 
scheduled.py

```
$ ./scheduled.py --help
usage: scheduled.py [-h] [--data0 DATA0] [--fromdate FROMDATE]
                    [--todate TODATE] [--cerebro kwargs] [--broker kwargs]
                    [--sizer kwargs] [--strat kwargs] [--plot [kwargs]]

Sample Skeleton

optional arguments:
  -h, --help           show this help message and exit
  --data0 DATA0        Data to read in (default:
                       ../../datas/2005-2006-day-001.txt)
  --fromdate FROMDATE  Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )
  --todate TODATE      Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )
  --cerebro kwargs     kwargs in key=value format (default: )
  --broker kwargs      kwargs in key=value format (default: )
  --sizer kwargs       kwargs in key=value format (default: )
  --strat kwargs       kwargs in key=value format (default: )
  --plot [kwargs]      kwargs in key=value format (default: )

```

Sample usage 
scheduled-min.py

```
$ ./scheduled-min.py --help
usage: scheduled-min.py [-h] [--data0 DATA0] [--fromdate FROMDATE]
                        [--todate TODATE] [--cerebro kwargs] [--broker kwargs]
                        [--sizer kwargs] [--strat kwargs] [--plot [kwargs]]

Timer Test Intraday

optional arguments:
  -h, --help           show this help message and exit
  --data0 DATA0        Data to read in (default: ../../datas/2006-min-005.txt)
  --fromdate FROMDATE  Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )
  --todate TODATE      Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )
  --cerebro kwargs     kwargs in key=value format (default: )
  --broker kwargs      kwargs in key=value format (default: )
  --sizer kwargs       kwargs in key=value format (default: )
  --strat kwargs       kwargs in key=value format (default: )
  --plot [kwargs]      kwargs in key=value format (default: )

```

Sample source 
scheduled.py

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime

import backtrader as bt

class St(bt.Strategy):
    params = dict(
        when=bt.timer.SESSION_START,
        timer=True,
        cheat=False,
        offset=datetime.timedelta(),
        repeat=datetime.timedelta(),
        weekdays=[],
    )

    def __init__(self):
        bt.ind.SMA()
        if self.p.timer:
            self.add_timer(
                when=self.p.when,
                offset=self.p.offset,
                repeat=self.p.repeat,
                weekdays=self.p.weekdays,
            )
        if self.p.cheat:
            self.add_timer(
                when=self.p.when,
                offset=self.p.offset,
                repeat=self.p.repeat,
                cheat=True,
            )

        self.order = None

    def prenext(self):
        self.next()

    def next(self):
        _, isowk, isowkday = self.datetime.date().isocalendar()
        txt = '{}, {}, Week {}, Day {}, O {}, H {}, L {}, C {}'.format(
            len(self), self.datetime.datetime(),
            isowk, isowkday,
            self.data.open[0], self.data.high[0],
            self.data.low[0], self.data.close[0])

        print(txt)

    def notify_timer(self, timer, when, *args, **kwargs):
        print('strategy notify_timer with tid {}, when {} cheat {}'.
              format(timer.p.tid, when, timer.p.cheat))

        if self.order is None and timer.p.cheat:
            print('-- {} Create buy order'.format(self.data.datetime.date()))
            self.order = self.buy()

    def notify_order(self, order):
        if order.status == order.Completed:
            print('-- {} Buy Exec @ {}'.format(
                self.data.datetime.date(), order.executed.price))

def runstrat(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()

    # Data feed kwargs
    kwargs = dict(
        timeframe=bt.TimeFrame.Days,
        compression=1,
        sessionstart=datetime.time(9, 0),
        sessionend=datetime.time(17, 30),
    )

    # Parse from/to-date
    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'
    for a, d in ((getattr(args, x), x) for x in ['fromdate', 'todate']):
        if a:
            strpfmt = dtfmt + tmfmt * ('T' in a)
            kwargs[d] = datetime.datetime.strptime(a, strpfmt)

    # Data feed
    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)
    cerebro.adddata(data0)

    # Broker
    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' + args.broker + ')'))

    # Sizer
    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer + ')'))

    # Strategy
    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))

    # Execute
    cerebro.run(**eval('dict(' + args.cerebro + ')'))

    if args.plot:  # Plot if requested to
        cerebro.plot(**eval('dict(' + args.plot + ')'))

def parse_args(pargs=None):
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description=(
            'Sample Skeleton'
        )
    )

    parser.add_argument('--data0', default='../../datas/2005-2006-day-001.txt',
                        required=False, help='Data to read in')

    # Defaults for dates
    parser.add_argument('--fromdate', required=False, default='',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--todate', required=False, default='',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--cerebro', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--broker', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--sizer', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--strat', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--plot', required=False, default='',
                        nargs='?', const='{}',
                        metavar='kwargs', help='kwargs in key=value format')

    return parser.parse_args(pargs)

if __name__ == '__main__':
    runstrat()

```

Sample source 
scheduled-min.py

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime

import backtrader as bt

class St(bt.Strategy):
    params = dict(
        when=bt.timer.SESSION_START,
        timer=True,
        cheat=False,
        offset=datetime.timedelta(),
        repeat=datetime.timedelta(),
        weekdays=[],
        weekcarry=False,
        monthdays=[],
        monthcarry=True,
    )

    def __init__(self):
        bt.ind.SMA()
        if self.p.timer:
            self.add_timer(
                when=self.p.when,
                offset=self.p.offset,
                repeat=self.p.repeat,
                weekdays=self.p.weekdays,
                weekcarry=self.p.weekcarry,
                monthdays=self.p.monthdays,
                monthcarry=self.p.monthcarry,
                # tzdata=self.data0,
            )
        if self.p.cheat:
            self.add_timer(
                when=self.p.when,
                offset=self.p.offset,
                repeat=self.p.repeat,
                weekdays=self.p.weekdays,
                weekcarry=self.p.weekcarry,
                monthdays=self.p.monthdays,
                monthcarry=self.p.monthcarry,
                # tzdata=self.data0,
                cheat=True,
            )

        self.order = None

    def prenext(self):
        self.next()

    def next(self):
        _, isowk, isowkday = self.datetime.date().isocalendar()
        txt = '{}, {}, Week {}, Day {}, O {}, H {}, L {}, C {}'.format(
            len(self), self.datetime.datetime(),
            isowk, isowkday,
            self.data.open[0], self.data.high[0],
            self.data.low[0], self.data.close[0])

        print(txt)

    def notify_timer(self, timer, when, *args, **kwargs):
        print('strategy notify_timer with tid {}, when {} cheat {}'.
              format(timer.p.tid, when, timer.p.cheat))

        if self.order is None and timer.params.cheat:
            print('-- {} Create buy order'.format(
                self.data.datetime.datetime()))
            self.order = self.buy()

    def notify_order(self, order):
        if order.status == order.Completed:
            print('-- {} Buy Exec @ {}'.format(
                self.data.datetime.datetime(), order.executed.price))

def runstrat(args=None):
    args = parse_args(args)
    cerebro = bt.Cerebro()

    # Data feed kwargs
    kwargs = dict(
        timeframe=bt.TimeFrame.Minutes,
        compression=5,
        sessionstart=datetime.time(9, 0),
        sessionend=datetime.time(17, 30),
    )

    # Parse from/to-date
    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'
    for a, d in ((getattr(args, x), x) for x in ['fromdate', 'todate']):
        if a:
            strpfmt = dtfmt + tmfmt * ('T' in a)
            kwargs[d] = datetime.datetime.strptime(a, strpfmt)

    # Data feed
    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)
    cerebro.adddata(data0)

    # Broker
    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' + args.broker + ')'))

    # Sizer
    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer + ')'))

    # Strategy
    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))

    # Execute
    cerebro.run(**eval('dict(' + args.cerebro + ')'))

    if args.plot:  # Plot if requested to
        cerebro.plot(**eval('dict(' + args.plot + ')'))

def parse_args(pargs=None):
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description=(
            'Timer Test Intraday'
        )
    )

    parser.add_argument('--data0', default='../../datas/2006-min-005.txt',
                        required=False, help='Data to read in')

    # Defaults for dates
    parser.add_argument('--fromdate', required=False, default='',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--todate', required=False, default='',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--cerebro', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--broker', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--sizer', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--strat', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--plot', required=False, default='',
                        nargs='?', const='{}',
                        metavar='kwargs', help='kwargs in key=value format')

    return parser.parse_args(pargs)

if __name__ == '__main__':
    runstrat()

```
########################################
docu-trade.txt - lunghezza: 2496
########################################
Trade

Definition of a trade:

A Trade is open when the a position in a instrument goes from 0 to a size X
    which may positive/negative for long/short positions)

A Trade is closed when a position goes from X to 0.

The followig two actions:

positive to negative

negative to positive

Are actually seen as:

A trade has been closed (position went to 0 from X)

A new trade has been open (position goes from 0 to Y)

Trades are only informative and have no user callable methods.

Reference: Trade

class backtrader.trade.Trade(data=None, tradeid=0, historyon=False, size=0, price=0.0, value=0.0, commission=0.0)

Keeps track of the life of an trade: size, price,
commission (and value?)

An trade starts at 0 can be increased and reduced and can
be considered closed if it goes back to 0.

The trade can be long (positive size) or short (negative size)

An trade is not meant to be reversed (no support in the logic for it)

Member Attributes:

ref
: unique trade identifier

status
 (
int
): one of Created, Open, Closed

tradeid
: grouping tradeid passed to orders during creation
    The default in orders is 0

size
 (
int
): current size of the trade

price
 (
float
): current price of the trade

value
 (
float
): current value of the trade

commission
 (
float
): current accumulated commission

pnl
 (
float
): current profit and loss of the trade (gross pnl)

pnlcomm
 (
float
): current profit and loss of the trade minus
    commission (net pnl)

isclosed
 (
bool
): records if the last update closed (set size to
    null the trade

isopen
 (
bool
): records if any update has opened the trade

justopened
 (
bool
): if the trade was just opened

baropen
 (
int
): bar in which this trade was opened

dtopen
 (
float
): float coded datetime in which the trade was
    opened

Use method 
open_datetime
 to get a Python datetime.datetime
  or use the platform provided 
num2date
 method

barclose
 (
int
): bar in which this trade was closed

dtclose
 (
float
): float coded datetime in which the trade was
    closed

Use method 
close_datetime
 to get a Python datetime.datetime
  or use the platform provided 
num2date
 method

barlen
 (
int
): number of bars this trade was open

historyon
 (
bool
): whether history has to be recorded

history
 (
list
): holds a list updated with each “update” event
    containing the resulting status and parameters used in the update

The first entry in the history is the Opening Event
The last entry in the history is the Closing Event
########################################
docu-tradingcalendar-tradingcalendar.txt - lunghezza: 27363
########################################
Trading Calendar

Release 
1.9.42.116
 adds support for 
Trading Calendars
. This is useful
when resampling in for example the following scenarios:

Daily to Weekly resampling can now deliver the weekly bar together with the
    last bar of the week.

This is so because the trading calendar identifies the 
next trading
 day
and the 
last trading day
 of the week can be identified in advance

Sub-daily to Daily resampling when the end of the session is not the
    regular one (which can already be specified to the data feed)

Trading Calendar Interface

There is a base class 
TradingCalendarBase
 which is used as a base for any
trading calendar. It defines two (2) methods which have to be overridden:

```
class TradingCalendarBase(with_metaclass(MetaParams, object)):
    def _nextday(self, day):
        '''
        Returns the next trading day (datetime/date instance) after ``day``
        (datetime/date instance) and the isocalendar components

        The return value is a tuple with 2 components: (nextday, (y, w, d))
        where (y, w, d)
        '''
        raise NotImplementedError

    def schedule(self, day):
        '''
        Returns a tuple with the opening and closing times (``datetime.time``)
        for the given ``date`` (``datetime/date`` instance)
        '''
        raise NotImplementedError

```

Implementations

PandasMarketCalendar

This implementation is based on a neat package which is a spin-off of initial
functionality available from Quantopian. The packages is at:

pandas_market_calendars
 and can be easily
installed:

```
pip install pandas_market_calendars

```

The implementation features the following interface:

```
class PandasMarketCalendar(TradingCalendarBase):
    '''
    Wrapper of ``pandas_market_calendars`` for a trading calendar. The package
    ``pandas_market_calendar`` must be installed

    Params:

      - ``calendar`` (default ``None``)

        The param ``calendar`` accepts the following:

        - string: the name of one of the calendars supported, for example
          `NYSE`. The wrapper will attempt to get a calendar instance

        - calendar instance: as returned by ``get_calendar('NYSE')``

      - ``cachesize`` (default ``365``)

        Number of days to cache in advance for lookup

    See also:

      - https://github.com/rsheftel/pandas_market_calendars

      - http://pandas-market-calendars.readthedocs.io/

    '''
    params = (
        ('calendar', None),  # A pandas_market_calendars instance or exch name
        ('cachesize', 365),  # Number of days to cache in advance
    )

```

TradingCalendar

This implementation allows to construct a calendar using self-gathered
information by specifying the holidays, early days, non-trading weekdays and
the opening and closing session times:

```
class TradingCalendar(TradingCalendarBase):
    '''
    Wrapper of ``pandas_market_calendars`` for a trading calendar. The package
    ``pandas_market_calendar`` must be installed

    Params:

      - ``open`` (default ``time.min``)

        Regular start of the session

      - ``close`` (default ``time.max``)

        Regular end of the session

      - ``holidays`` (default ``[]``)

        List of non-trading days (``datetime.datetime`` instances)

      - ``earlydays`` (default ``[]``)

        List of tuples determining the date and opening/closing times of days
        which do not conform to the regular trading hours where each tuple has
        (``datetime.datetime``, ``datetime.time``, ``datetime.time`` )

      - ``offdays`` (default ``ISOWEEKEND``)

        A list of weekdays in ISO format (Monday: 1 -> Sunday: 7) in which the
        market doesn't trade. This is usually Saturday and Sunday and hence the
        default

    '''
    params = (
        ('open', time.min),
        ('close', _time_max),
        ('holidays', []),  # list of non trading days (date)
        ('earlydays', []),  # list of tuples (date, opentime, closetime)
        ('offdays', ISOWEEKEND),  # list of non trading (isoweekdays)
    )

```

Usage pattern

Global Trading Calendar

Via 
Cerebro
 one can add a global calendar which is the default for all data
feeds, unless one is specified for the data feed:

```
def addcalendar(self, cal):
    '''Adds a global trading calendar to the system. Individual data feeds
    may have separate calendars which override the global one

    ``cal`` can be an instance of ``TradingCalendar`` a string or an
    instance of ``pandas_market_calendars``. A string will be will be
    instantiated as a ``PandasMarketCalendar`` (which needs the module
    ``pandas_market_calendar`` installed in the system.

    If a subclass of `TradingCalendarBase` is passed (not an instance) it
    will be instantiated
    '''

```

Per data-feed

By specifying a 
calendar
 parameter following the same conventions as
described above in 
addcalendar
.

For example:

```
...
data = bt.feeds.YahooFinanceData(dataname='YHOO', calendar='NYSE', ...)
cerebro.adddata(data)
...

```

Examples

Daily to Weekly

Let’s have a look at a sample run of the code that can be found below. In 2016,
Easter Friday (2016-03-25) was a holiday also in the 
NYSE
. If the sample is
run with no trading calendar, let’s see what happens around that date.

In this case the resampling is being done from daily to weekly (using 
YHOO

and the daily data for 2016):

```
$ ./tcal.py

...
Strategy len 56 datetime 2016-03-23 Data0 len 56 datetime 2016-03-23 Data1 len 11 datetime 2016-03-18
Strategy len 57 datetime 2016-03-24 Data0 len 57 datetime 2016-03-24 Data1 len 11 datetime 2016-03-18
Strategy len 58 datetime 2016-03-28 Data0 len 58 datetime 2016-03-28 Data1 len 12 datetime 2016-03-24
...

```

In this output, the 1
st
 date is the accounting made by the strategy. The 2
nd

date is that of the daily

The week ends, as expected, on 2016-03-24 (Thursday), but without a trading
calendar the resampling code cannot know it and the resampled bar with date
2016-03-18 (the week before) is delivered. When the trading moves on to
2016-03-28 (Monday), the resampler detects the week change and delivers a
resampled bar for 2016-03-24.

The same but run with a 
PandasMarketCalendar
 for 
NYSE
 (and adding a plot)

```
$ ./tcal.py --plot --pandascal NYSE

...
Strategy len 56 datetime 2016-03-23 Data0 len 56 datetime 2016-03-23 Data1 len 11 datetime 2016-03-18
Strategy len 57 datetime 2016-03-24 Data0 len 57 datetime 2016-03-24 Data1 len 12 datetime 2016-03-24
Strategy len 58 datetime 2016-03-28 Data0 len 58 datetime 2016-03-28 Data1 len 12 datetime 2016-03-24
...

```

There is a change! Thanks to the calendar the resampler knows the week is over
on 2016-03-24 and delivers the corresponding weekly resampled bar for
2016-03-24 on the same day.

And the plot.

Since the information may not necessarily be available for each and every
market, one can also craft the calendar. For the 
NYSE
 and 
2016
 it looks like:

```
class NYSE_2016(bt.TradingCalendar):
    params = dict(
        holidays=[
            datetime.date(2016, 1, 1),
            datetime.date(2016, 1, 18),
            datetime.date(2016, 2, 15),
            datetime.date(2016, 3, 25),
            datetime.date(2016, 5, 30),
            datetime.date(2016, 7, 4),
            datetime.date(2016, 9, 5),
            datetime.date(2016, 11, 24),
            datetime.date(2016, 12, 26),
        ]
    )

```

Easter Friday (2016-03-25) is listed as one of the holidays. Running the sample
now:

```
$ ./tcal.py --plot --owncal

...
Strategy len 56 datetime 2016-03-23 Data0 len 56 datetime 2016-03-23 Data1 len 11 datetime 2016-03-18
Strategy len 57 datetime 2016-03-24 Data0 len 57 datetime 2016-03-24 Data1 len 12 datetime 2016-03-24
Strategy len 58 datetime 2016-03-28 Data0 len 58 datetime 2016-03-28 Data1 len 12 datetime 2016-03-24
...

```

And the same result has been obtained with the crafted calendar definition.

Minutes to Daily

Using some private intraday data and the knowledge that the market closed early
on 2016-11-25 (the day after Thanksgiving the market closed at 13:00 in

US/Eastern
 timezone), another test run, this time with the 2
nd

sample.

Note

The source data is taken directly from the displayed data and is in

CET
 timeozone even if the asset in question, 
YHOO
 trades in
the USA. The 
tzinput='CET'
 and 
tz='US/Eastern'
 is used in the
code for the data feed to let the platform appropriately transform
the input and display the output

First with no trading calendar

```
$ ./tcal-intra.py

...
Strategy len 6838 datetime 2016-11-25 18:00:00 Data0 len 6838 datetime 2016-11-25 13:00:00 Data1 len 21 datetime 2016-11-23 16:00:00
Strategy len 6839 datetime 2016-11-25 18:01:00 Data0 len 6839 datetime 2016-11-25 13:01:00 Data1 len 21 datetime 20 16-11-23 16:00:00
Strategy len 6840 datetime 2016-11-28 14:31:00 Data0 len 6840 datetime 2016-11-28 09:31:00 Data1 len 22 datetime 2016-11-25 16:00:00
Strategy len 6841 datetime 2016-11-28 14:32:00 Data0 len 6841 datetime 2016-11-28 09:32:00 Data1 len 22 datetime 2016-11-25 16:00:00
...

```

As expected the day closes early at 
13:00
, but the resampler doesn’t know
it (the official session ends at 
16:00
) and keeps on delivering the
resampled daily bar from the previous day (2016-11-23) and the new resampled daily bar is first
delivered during the next trading day (2016-11-28) with a date of 2016-11-25.

Note

The data has an extra minute bar at 
13:01
 which is probably due
to the auction process offering a last price after the market closing
time.

We could add a filter to the stream to filter out the bars outside of
the session times (the filter would find it out from the trading
calendar)

But that’s not the point of this sample.

The same run with a 
PandasMarketCalendar
 instance:

```
$ ./tcal-intra.py --pandascal NYSE

...
Strategy len 6838 datetime 2016-11-25 18:00:00 Data0 len 6838 datetime 2016-11-25 13:00:00 Data1 len 15 datetime 2016-11-25 13:00:00
Strategy len 6839 datetime 2016-11-25 18:01:00 Data0 len 6839 datetime 2016-11-25 13:01:00 Data1 len 15 datetime 2016-11-25 13:00:00
Strategy len 6840 datetime 2016-11-28 14:31:00 Data0 len 6840 datetime 2016-11-28 09:31:00 Data1 len 15 datetime 2016-11-25 13:00:00
Strategy len 6841 datetime 2016-11-28 14:32:00 Data0 len 6841 datetime 2016-11-28 09:32:00 Data1 len 15 datetime 2016-11-25 13:00:00
...

```

And now the daily bar for 2016-11-25 is delivered when the intraday 1-minute
feed hits 2016-11-25 at 13:00 (let’s disregard the 13:01 bar), because the
trading calendar is telling the resampling code that the day is over.

Let’s add a crafted definition. The same as before but extending it with some 
earlydays

```
class NYSE_2016(bt.TradingCalendar):
    params = dict(
        holidays=[
            datetime.date(2016, 1, 1),
            datetime.date(2016, 1, 18),
            datetime.date(2016, 2, 15),
            datetime.date(2016, 3, 25),
            datetime.date(2016, 5, 30),
            datetime.date(2016, 7, 4),
            datetime.date(2016, 9, 5),
            datetime.date(2016, 11, 24),
            datetime.date(2016, 12, 26),
        ],
        earlydays=[
            (datetime.date(2016, 11, 25),
             datetime.time(9, 30), datetime.time(13, 1))
        ],
        open=datetime.time(9, 30),
        close=datetime.time(16, 0),
    )

```

The run:

```
$ ./tcal-intra.py --owncal

...
Strategy len 6838 datetime 2016-11-25 18:00:00 Data0 len 6838 datetime 2016-11-25 13:00:00 Data1 len 15 datetime 2016-11-23 16:00:00
Strategy len 6839 datetime 2016-11-25 18:01:00 Data0 len 6839 datetime 2016-11-25 13:01:00 Data1 len 16 datetime 2016-11-25 13:01:00
Strategy len 6840 datetime 2016-11-28 14:31:00 Data0 len 6840 datetime 2016-11-28 09:31:00 Data1 len 16 datetime 2016-11-25 13:01:00
Strategy len 6841 datetime 2016-11-28 14:32:00 Data0 len 6841 datetime 2016-11-28 09:32:00 Data1 len 16 datetime 2016-11-25 13:01:00
...

```

The avid reader will notice that the crafted definition contains has defined

13:01
 (with 
datetime.time(13, 1)
) as the end of session for our short
day of 2016-11-25. This is only to show how the crafted 
TradingCalendar
 can
help into fitting things.

Now the daily resampled bar for 2016-11-25 is delivered together with the
1-minute bar at 13:01.

Extra bonus for the strategy

The first 
datetime
, the one belonging to the strategy, is always in a
different timezone which is actually 
UTC
. Also with this release

1.9.42.116
 this can be synchronized. The following parameter has been added to

Cerebro
 (use either during instantiation or with 
cerebro.run

```
- ``tz`` (default: ``None``)

  Adds a global timezone for strategies. The argument ``tz`` can be

    - ``None``: in this case the datetime displayed by strategies will be
      in UTC, which has been always the standard behavior

    - ``pytz`` instance. It will be used as such to convert UTC times to
      the chosen timezone

    - ``string``. Instantiating a ``pytz`` instance will be attempted.

    - ``integer``. Use, for the strategy, the same timezone as the
      corresponding ``data`` in the ``self.datas`` iterable (``0`` would
      use the timezone from ``data0``)

```

It is also supported with the 
cerebro.addtz
 method:

```
def addtz(self, tz):
    '''
    This can also be done with the parameter ``tz``

    Adds a global timezone for strategies. The argument ``tz`` can be

      - ``None``: in this case the datetime displayed by strategies will be
        in UTC, which has been always the standard behavior

      - ``pytz`` instance. It will be used as such to convert UTC times to
        the chosen timezone

      - ``string``. Instantiating a ``pytz`` instance will be attempted.

      - ``integer``. Use, for the strategy, the same timezone as the
        corresponding ``data`` in the ``self.datas`` iterable (``0`` would
        use the timezone from ``data0``)

    '''

```

Repeating the last run of the intraday sample and using 
0
 for 
tz

(synchronize with the timezone of 
data0
) the following is the output
focusing on the same dates and times as above:

```
$ ./tcal-intra.py --owncal --cerebro tz=0

...
Strategy len 6838 datetime 2016-11-25 13:00:00 Data0 len 6838 datetime 2016-11-25 13:00:00 Data1 len 15 datetime 2016-11-23 16:00:00
Strategy len 6839 datetime 2016-11-25 13:01:00 Data0 len 6839 datetime 2016-11-25 13:01:00 Data1 len 16 datetime 2016-11-25 13:01:00
Strategy len 6840 datetime 2016-11-28 09:31:00 Data0 len 6840 datetime 2016-11-28 09:31:00 Data1 len 16 datetime 2016-11-25 13:01:00
Strategy len 6841 datetime 2016-11-28 09:32:00 Data0 len 6841 datetime 2016-11-28 09:32:00 Data1 len 16 datetime 2016-11-25 13:01:00
...

```

The timestamp is now timezone aligned.

Sample usage (tcal.py)

```
$ ./tcal.py --help
usage: tcal.py [-h] [--data0 DATA0] [--offline] [--fromdate FROMDATE]
               [--todate TODATE] [--cerebro kwargs] [--broker kwargs]
               [--sizer kwargs] [--strat kwargs] [--plot [kwargs]]
               [--pandascal PANDASCAL | --owncal]
               [--timeframe {Weeks,Months,Years}]

Trading Calendar Sample

optional arguments:
  -h, --help            show this help message and exit
  --data0 DATA0         Data to read in (default: YHOO)
  --offline             Read from disk with same name as ticker (default:
                        False)
  --fromdate FROMDATE   Date[time] in YYYY-MM-DD[THH:MM:SS] format (default:
                        2016-01-01)
  --todate TODATE       Date[time] in YYYY-MM-DD[THH:MM:SS] format (default:
                        2016-12-31)
  --cerebro kwargs      kwargs in key=value format (default: )
  --broker kwargs       kwargs in key=value format (default: )
  --sizer kwargs        kwargs in key=value format (default: )
  --strat kwargs        kwargs in key=value format (default: )
  --plot [kwargs]       kwargs in key=value format (default: )
  --pandascal PANDASCAL
                        Name of trading calendar to use (default: )
  --owncal              Apply custom NYSE 2016 calendar (default: False)
  --timeframe {Weeks,Months,Years}
                        Timeframe to resample to (default: Weeks)

```

Sample usage (tcal-intra.py)

```
$ ./tcal-intra.py --help
usage: tcal-intra.py [-h] [--data0 DATA0] [--fromdate FROMDATE]
                     [--todate TODATE] [--cerebro kwargs] [--broker kwargs]
                     [--sizer kwargs] [--strat kwargs] [--plot [kwargs]]
                     [--pandascal PANDASCAL | --owncal] [--timeframe {Days}]

Trading Calendar Sample

optional arguments:
  -h, --help            show this help message and exit
  --data0 DATA0         Data to read in (default: yhoo-2016-11.csv)
  --fromdate FROMDATE   Date[time] in YYYY-MM-DD[THH:MM:SS] format (default:
                        2016-01-01)
  --todate TODATE       Date[time] in YYYY-MM-DD[THH:MM:SS] format (default:
                        2016-12-31)
  --cerebro kwargs      kwargs in key=value format (default: )
  --broker kwargs       kwargs in key=value format (default: )
  --sizer kwargs        kwargs in key=value format (default: )
  --strat kwargs        kwargs in key=value format (default: )
  --plot [kwargs]       kwargs in key=value format (default: )
  --pandascal PANDASCAL
                        Name of trading calendar to use (default: )
  --owncal              Apply custom NYSE 2016 calendar (default: False)
  --timeframe {Days}    Timeframe to resample to (default: Days)

```

Sample Code (tcal.py)

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime

import backtrader as bt

class NYSE_2016(bt.TradingCalendar):
    params = dict(
        holidays=[
            datetime.date(2016, 1, 1),
            datetime.date(2016, 1, 18),
            datetime.date(2016, 2, 15),
            datetime.date(2016, 3, 25),
            datetime.date(2016, 5, 30),
            datetime.date(2016, 7, 4),
            datetime.date(2016, 9, 5),
            datetime.date(2016, 11, 24),
            datetime.date(2016, 12, 26),
        ]
    )

class St(bt.Strategy):
    params = dict(
    )

    def __init__(self):
        pass

    def start(self):
        self.t0 = datetime.datetime.utcnow()

    def stop(self):
        t1 = datetime.datetime.utcnow()
        print('Duration:', t1 - self.t0)

    def prenext(self):
        self.next()

    def next(self):
        print('Strategy len {} datetime {}'.format(
            len(self), self.datetime.date()), end=' ')

        print('Data0 len {} datetime {}'.format(
            len(self.data0), self.data0.datetime.date()), end=' ')

        if len(self.data1):
            print('Data1 len {} datetime {}'.format(
                len(self.data1), self.data1.datetime.date()))
        else:
            print()

def runstrat(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()

    # Data feed kwargs
    kwargs = dict()

    # Parse from/to-date
    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'
    for a, d in ((getattr(args, x), x) for x in ['fromdate', 'todate']):
        if a:
            strpfmt = dtfmt + tmfmt * ('T' in a)
            kwargs[d] = datetime.datetime.strptime(a, strpfmt)

    YahooData = bt.feeds.YahooFinanceData
    if args.offline:
        YahooData = bt.feeds.YahooFinanceCSVData  # change to read file

    # Data feed
    data0 = YahooData(dataname=args.data0, **kwargs)
    cerebro.adddata(data0)

    d1 = cerebro.resampledata(data0,
                              timeframe=getattr(bt.TimeFrame, args.timeframe))
    d1.plotinfo.plotmaster = data0
    d1.plotinfo.sameaxis = True

    if args.pandascal:
        cerebro.addcalendar(args.pandascal)
    elif args.owncal:
        cerebro.addcalendar(NYSE_2016)

    # Broker
    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' + args.broker + ')'))

    # Sizer
    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer + ')'))

    # Strategy
    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))

    # Execute
    cerebro.run(**eval('dict(' + args.cerebro + ')'))

    if args.plot:  # Plot if requested to
        cerebro.plot(**eval('dict(' + args.plot + ')'))

def parse_args(pargs=None):
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description=(
            'Trading Calendar Sample'
        )
    )

    parser.add_argument('--data0', default='YHOO',
                        required=False, help='Data to read in')

    parser.add_argument('--offline', required=False, action='store_true',
                        help='Read from disk with same name as ticker')

    # Defaults for dates
    parser.add_argument('--fromdate', required=False, default='2016-01-01',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--todate', required=False, default='2016-12-31',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--cerebro', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--broker', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--sizer', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--strat', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--plot', required=False, default='',
                        nargs='?', const='{}',
                        metavar='kwargs', help='kwargs in key=value format')

    pgroup = parser.add_mutually_exclusive_group(required=False)
    pgroup.add_argument('--pandascal', required=False, action='store',
                        default='', help='Name of trading calendar to use')

    pgroup.add_argument('--owncal', required=False, action='store_true',
                        help='Apply custom NYSE 2016 calendar')

    parser.add_argument('--timeframe', required=False, action='store',
                        default='Weeks', choices=['Weeks', 'Months', 'Years'],
                        help='Timeframe to resample to')

    return parser.parse_args(pargs)

if __name__ == '__main__':
    runstrat()

```

Sample Code (tcal-intra.py)

```
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime

import backtrader as bt

class NYSE_2016(bt.TradingCalendar):
    params = dict(
        holidays=[
            datetime.date(2016, 1, 1),
            datetime.date(2016, 1, 18),
            datetime.date(2016, 2, 15),
            datetime.date(2016, 3, 25),
            datetime.date(2016, 5, 30),
            datetime.date(2016, 7, 4),
            datetime.date(2016, 9, 5),
            datetime.date(2016, 11, 24),
            datetime.date(2016, 12, 26),
        ],
        earlydays=[
            (datetime.date(2016, 11, 25),
             datetime.time(9, 30), datetime.time(13, 1))
        ],
        open=datetime.time(9, 30),
        close=datetime.time(16, 0),
    )

class St(bt.Strategy):
    params = dict(
    )

    def __init__(self):
        pass

    def prenext(self):
        self.next()

    def next(self):
        print('Strategy len {} datetime {}'.format(
            len(self), self.datetime.datetime()), end=' ')

        print('Data0 len {} datetime {}'.format(
            len(self.data0), self.data0.datetime.datetime()), end=' ')

        if len(self.data1):
            print('Data1 len {} datetime {}'.format(
                len(self.data1), self.data1.datetime.datetime()))
        else:
            print()

def runstrat(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()

    # Data feed kwargs
    # kwargs = dict(tz='US/Eastern')
    # import pytz
    # tz = tzinput = pytz.timezone('Europe/Berlin')
    tzinput = 'Europe/Berlin'
    # tz = tzinput
    tz = 'US/Eastern'
    kwargs = dict(tzinput=tzinput, tz=tz)

    # Parse from/to-date
    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'
    for a, d in ((getattr(args, x), x) for x in ['fromdate', 'todate']):
        if a:
            strpfmt = dtfmt + tmfmt * ('T' in a)
            kwargs[d] = datetime.datetime.strptime(a, strpfmt)

    # Data feed
    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)
    cerebro.adddata(data0)

    d1 = cerebro.resampledata(data0,
                              timeframe=getattr(bt.TimeFrame, args.timeframe))
    # d1.plotinfo.plotmaster = data0
    # d1.plotinfo.sameaxis = False

    if args.pandascal:
        cerebro.addcalendar(args.pandascal)
    elif args.owncal:
        cerebro.addcalendar(NYSE_2016())  # or NYSE_2016() to pass an instance

    # Broker
    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' + args.broker + ')'))

    # Sizer
    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer + ')'))

    # Strategy
    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))

    # Execute
    cerebro.run(**eval('dict(' + args.cerebro + ')'))

    if args.plot:  # Plot if requested to
        cerebro.plot(**eval('dict(' + args.plot + ')'))

def parse_args(pargs=None):
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description=(
            'Trading Calendar Sample'
        )
    )

    parser.add_argument('--data0', default='yhoo-2016-11.csv',
                        required=False, help='Data to read in')

    # Defaults for dates
    parser.add_argument('--fromdate', required=False, default='2016-01-01',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--todate', required=False, default='2016-12-31',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--cerebro', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--broker', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--sizer', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--strat', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--plot', required=False, default='',
                        nargs='?', const='{}',
                        metavar='kwargs', help='kwargs in key=value format')

    pgroup = parser.add_mutually_exclusive_group(required=False)
    pgroup.add_argument('--pandascal', required=False, action='store',
                        default='', help='Name of trading calendar to use')

    pgroup.add_argument('--owncal', required=False, action='store_true',
                        help='Apply custom NYSE 2016 calendar')

    parser.add_argument('--timeframe', required=False, action='store',
                        default='Days', choices=['Days'],
                        help='Timeframe to resample to')

    return parser.parse_args(pargs)

if __name__ == '__main__':
    runstrat()

```
########################################
docu-user-defined-commissions-commission-schemes-subclassing.txt - lunghezza: 6174
########################################
User Defined Commissions

The most important part of reworking the CommInfo object to the actual
incarnation involved:

Retaining the original 
CommissionInfo
 class and behavior

Opening the door for easy creation of user defined commissions

Making the format xx% the default for new commission schemes instead of 0.xx
    (just a matter of taste), keeping the behavior configurable

Note

See below the docstring of 
CommInfoBase
 for parameters reference

Defining a Commission Scheme

It involves 1 or 2 steps

Subclassing 
CommInfoBase

Simply changing the default parameters may be enough. 
backtrader

 already does this with some definitions present in the module

backtrader.commissions
. The regular industry standard for Futures is a
 fixed amount per contract and per round. The definition can be done as:

```
class CommInfo_Futures_Fixed(CommInfoBase):
    params = (
        ('stocklike', False),
        ('commtype', CommInfoBase.COMM_FIXED),
    )

```

For stocks and perc-wise commissions:

```
class CommInfo_Stocks_Perc(CommInfoBase):
    params = (
        ('stocklike', True),
        ('commtype', CommInfoBase.COMM_PERC),
    )

```

As stated above the default for the interpretation of the percentage here
 (passed as parameter 
commission
) is that of: 
xx%
. Should the
 old/other behavior be wished 
0.xx
, it can be easily done:

```
class CommInfo_Stocks_PercAbs(CommInfoBase):
    params = (
        ('stocklike', True),
        ('commtype', CommInfoBase.COMM_PERC),
        ('percabs', True),
    )

```

Overriding (if needed be) the 
_getcommission
 method

Defined as:

```
def _getcommission(self, size, price, pseudoexec):
   '''Calculates the commission of an operation at a given price

   pseudoexec: if True the operation has not yet been executed
   '''

```

More details in a practical example below

How to apply this to the platform

Once a 
CommInfoBase
 subclass is in place the trick is to use

broker.addcommissioninfo
 rather than the usual 
broker.setcommission
. The
latter will internally use the legacy 
CommissionInfoObject
.

Easier done than said:

```
...

comminfo = CommInfo_Stocks_PercAbs(commission=0.005)  # 0.5%
cerebro.broker.addcommissioninfo(comminfo)

```

The 
addcommissioninfo
 method is defined as follows:

```
def addcommissioninfo(self, comminfo, name=None):
    self.comminfo[name] = comminfo

```

Setting 
name
 means that the 
comminfo
 object will only apply to assets
with that name. The default value of 
None
 means it applies to all assets in
the system.

A practical example

Ticket #45
 asks about a
commission scheme which applies to Futures, is percentage wise and uses the
commission percentage on the entire “virtual” value of the contract. ie:
includes the future multiplier in the commission calculation.

It should be easy:

```
import backtrader as bt

class CommInfo_Fut_Perc_Mult(bt.CommInfoBase):
    params = (
      ('stocklike', False),  # Futures
      ('commtype', bt.CommInfoBase.COMM_PERC),  # Apply % Commission
    # ('percabs', False),  # pass perc as xx% which is the default
    )

    def _getcommission(self, size, price, pseudoexec):
        return size * price * self.p.commission * self.p.mult

```

Putting it into the system:

```
comminfo = CommInfo_Fut_Perc_Mult(
    commission=0.1,  # 0.1%
    mult=10,
    margin=2000  # Margin is needed for futures-like instruments
)

cerebro.addcommissioninfo(comminfo)

```

If the format 
0.xx
 is preferred as the default, just set param 
percabs

to 
True
:

```
class CommInfo_Fut_Perc_Mult(bt.CommInfoBase):
    params = (
      ('stocklike', False),  # Futures
      ('commtype', bt.CommInfoBase.COMM_PERC),  # Apply % Commission
      ('percabs', True),  # pass perc as 0.xx
    )

comminfo = CommInfo_Fut_Perc_Mult(
    commission=0.001,  # 0.1%
    mult=10,
    margin=2000  # Margin is needed for futures-like instruments
)

cerebro.addcommissioninfo(comminfo)

```

This all should do the trick.

Explaining 
pseudoexec

Let’s recall the definition of 
_getcommission
:

```
def _getcommission(self, size, price, pseudoexec):
    '''Calculates the commission of an operation at a given price

    pseudoexec: if True the operation has not yet been executed
    '''

```

The purpose of the 
pseudoexec
 arg may seem obscure but it serves a purpose.

The platform may call this method to do precalculation of available cash and
    some other tasks

This means that the method may (and it actually will) be called more than
    once with the same parameters

pseudoexec
 indicates whether the call corresponds to the actual execution of
an order. Although at first sight this may not seem “relevant”, it is if
scenarios like the following are considered:

A broker offers a 50% discount on futures round-trip commission once the
    amount of negotiated contracts has exceeeded 5000 units

In such case and if 
pseudoexec
 was not there, the multiple non-execution
calls to the method would quickly trigger the assumption that the discount
is in place.

Putting the scenario to work:

```
import backtrader as bt

class CommInfo_Fut_Discount(bt.CommInfoBase):
    params = (
      ('stocklike', False),  # Futures
      ('commtype', bt.CommInfoBase.COMM_FIXED),  # Apply Commission

      # Custom params for the discount
      ('discount_volume', 5000),  # minimum contracts to achieve discount
      ('discount_perc', 50.0),  # 50.0% discount
    )

    negotiated_volume = 0  # attribute to keep track of the actual volume

    def _getcommission(self, size, price, pseudoexec):
        if self.negotiated_volume > self.p.discount_volume:
           actual_discount = self.p.discount_perc / 100.0
        else:
           actual_discount = 0.0

        commission = self.p.commission * (1.0 - actual_discount)
        commvalue = size * price * commission

        if not pseudoexec:
           # keep track of actual real executed size for future discounts
           self.negotiated_volume += size

        return commvalue

```

The purpose and being of 
pseudoexec
 are hopefully clear now.

CommInfoBase docstring and params

See Commissions: Stocks vs Futures for the reference of

CommInfoBase
########################################
docu-writer.txt - lunghezza: 2314
########################################
Writer

Write out to a stream the following contents:

csv stream with data feeds, strategies, indicators and observers

Which objects actually go into the csv stream can be controlled with the

csv
 attribute of each object (defaults to True for 
data feeds
 and

observers
 / False for 
indicators
)

A summary of the properties of

Data Feeds

Strategies (lines and parameters)

Indicators/Observers: (lines and parameters)

Analyzers: (parameters and analysis outcome)

There is only a single Writer defined called 
WriterFile
, which can be added
to the system:

By setting the 
writer
 parameter of cerebro to True

A standard 
WriterFile
 will be instantiated

By calling 
Cerebro.addwriter(writerclass, **kwargs)

writerclass
 will be instantiated during backtesting execution with the
givenn 
kwargs

Given that a standard 
WriterFile
 does not ouput 
csv
 as a default,
the following 
addwriter
 invocation would take care of it:

```
cerebro.addwriter(bt.WriterFile, csv=True)

```

Reference

class backtrader.WriterFile()

The system wide writer class.

It can be parametrized with:

out
 (default: 
sys.stdout
): output stream to write to

If a string is passed a filename with the content of the parameter will
be used

close_out
  (default: 
False
)

If 
out
 is a stream whether it has to be explicitly closed by the
writer

csv
 (default: 
False
)

If a csv stream of the data feeds, strategies, observers and indicators
has to be written to the stream during execution

Which objects actually go into the csv stream can be controlled with
the 
csv
 attribute of each object (defaults to 
True
 for 
data
feeds
 and 
observers
 / False for 
indicators
)

csv_filternan
 (default: 
True
) whether 
nan
 values have to be
    purged out of the csv stream (replaced by an empty field)

csv_counter
 (default: 
True
) if the writer shall keep and print
    out a counter of the lines actually output

indent
 (default: 
2
) indentation spaces for each level

separators
 (default: 
['=', '-', '+', '*', '.', '~', '"', '^',
    '#']
)

Characters used for line separators across section/sub(sub)sections

seplen
 (default: 
79
)

total length of a line separator including indentation

rounding
 (default: 
None
)

Number of decimal places to round floats down to. With 
None
 no
rounding is performed
